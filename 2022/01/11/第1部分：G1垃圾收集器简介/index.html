<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"blog.gamedo.org","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.24.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="对大多数人来说，Java垃圾回收器是一个可以让用户愉快处理业务的黑匣子。程序开发程序，测试（QE）验证功能，运维负责部署。在这个过程中，你可能会对堆大小、PermGen&#x2F;Metaspace或线程进行一些调整，除此之外，似乎一切都运行正常。那么问题来了，当你准备打开这个匣子时会发生什么？当这些默认值不再满足需求时又将怎样呢？作为一名开发人员、测试人员、性能工程师或架构师，了解垃圾收集工作原">
<meta property="og:type" content="article">
<meta property="og:title" content="[译]第一篇：G1垃圾回收器简介">
<meta property="og:url" content="https://blog.gamedo.org/2022/01/11/%E7%AC%AC1%E9%83%A8%E5%88%86%EF%BC%9AG1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%AE%80%E4%BB%8B/index.html">
<meta property="og:site_name" content="听雨">
<meta property="og:description" content="对大多数人来说，Java垃圾回收器是一个可以让用户愉快处理业务的黑匣子。程序开发程序，测试（QE）验证功能，运维负责部署。在这个过程中，你可能会对堆大小、PermGen&#x2F;Metaspace或线程进行一些调整，除此之外，似乎一切都运行正常。那么问题来了，当你准备打开这个匣子时会发生什么？当这些默认值不再满足需求时又将怎样呢？作为一名开发人员、测试人员、性能工程师或架构师，了解垃圾收集工作原">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.redhat.com/cms/managed-files/heap-empty-regions.png">
<meta property="og:image" content="https://www.redhat.com/cms/managed-files/heap-eden-regions.png">
<meta property="og:image" content="https://www.redhat.com/cms/managed-files/heap-survivor-region.png">
<meta property="og:image" content="https://www.redhat.com/cms/managed-files/heap-old-region.png">
<meta property="og:image" content="https://www.redhat.com/cms/managed-files/heap-fillingup.png">
<meta property="og:image" content="https://www.redhat.com/cms/managed-files/heap-mixed-cycle.png">
<meta property="og:image" content="https://www.redhat.com/cms/managed-files/heap-mixed-cycle-after.png">
<meta property="og:image" content="https://www.redhat.com/cms/managed-files/heap-humongous.png">
<meta property="article:published_time" content="2022-01-11T09:57:00.000Z">
<meta property="article:modified_time" content="2025-08-12T06:47:53.950Z">
<meta property="article:author" content="临江听雨">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="JVM">
<meta property="article:tag" content="Hotspot">
<meta property="article:tag" content="G1垃圾回收">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.redhat.com/cms/managed-files/heap-empty-regions.png">


<link rel="canonical" href="https://blog.gamedo.org/2022/01/11/%E7%AC%AC1%E9%83%A8%E5%88%86%EF%BC%9AG1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%AE%80%E4%BB%8B/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://blog.gamedo.org/2022/01/11/%E7%AC%AC1%E9%83%A8%E5%88%86%EF%BC%9AG1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%AE%80%E4%BB%8B/","path":"2022/01/11/第1部分：G1垃圾收集器简介/","title":"[译]第一篇：G1垃圾回收器简介"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>[译]第一篇：G1垃圾回收器简介 | 听雨</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.9.0/mermaid.min.js","integrity":"sha256-Cz7UN0EXNjgV2u/a38wg/3BNfdRRO1XtgDq93L2GqJg="}}</script>
  <script src="/js/third-party/tags/mermaid.js" defer></script>





  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">听雨</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">临江听雨</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/pcloves" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;pcloves" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.gamedo.org/2022/01/11/%E7%AC%AC1%E9%83%A8%E5%88%86%EF%BC%9AG1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="临江听雨">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="听雨">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="[译]第一篇：G1垃圾回收器简介 | 听雨">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          [译]第一篇：G1垃圾回收器简介
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-01-11 17:57:00" itemprop="dateCreated datePublished" datetime="2022-01-11T17:57:00+08:00">2022-01-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-12 14:47:53" itemprop="dateModified" datetime="2025-08-12T14:47:53+08:00">2025-08-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E6%B2%89%E6%B7%80/" itemprop="url" rel="index"><span itemprop="name">技术沉淀</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>对大多数人来说，Java垃圾回收器是一个可以让用户愉快处理业务的黑匣子。程序开发程序，测试（QE）验证功能，运维负责部署。在这个过程中，你可能会对堆大小、PermGen&#x2F;Metaspace或线程进行一些调整，除此之外，似乎一切都运行正常。那么问题来了，当你准备打开这个匣子时会发生什么？当这些默认值不再满足需求时又将怎样呢？作为一名开发人员、测试人员、性能工程师或架构师，了解垃圾收集工作原理的基础知识，以及如何收集和分析相应的数据并将其转化为有效的调优实践，都是非常宝贵的技能。在本系列文章中，我将带你体验G1垃圾收集器，并把你从G1初学者转变为G1爱好者，并且将GC的性能优化到极致。</p>
<p>我们从最基本的话题开始：G1收集器的关键是什么？它是如何工作的？如果对于它的设计目标、如何决策以及如何设计没有一个综合性的理解。这就好比你设定好了目的地，但是却没有准备好交通工具或者导航地图。</p>
<p>G1收集器的核心目标是实现一个可预测的，软性的暂停时间，这个目标就是通过参数 <code>-XX:MaxGCPauseMillis</code> 定义的，与此同时也保持一贯的（consistent ）应用吞吐量。最终目标是满足当今高性能的、多线程的以及堆内存不断增大的应用程序的业务需求。G1的一般性原则是：暂停时间设置得越大，可实现的吞吐量和总延迟就越高。而暂停时间目标设置得越小，可实现的吞吐量和总延迟就越低。而你使用G1的目标就是结合应用程序的运行需求、自身特性以及对于G1的理解，调整出一组参数（options），并实现业务需求下的最佳运行状态。有一点需要牢记的是：调优是一个不断循序渐进的过程，在这个过程中，你需要通过反复地测试和评估来建立测试基线和调优设置。而对于调优这件事，并不存在一个明确的指南或者说万金油参数，你需要对性能进行评估，然后调整参数，再次评估，直到达到目标要求。</p>
<p>对于G1来说，它通过几种不同的方式来实现这些目标。首先，就像它的名字一样，G1收集存活对象数量最少的region（也即垃圾优先！），并将存活对象压缩&#x2F;转移（compacts&#x2F;evacuates）到新region。其次，G1使用了一系列逐步的、并行的、多阶段的循环来满足软暂停的目标。这允许G1在规定的时间内做最必要的事情，而不必考虑整个堆的大小。</p>
<p>在上文中，我们引入了一个新的概念： <code>区域</code> （regions）（译注：后文统一使用region）。简单来说，一个region代表一个已分配的堆内存区间，它可以存储任何分代的对象，并且不需要和同一代的其他region保持地址连续性。在G1中，传统的年轻代（Young ）和老年代（Tenured ）的概念仍然存在。年轻代包含Eden区和Survivor区，对象在Eden区创建，当发生GC时，对象被转移到Survivor区。存活对象一直待在Survivor区直到它们被回收或者由于年龄超过 <code>XX:MaxTenuringThreshold</code> （默认值为15）晋升到老年代。老年代包括Old region，当存活对象的年龄达到 <code>XX:MaxTenuringThreshold</code> 时就从Survivor区晋升到该区。当然万事都有例外，我们会在后文详细讨论。当虚拟机启动时，region的数量就被计算出来了。并且遵循这么一个原则：region的数量尽量的接近2048，每个region的大小都是1MB到64MB之间，并且该值是2的指数幂（2^n）。简单举例，假设存在一个12GB大小的堆，那么：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">12288 MB / 2048 = 6 MB  - 6不是2的指数幂，不符合要求</span><br><span class="line">12288 MB / 8 MB = 1536  - 1536个region有些小</span><br><span class="line">12288 MB / 4 MB = 3072  - 嗯，可以接受</span><br></pre></td></tr></table></figure>

<p>根据上面的计算，默认情况下JVM虚拟机会分成3072个region，每个region的大小为4MB，正如如下图所示。当然，你也可以通过设置参数： <code>-XX:G1HeapRegionSize</code> 显式的设置region的个数。当手动设置region数量时，理解堆大小与region数量的比值就显得非常重要，因为region数量越少，G1的灵活性就会越低，扫描、标记和收集每个region所需的时间也就越长。不管什么情况下，空的region都会添加到被称为“<strong>空闲列表</strong>”（free list）的无序链表中。</p>
<p><img src="https://www.redhat.com/cms/managed-files/heap-empty-regions.png"></p>
<p>虽然G1是一个分代的垃圾收集器，但是在堆空间上分配和使用并非连续的，因为它需要动态调整年轻代和老年代的配比，以达到最佳性能。当对象开始被分配时，会从<strong>空闲列表</strong>中分配一个region作为<strong>本地线程分配缓冲区</strong>（TLAB），该分配操作通过CAS确保同步性。之后对象就从该缓存区中创建而不需要额外同步。当某region的空间被对象填满后，会选择一个新的region继续填充。当所有Eden区的region都被填满时，会触发一次 <code>转移暂停</code>（<code>evacuation pause</code> ， 也称作 young collection &#x2F; young gc &#x2F; young pause或者mixed collection &#x2F; mixed gc &#x2F; mixed pause），Eden区内region的数量就大致就代表了软暂停时间内需要垃圾回收的region数量。整个堆分配的Eden region的数量介于5%和60%之间，并且在每次young gc后基于本次yong gc的性能情况进行动态调整。</p>
<p>以下是将对象分配到非连续Eden区的示意图</p>
<p><img src="https://www.redhat.com/cms/managed-files/heap-eden-regions.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GC pause (young); #1</span><br><span class="line">          [Eden: 612.0M(612.0M)-&gt;0.0B(532.0M) Survivors: 0.0B-&gt;80.0M Heap: 612.0M(12.0G)-&gt;611.7M(12.0G)]</span><br><span class="line">GC pause (young); #2</span><br><span class="line">          [Eden: 532.0M(532.0M)-&gt;0.0B(532.0M) Survivors: 80.0M-&gt;80.0M Heap: 1143.7M(12.0G)-&gt;1143.8M(12.0G)]</span><br></pre></td></tr></table></figure>

<p>根据上面的 <code>GC pause (young)</code> 日志，我们可以发现在 <strong>#1</strong>所示的暂停中，由于Eden区达到了 <strong>612.0M</strong> （总空间为也<strong>612.0M</strong>，一共153个region）而触发转移（evacuation）操作。整个Eden区域都被转移（<strong>0.0B</strong>）。鉴于本次GC所消耗的时间，Eden区还被缩减到<strong>532.0M</strong>（133个region）。在**#2<strong>所示的暂停中，我们看到由于达到了</strong>532.0M<strong>的上限，转移操作再次触发。并且由于暂停时间符合预期，Eden区仍然保持在</strong>532.0M**。</p>
<blockquote>
<p>译注：</p>
<p>有些文章会把evacuation翻译为<strong>拷贝</strong>或<strong>疏散</strong>，本文使用《深入Java虚拟机：JVM G1GC的算法与实现》一书中的译法，翻译为<strong>转移</strong></p>
</blockquote>
<p>当上述young gc发生时，死亡对象被回收，存活对象被转移并压缩到Survivor区。G1收集器包含一个由<strong>G1ReservePercent</strong>（默认值为10%）明确定义的硬性边界，这个边界保证了在转移时整堆中总有一部分空间作为Survivor区。而如果没有这个硬性边界，整个堆都会被耗光直到没有内存空间用来做转移。我们并不能拍胸脯说这种情况绝对不会发生，所以说这也是一个调优参数。这一原则可以确保在每次成功转移后，之前所有分配的Eden region都返回到<strong>空闲列表</strong>中，所有被转移的生存对象最终进入Survivor区。</p>
<p>下图是一个标准的young gc的示意图：</p>
<p><img src="https://www.redhat.com/cms/managed-files/heap-survivor-region.png"></p>
<p>我们继续上面的流程，新对象会再次被分配到Eden区。当Eden空间被填满时，又会触发一次young gc。根据现有存活对象的年龄(所谓年龄，就是对象撑过了多少次的young gc)，对象将会晋升到Old region。由于Survivor空间是年轻代的一部分，在年轻代gc（young pauses）期间，对象会被回收或者晋升。</p>
<p>下面是一个young gc的示例，Survivor区的存活对象被转移到一个新的Old region，而来自Eden区的存活对象被转移到新的Survivor区。而那些执行转移的region（删除线所示）会变成空的，并且重新回到空闲列表中。</p>
<p><img src="https://www.redhat.com/cms/managed-files/heap-old-region.png"></p>
<p>G1会按照这种方式持续执行，直到遇到如下三种事件中的任意一种：</p>
<ol>
<li>当G1触及到一个可配置的被称为<strong>InitiatingHeapOccupencyPercent</strong>（IHOP）的软边界。</li>
<li>当G1触及到一个可配置的硬边界：<strong>G1ReservePercent</strong></li>
<li>当G1触发了一次大对象分配（humongous allocation，这正是上文说的那个例外，下面会详细介绍）</li>
</ol>
<p>先讨论最常见的情形，IHOP事件代表young gc期间的某个时间点，此时Old region内的对象超过了整堆的45%（默认值）。该百分比作为young gc的一个组成部分，被不断地计算和评估。当三种情形中的任意一种被触发，就会发出请求启动<strong>并发标记周期</strong>（concurrent marking cycle）。</p>
<blockquote>
<p>译注：</p>
<ol>
<li>关于<strong>InitiatingHeapOccupencyPercent</strong>参数，在JDK-6976060之前，计算方式为：整堆的使用量 &#x2F; 整堆大小，而之后是：Old region（包括humongous region）的使用量 &#x2F; 整堆大小，具体详情可以参考 [R大的解答]([<a href="https://hllvm-group.iteye.com/group/topic/44381?page=3">HotSpot VM] 请教G1算法的原理讨论第3页: - 资料 - 高级语言虚拟机 - ITeye群组</a>)</li>
<li>这里所说的<strong>并发标记周期</strong>也叫做<strong>全局并发标记</strong>（global concurrent marking），指的是包括：初始标记、并发标记、最终标记、清理这几个阶段的统称，不要和其中的并发标记阶段混淆</li>
</ol>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">8801.974: [G1Ergonomics (Concurrent Cycles) request concurrent cycle initiation, reason: occupancy higher than threshold, occupancy: 12582912000 bytes, allocation request: 0 bytes, threshold: 12562779330 bytes (45.00 %), source: end of GC]</span><br><span class="line">8804.670: [G1Ergonomics (Concurrent Cycles) initiate concurrent cycle, reason: concurrent cycle initiation requested]</span><br><span class="line">8805.612: [GC concurrent-mark-start]</span><br><span class="line">8820.483: [GC concurrent-mark-end, 14.8711620 secs]</span><br></pre></td></tr></table></figure>

<p>G1的并发标记基于初始快照（snapshot-at-the-beginning, SATB）的原理。这意味着只有被快照“拍下”的存活对象才会参与是否为垃圾的识别，这当然是出于效率考虑。而并发标记期间任何新分配的对象都被认为是绝对存活的对象，不管它的实际存活状态如何。意识到这么一点非常重要：并发标记的时间越长，可收集对象和绝对存活对象的比值就会越大（译注：原文为：This is important because the longer it takes for concurrent marking to complete, the higher the ratio will be of what is collectible versus what is considered to be implicitly live.）。如果在并发标记期间分配的对象多于最终回收的对象，堆内存最终会被耗尽。在<strong>并发标记周期</strong>中，你会发现young gc会持续进行，因为在并发标记周期中，不是每个子阶段都会导致STW（stop-the-world）。</p>
<p>下图展示了当一次young gc结束后且达到IHOP 阈值时堆空间。</p>
<p><img src="https://www.redhat.com/cms/managed-files/heap-fillingup.png"></p>
<p>一旦并发标记周期完成，紧接着就是一次young gc，随后是第2种类型的转移，这被称为mixed gc。mixed gc和young gc的工作方式几乎相同，但是有两个主要区别。首先，mixed gc还会回收、转移并压缩被选定的Old region。其次，mixed gc的转移不同于young gc的转移。它的工作目标是尽可能快速、频繁的回收。这样做的目的是为了在软性暂停时间内最小化Eden &#x2F; Survivor区的数量，使得Old region的数量最大化。</p>
<blockquote>
<p>译注：</p>
<p>关于上面说的：最小化Eden &#x2F; Survivor区的数量，可以参考：[G1Policy::calculate_young_list_desired_min_length](<a href="https://github.com/openjdk/jdk17u/blob/master/src/hotspot/share/gc/g1/g1Policy.cpp#L183">jdk17u&#x2F;g1Policy.cpp at master · openjdk&#x2F;jdk17u (github.com)</a>)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8821.975: [G1Ergonomics (Mixed GCs) start mixed GCs, reason: candidate old regions available, candidate old regions: 553 regions, reclaimable: 6072062616 bytes (21.75 %), threshold: 5.00 %]</span><br></pre></td></tr></table></figure>

<p>上面的log日志展示了一次mixed gc，候选Old region的数量（553）含有21.75%的可回收空间，这个值高于<strong>G1HeapWastePercent</strong>所规定的5%的最小阈值（JDK8u40+默认为5%，JDK7默认为10%），正因如此mixed gc被触发。鉴于不能执行费时的操作，G1会恪守垃圾优先的策略：根据候选Old region存活对象占比，决定是否将其加入到有序的回收候选列表中。如果一个Old region内的存活对象小于<strong>G1MixedGCLiveThresholdPercent</strong> 所规定的百分比（JDK8u4+默认为85%，JDK7默认值为65%），该Old region就被加入到回收候选列表中。反而言之，如果一个Old region内存活对象的比率大于65%（JDK7）或85%（JDK8u40+），G1就不再浪费时间在这次mixed gc中对其进行回收和转移。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8822.178: [GC pause (mixed) 8822.178: [G1Ergonomics (CSet Construction) start choosing CSet, _pending_cards: 74448, predicted base time: 170.03 ms, remaining time: 829.97 ms, target pause time: 1000.00 ms]</span><br></pre></td></tr></table></figure>

<p>与young gc相比，mixed gc使用相同的暂停时间，而回收的region却横跨3个region（译注：Eden、Survivor、Old）。它是通过<strong>G1MixedGCCountTarget</strong> （默认值为8）实现对Old region的逐步（incremental ）回收的。具体来讲，它是将候选回收列表中Old region的数量除以<strong>G1MixedGCCountTarget</strong> （译注：假设商为<strong>X</strong>），然后在接下来的mixed gc循环中每次最少都要收集<strong>X</strong>个Old region。回收完毕后，如果可回收region仍然大于<strong>G1HeapWastePercent</strong>，mixed gc循环就会持续下去。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8822.704: [G1Ergonomics (Mixed GCs) continue mixed GCs, reason: candidate old regions available, candidate old regions: 444 regions, reclaimable: 4482864320 bytes (16.06 %), threshold: 10.00 %]</span><br></pre></td></tr></table></figure>

<p>下图展示了一次mixed gc。所有的Eden区都会被回收并转移到Survivor区。所有的Survivor区也会被回收，根据年龄的不同，足够老的存活对象会晋升到老年代。与此同时，也会选择一组Old region进行回收，这些region内的存活对象会被压缩并转移到新的Old region中。这种压缩和转移的过程可以显著减少内存碎片，同时保证空闲列表中有足够的空闲region。</p>
<p><img src="https://www.redhat.com/cms/managed-files/heap-mixed-cycle.png"></p>
<p>下图展示了当mixed gc结束后堆内存的状态。所有的Eden区域都被回收，存活对象被转移到新分配的Survivor区域。原来的Survivor也被回收，（满足条件的）存活对象晋升到Old region中。回收候选列表中的Old region会重新返回空闲列表，同时仍然存活的对象被压缩、转移到新的Old region。</p>
<p><img src="https://www.redhat.com/cms/managed-files/heap-mixed-cycle-after.png"></p>
<p>mixed gc会持续进行直到这个8次（译注：也即<strong>G1MixedGCCountTarget</strong> ）循环结束，或者可回收百分比小于<code>G1HeapWastePercent</code>。此时，mixed gc循环结束，接下来回归到标准的young gc中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8830.249: [G1Ergonomics (Mixed GCs) do not continue mixed GCs, reason: reclaimable percentage not over threshold, candidate old regions: 58 regions, reclaimable: 2789505896 bytes (9.98 %), threshold: 10.00 %]</span><br></pre></td></tr></table></figure>

<p>目前我们已经讨论了常见的场景。我们回过头来讨论前面提到的异常情况。这种异常就是当分配的对象大于region的50%。在这种情况下，这个对象就被认为是大对象（humongous），并且会执行专门的大对象分配（humongous allocations）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Region Size: 4096 KB</span><br><span class="line">Object A: 12800 KB</span><br><span class="line">Result: Humongous Allocation across 4 regions</span><br></pre></td></tr></table></figure>

<p>下图展示了一个<strong>12.5MB</strong>的大对象横跨4个连续region的情况</p>
<p><img src="https://www.redhat.com/cms/managed-files/heap-humongous.png"></p>
<ol>
<li>大对象仅仅是一个对象，因此需要被分配到连续的region中，这可能会导致严重的碎片化。</li>
<li>大对象被直接分配到老年代中特殊的大对象region（humongous region）中。这是因为如果分配到年轻代，那么转移和复制这个大对象的成本太高。</li>
<li>尽管上图中的对象只有<strong>12.5MB</strong>，他也必须使用4个完整的region，总容量为16MB</li>
<li>大对象分配总是会触发一次并发标记循环，不管是否达到IHOP的阈值</li>
</ol>
<p>少量的大对象分配可能不会引起什么问题，但是如果它们被持续地分配就会导致明显的碎片化，同时带来显著的性能影响。在JDK8u40之前，大对象仅在Full gc时才会被回收，对于JDK7和JDK8的早期版本来说，这个影响非常大。这就是为什么掌握应用程序中对象大小和G1的region大小是至关重要的。尽管如此，在最新的JDK8中（译注：本文写于2016年12月6日），如果你的应用程序需要分配大量的大对象，那么反复的评估和调优绝对是一件好事。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4948.653: [G1Ergonomics (Concurrent Cycles) request concurrent cycle initiation, reason: requested by GC cause, GC cause: G1 Humongous Allocation]</span><br><span class="line">7677.280: [G1Ergonomics (Concurrent Cycles) do not request concurrent cycle initiation, reason: still doing mixed collections, occupancy: 14050918400 bytes, allocation request: 16777232 bytes, threshold: 12562779330 32234.274: [G1Ergonomics (Concurrent Cycles) request concurrent cycle initiation, reason: occupancy higher than threshold, occupancy: 12566134784 bytes, allocation request: 9968136 bytes, threshold: 12562779330 bytes (45.00 %), source: concurrent humongous allocation]</span><br></pre></td></tr></table></figure>

<p>最后也是最不幸的是，G1也不得不执行可怕的Full GC。尽管G1会极力避免Full gc，但如果调优不当，那么Full gc就仍然是一个很残酷的现实。鉴于G1的目标是管理更大的堆内存，Full gc可能会对线上业务和SLA（译注：这是什么）造成灾难性的影响。一个最主要的原因就是G1的Full gc是单线程的。如果讨论Full gc的原因，第一个也最应该避免的原因就和元空间（Metaspace）有关。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Full GC (Metadata GC Threshold) 2065630K-&gt;2053217K(31574016K), 3.5927870 secs]</span><br></pre></td></tr></table></figure>

<p>一个最新消息是：当更新到JDK8u40+，类卸载就不再需要一次Full gc！仍然可能遇到和元空间有关的 Full gc，但这已经是UseCompressedOops及UseCompressedClassSpoInters或并发标记所需的时间有关了（我们将在以后的文章中讨论）。</p>
<p>接下来导致Full gc的两个原因很真实，而且往往是不可避免的。作为码农，我们的工作是尽最大努力优化和评估创建对象的代码，从而延后和避免这两种情况的发生。其中一个原因是“转移目标空间耗尽”（to-space exhausted），随之而来的是一次Full gc。这说明转移失败（evacuation failures）了，也即堆空间无法再扩展（译注：也就是达到Xmx的配置）且没有可用空间执行转移操作。如果您还记得的话，我们之前讨论过由<strong>G1ReservePercent</strong>定义的硬边界事件。这表示需要转移到to-space的空间超出了您的可用（reserve）空间，并且堆空间已经彻底满了，因此没有可用region执行转移操作。在某些情况下，如果JVM能够解决空间问题，那么后面就不会有Full gc，但这仍然是一个代价非常昂贵的STW事件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6229.578: [GC pause (young) (to-space exhausted), 0.0406140 secs]</span><br><span class="line">6229.691: [Full GC 10G-&gt;5813M(12G), 15.7221680 secs]</span><br></pre></td></tr></table></figure>

<p>如果你发现这种情形经常发生，你应该立刻意识到有很大的调优空间。另外一个原因就是并发标记期间的Full gc。在这种情况下，g1并没有转移失败，只是在并发标记完成并触发mixed gc之前用光了堆空间。这两个原因根源要么是内存泄漏，要么是对象分配和晋升的速度超过了g1的回收速度。如果 Full gc的占比很大，那么可以假设是因为对象分配和晋升有关。如果占比很小，并且最终遇到 OutOfMemoryError，那么就应该排查是否有内存泄漏。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">57929.136: [GC concurrent-mark-start]</span><br><span class="line">57955.723: [Full GC 10G-&gt;5109M(12G), 15.1175910 secs]</span><br><span class="line">57977.841: [GC concurrent-mark-abort]</span><br></pre></td></tr></table></figure>

<p>最后，我希望这篇文章能够帮助你了解G1的设计方式，以及它是如何做出垃圾回收决策的。我希望您继续关注本系列的下一篇文章，我们将深入挖掘各种JVM参数，以收集和解释通过GC日志产生的海量数据。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
              <a href="/tags/JVM/" rel="tag"># JVM</a>
              <a href="/tags/Hotspot/" rel="tag"># Hotspot</a>
              <a href="/tags/G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" rel="tag"># G1垃圾回收</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/05/20/Spring%20Boot%20Actuator%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/" rel="prev" title="Spring Boot Actuator官方参考文档（2.5.0）翻译（完结）">
                  <i class="fa fa-angle-left"></i> Spring Boot Actuator官方参考文档（2.5.0）翻译（完结）
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/07/01/Vert.x%20OAuth2%E8%AE%A4%E8%AF%81/" rel="next" title="Vert.x OAuth2认证">
                  Vert.x OAuth2认证 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">临江听雨</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
