<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"blog.gamedo.org","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.24.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="听雨">
<meta property="og:url" content="https://blog.gamedo.org/page/2/index.html">
<meta property="og:site_name" content="听雨">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="临江听雨">
<meta property="article:tag" content="GameDev">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://blog.gamedo.org/page/2/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>听雨</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.9.0/mermaid.min.js","integrity":"sha256-Cz7UN0EXNjgV2u/a38wg/3BNfdRRO1XtgDq93L2GqJg="}}</script>
  <script src="/js/third-party/tags/mermaid.js" defer></script>





  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">听雨</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">临江听雨</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/pcloves" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;pcloves" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.gamedo.org/2021/03/26/netty%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="临江听雨">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="听雨">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 听雨">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/26/netty%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">netty源码学习笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-26 15:00:00" itemprop="dateCreated datePublished" datetime="2021-03-26T15:00:00+08:00">2021-03-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-12 14:47:53" itemprop="dateModified" datetime="2025-08-12T14:47:53+08:00">2025-08-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E6%B2%89%E6%B7%80/" itemprop="url" rel="index"><span itemprop="name">技术沉淀</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="ChannelId的那些事儿"><a href="#ChannelId的那些事儿" class="headerlink" title="ChannelId的那些事儿"></a>ChannelId的那些事儿</h2><h3 id="ChannelId组成"><a href="#ChannelId组成" class="headerlink" title="ChannelId组成"></a>ChannelId组成</h3><p><code>ChannelId</code>默认由<code>io.netty.channel.DefaultChannelId</code>实现，最终结果存储在一个<code>data</code>的byte数组中，data数组内由5个字段组成，从低位到高位分别是：6或8字节的<code>MACHINE_ID</code>，4字节的<code>PROCESS_ID</code>，4字节的<code>SEQUENCE</code>，8字节的<code>TIMESTAMP</code>和4字节的<code>RANDOM</code>，下表以8字节的&#96;MACHINE_ID举例：</p>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">RANDOM</th>
<th align="center">TIMESTAMP</th>
<th align="center">SEQUENCE</th>
<th align="center">PROCESS_ID</th>
<th align="center">MACHINE_ID</th>
</tr>
</thead>
<tbody><tr>
<td align="center">字节</td>
<td align="center">[27-24]（4字节）</td>
<td align="center">[23-16]（8字节）</td>
<td align="center">[15-12]（4字节）</td>
<td align="center">[11-8]（4字节）</td>
<td align="center">[7-0]（6或8字节）</td>
</tr>
<tr>
<td align="center">说明</td>
<td align="center">随机</td>
<td align="center">自定义</td>
<td align="center">初值为0，每次递增1</td>
<td align="center">优先从系统属性<strong>io.netty.processId</strong>获取，类型为int</td>
<td align="center">优先从系统属性<strong>io.netty.machineId</strong>获取，类型为String，长度为17或23</td>
</tr>
</tbody></table>
<p>在DefaultChannelId的实现中，**<code>TIMESTAMP</code>**字段并没有直接使用系统的时间戳，例如：<code>System.nanoTime()</code>，而是自定义了一个时间戳生成方法：<code>Long.reverse(System.nanoTime()) ^ System.currentTimeMillis()</code>，举例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="variable">nanoTime</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="variable">timeMillis</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="variable">xorValue</span> <span class="operator">=</span> nanoTime ^ timeMillis;</span><br><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="variable">reverse</span> <span class="operator">=</span> Long.reverse(xor);</span><br><span class="line"></span><br><span class="line">log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, String.format(<span class="string">&quot;%64s&quot;</span>, Long.toBinaryString(nanoTime)));</span><br><span class="line">log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, String.format(<span class="string">&quot;%64s&quot;</span>, Long.toBinaryString(timeMillis)));</span><br><span class="line">log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, String.format(<span class="string">&quot;%64s&quot;</span>, Long.toBinaryString(xorValue)));</span><br><span class="line">log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, String.format(<span class="string">&quot;%64s&quot;</span>, Long.toBinaryString(reverse)));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出如下所示</span></span><br><span class="line"><span class="comment">:                   1111111100000110011110111010001111000001000000   -nanoTime</span></span><br><span class="line"><span class="comment">:                        10111100001101101100000001000101100110110   -timeMillis</span></span><br><span class="line"><span class="comment">:                   1111101011100111110011011010000111101101110110   -xorValue</span></span><br><span class="line"><span class="comment">:  110111011011110000101101100111110011101011111000000000000000000   -reverse，也即将xorValue换成2进制后，头尾互掉后的值</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>至于Netty为什么这么设计，只是在源码中有一句简单的注释：<code>// timestamp (kind of)</code>，翻译过来就是一种（Netty式的）时间戳，可能就是想这么实现吧。</p>
<h3 id="ChannelId的表示"><a href="#ChannelId的表示" class="headerlink" title="ChannelId的表示"></a>ChannelId的表示</h3><p><code>ChannelId</code>有两个函数：<code>asShortText()</code>和<code>asLongText()</code>，</p>
<ul>
<li><p><code>asShortText()</code>使用懒加载的方式，输出**<code>RANDOM</code><strong>字段转换成16进制并存储到<code>String shortValue</code>，例如：</strong>60fb0e5f**</p>
</li>
<li><p><code>asLongText()</code>也采用懒加载的方式，将data数组中的5个字段转换成16进制以后，从**<code>MACHINE_ID</code><strong>开始，到</strong><code>RANDOM</code><strong>结束，用“-”连起来，最后存储到<code>String longValue</code>中，例如：</strong>00000000000000e0-00003738-00000000-3a5715eac38e517e-60fb0e5f**</p>
</li>
</ul>
<h2 id="bind那些事儿"><a href="#bind那些事儿" class="headerlink" title="bind那些事儿"></a>bind那些事儿</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ServerBootstrap-&gt;ReflectiveChannelFactory: newChannel()</span><br><span class="line">ServerBootstrap-&gt;ServerBootstrap: 1. initChannel(Channel)</span><br><span class="line">ServerBootstrap-&gt;EventLoopGroup: register(Channel)</span><br></pre></td></tr></table></figure>

<p>在上述的<code>1. initChannel(Channel)</code>中，执行了了一个重要的操作：new了一个匿名的<code>ChannelInitializer</code>并且addLast到传入的<code>Channel</code>的<code>ChannelPipeline</code>中，该<code>ChannelInitializer</code>主要执行了两件事：</p>
<ul>
<li>当<code>ChannelInitializer.initChannel</code>回调被调用时，将<code>ServerBootstrap</code>的<code>ChannelHandler</code> addList到<code>Channel.pipeline()</code>，而<code>ServerBootstrap</code>的<code>ChannelHanlder</code>可以在构造时通过<code>handler(ChannelHandler)</code>传入，例如传入一个<code>new LoggingHandler(LogLevel.INFO)</code>，从而实现log输出，有两点需要注意：<ul>
<li><code>ChannelInitializer.initChannel</code>回调时，发生在<code>ServerBootstrap.group</code>中（也即大家常用的BossGroup），此时还没有注册到<code>ServerBootstrap.childGroup</code>中（也即大家常用的WorkerGroup）。</li>
<li>该ChannelHandler全局只有一个，会被所有的EventLoop共享包括<code>ServerBootstrap.group</code>和<code>ServerBootstrap.childGroup</code>在内的所有<code>EventLoop</code></li>
</ul>
</li>
<li>当<code>ChannelInitializer.initChannel</code>回调被调用时，调用了<code>Channel</code>的<code>EventLoop</code>（该<code>EventLoop</code>隶属于父线程池）并执行了一个异步任务：向<code>Channel.pipeline()</code>中addLast了一个<code>new ServerBootstrapAcceptor</code>，<code>ServerBootstrapAcceptor</code>执行了两件重要的事情：<ul>
<li>将<code>ServerBootstrap.childHandler</code> addLast到<code>Channel.pipeline()</code></li>
<li>调用<code>ServerBootstrap.childGroup.register(Channel)</code>将<code>Channel</code>注册到子线程池（所以<code>AbstractChannel</code>声明成员变量<code>eventLoop</code>时使用了<code>volatile</code>关键字修饰）</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.gamedo.org/2021/03/22/gamedo.persistence%E6%8C%81%E4%B9%85%E5%8C%96%E6%A1%86%E6%9E%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="临江听雨">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="听雨">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 听雨">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/22/gamedo.persistence%E6%8C%81%E4%B9%85%E5%8C%96%E6%A1%86%E6%9E%B6/" class="post-title-link" itemprop="url">gamedo.persistence持久化框架</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-03-22 13:00:00 / 修改时间：13:45:07" itemprop="dateCreated datePublished" datetime="2021-03-22T13:00:00+08:00">2021-03-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AE%9E%E8%B7%B5%E7%BB%8F%E9%AA%8C/" itemprop="url" rel="index"><span itemprop="name">实践经验</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AE%9E%E8%B7%B5%E7%BB%8F%E9%AA%8C/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">游戏开发</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://img.shields.io/github/license/pcloves/gamedo.persistence?style=flat-square" alt="GitHub"><img src="https://img.shields.io/github/v/tag/pcloves/gamedo.persistence?style=flat-square" alt="GitHub tag (latest by date)"><img src="https://img.shields.io/maven-central/v/org.gamedo/persistence?style=flat-square" alt="Maven Central"><img src="https://img.shields.io/github/workflow/status/pcloves/gamedo.persistence/Java%20CI%20with%20Maven?style=flat-square" alt="GitHub Workflow Status"></p>
<h1 id="gamedo-persistence"><a href="#gamedo-persistence" class="headerlink" title="gamedo.persistence"></a>gamedo.persistence</h1><p>gamedo.persistence是gamedo游戏服务器框架的持久化模块。它底层依赖于spring-data-mongodb，致力于构建一个 <strong>高性能、简单易用、易于维护</strong> 的游戏服务器持久化模块。同时，gamedo.persistence吸收了ECS设计模式的思想，也即：“组合优于继承”（这也是开发中的gamedo.ecs模块的一大个特性）。通过对底层的设计，将游戏持久化对象数据约束为Entity-Components（也即一个实体由多个组件组合而成）的形式，从而统一团队成员对于游戏对象数据的规范化设计和使用。</p>
<h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><h3 id="Maven配置"><a href="#Maven配置" class="headerlink" title="Maven配置"></a>Maven配置</h3><p>增加Maven依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.gamedo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>persistence<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><ol>
<li>定义游戏对象数据使之继承自<strong>EntityDbData</strong>，并使用 <strong>@Document</strong>注解来指定该持久化对象数据要持久化到MongoDB的哪一个Document中，一般情况下，该类内不再增加新的成员变量，因为数据应该存储在<strong>ComponentDbData</strong>的子类中，例如定义个玩家类：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Document(&quot;player&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EntityDbPlayer</span> <span class="keyword">extends</span> <span class="title class_">EntityDbData</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EntityDbPlayer</span><span class="params">(String id, Map&lt;String, ComponentDbData&gt; componentDbDataMap)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(id, componentDbDataMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>根据开发需求，定义不同的组件数据类，也即是 <strong>ComponentDbData</strong>的子类，并使用和<strong>EntityDbPlayer</strong>相同的 <strong>@Document</strong>注解，确保被持久化到同一个Document中，例如定义一个背包类</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EqualsAndHashCode(callSuper = true)</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Document(&quot;player&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComponentDbPlayerInfo</span> <span class="keyword">extends</span> <span class="title class_">ComponentDbData</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> level;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EqualsAndHashCode(callSuper = true)</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Document(&quot;player&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComponentDbBag</span> <span class="keyword">extends</span> <span class="title class_">ComponentDbData</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">final</span> List&lt;Integer&gt; itemList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>定义<strong>EntityDbPlayer</strong>的转换器（属于样板代码，不需要实现逻辑），由于gamedo.persistence在设计过程中，使用了使用了自定义转换器对EntityDbData类进行序列化和反序列化，因此其子类也需要继承 <strong>AbstractEntityDbDataReadingConverter</strong>和 <strong>AbstractEntityDbDataWritingConverter</strong>并加上**@Component**注解，目的可以正确加载到spring的IOC容器中</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ReadingConverter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EntityDbPlayerReadingConverter</span> <span class="keyword">extends</span> <span class="title class_">AbstractEntityDbDataReadingConverter</span>&lt;EntityDbPlayer&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EntityDbPlayerReadingConverter</span><span class="params">(MongoConfiguration configuration)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(configuration);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@WritingConverter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EntityDbPlayerWriterConverter</span> <span class="keyword">extends</span> <span class="title class_">AbstractEntityDbDataWritingConverter</span>&lt;EntityDbPlayer&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EntityDbPlayerWriterConverter</span><span class="params">(MongoConfiguration configuration)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(configuration);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>搞定！接下来就是使用gamedo.persistence了</li>
</ol>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@SpringBootApplication(scanBasePackages = &#123;&quot;org.gamedo&quot;, &quot;org.gamedo.persistence&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ConfigurableApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> SpringApplication.run(Application.class, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、从容器中获取DbDataMongoTemplate（不能通过new操作符获取DbDataMongoTemplate，否则不具有异步持久化能力）</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">DbDataMongoTemplate</span> <span class="variable">dataMongoTemplate</span> <span class="operator">=</span> applicationContext.getBean(DbDataMongoTemplate.class);</span><br><span class="line">        <span class="comment">//2、创建一个玩家持久化对象类：EntityDbPlayer</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">EntityDbPlayer</span> <span class="variable">entityDbPlayer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EntityDbPlayer</span>(<span class="keyword">new</span> <span class="title class_">ObjectId</span>().toString(), <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、增加一个组件数据：ComponentDbData</span></span><br><span class="line">        entityDbPlayer.addComponentDbData(<span class="keyword">new</span> <span class="title class_">ComponentDbBag</span>(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()));</span><br><span class="line">        entityDbPlayer.addComponentDbData(<span class="keyword">new</span> <span class="title class_">ComponentDbPlayerInfo</span>(<span class="string">&quot;testName&quot;</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4、调用同步save函数，将完整的EntityDbPlayer持久化到MongoDB中</span></span><br><span class="line">        dataMongoTemplate.save(entityDbPlayer);</span><br><span class="line">        <span class="comment">//4.1、同步方式实现异步调用save函数，该方法会把entityDbPlayer安全地发布到db线程后，就直接返回。</span></span><br><span class="line">        dataMongoTemplate.saveAsync(entityDbPlayer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接下来是gamedo.persistence提供的线程安全的异步增量更新的功能---------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//应用层</span></span><br><span class="line">        <span class="comment">//5、获取组件数据</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ComponentDbBag</span> <span class="variable">componentDbData</span> <span class="operator">=</span> entityDbPlayer.getComponentDbData(ComponentDbBag.class);</span><br><span class="line">        <span class="comment">//6、修改数据</span></span><br><span class="line">        componentDbData.getItemList().add(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//7、对修改的变量进行标脏</span></span><br><span class="line">        componentDbData.setDirty(<span class="string">&quot;itemList&quot;</span>, componentDbData.getItemList());</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">//存储层</span></span><br><span class="line">        <span class="comment">//8、进行异步更新，并通过CompletableFuture检查执行结果</span></span><br><span class="line">        <span class="keyword">if</span>(componentDbData.isDirty())</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">final</span> CompletableFuture&lt;UpdateResult&gt; future = dataMongoTemplate.updateFirstAsync(componentDbData);</span><br><span class="line">          <span class="comment">//9、可以检查执行结果</span></span><br><span class="line">          future.whenCompleteAsync((result, t) -&gt; &#123;</span><br><span class="line">              <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">                  log.error(<span class="string">&quot;exception caught.&quot;</span>, t);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  log.info(<span class="string">&quot;update async finish, result:&#123;&#125;&quot;</span>, result);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              applicationContext.close();</span><br><span class="line">          &#125;);</span><br><span class="line"></span><br><span class="line">          log.info(<span class="string">&quot;application run finish.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当执行完第4步或第4.1步后，MongoDB中数据为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">    &quot;_id&quot; : ObjectId(&quot;6058279e4cff6830d4ff1fd1&quot;), </span><br><span class="line">    &quot;_class&quot; : &quot;org.gamedo.db.EntityDbPlayer&quot;, </span><br><span class="line">    &quot;ComponentDbBag&quot; : &#123;</span><br><span class="line">        &quot;itemList&quot; : [], </span><br><span class="line">        &quot;_class&quot; : &quot;org.gamedo.db.ComponentDbBag&quot;</span><br><span class="line">    &#125;, </span><br><span class="line">    &quot;ComponentDbPlayerInfo&quot; : &#123;</span><br><span class="line">        &quot;name&quot; : &quot;testName&quot;, </span><br><span class="line">        &quot;level&quot; : NumberInt(1), </span><br><span class="line">        &quot;_class&quot; : &quot;org.gamedo.db.ComponentDbPlayerInfo&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第5<del>9步骤属于gamedo.persistence提供的<strong>异步</strong>的<strong>局部增量更新</strong>的特性，在团队协作开发中，一般会把第8</del>9步封装到一个单独的模块中，进行统一的持久化操作，比如每隔5秒检查 **DbData.isDirty()**，并进行异步局部增量更新，而对于上层使用者只需要进行标脏操作即可。</p>
<p>当程序运行结束后，MongoDB中数据为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">    &quot;_id&quot; : ObjectId(&quot;6058279e4cff6830d4ff1fd1&quot;), </span><br><span class="line">    &quot;_class&quot; : &quot;org.gamedo.db.EntityDbPlayer&quot;, </span><br><span class="line">    &quot;ComponentDbBag&quot; : &#123;</span><br><span class="line">        &quot;itemList&quot; : [</span><br><span class="line">            NumberInt(1)</span><br><span class="line">        ], </span><br><span class="line">        &quot;_class&quot; : &quot;org.gamedo.db.ComponentDbBag&quot;</span><br><span class="line">    &#125;, </span><br><span class="line">    &quot;ComponentDbPlayerInfo&quot; : &#123;</span><br><span class="line">        &quot;name&quot; : &quot;testName&quot;, </span><br><span class="line">        &quot;level&quot; : NumberInt(1), </span><br><span class="line">        &quot;_class&quot; : &quot;org.gamedo.db.ComponentDbPlayerInfo&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过对比可知，文档中仅仅ComponentDbBag.itemList里增加了一个NumberInt(1)，而控制台日志输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2021-03-16 15:21:05.265  INFO 36044 --- [           main] org.gamedo.Application                   : application run finish.</span><br><span class="line">2021-03-16 15:21:05.275  INFO 36044 --- [nPool-worker-19] org.gamedo.Application                   : updateFirstAsync finish, result:AcknowledgedUpdateResult&#123;matchedCount=1, modifiedCount=1, upsertedId=null&#125;</span><br></pre></td></tr></table></figure>

<p>通过日志可知：</p>
<ol>
<li>持久化发生在nPool-worker-19线程，而非main主线程</li>
<li>持久化日志在主线程日志之后打印，也即不会阻塞main主线程的业务逻辑</li>
</ol>
<h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><h3 id="ECS：组合优于继承"><a href="#ECS：组合优于继承" class="headerlink" title="ECS：组合优于继承"></a>ECS：组合优于继承</h3><p>在gamedo.persistence中，游戏持久化对象数据被定义为：EntityDbData。它对应于ECS中的E（Entity），并且和ECS中的Entity相同的是：EntityDbData仅仅只是一个数据容器（当然，如果非得在EntityDbData的子类内增加成员变量也是可以的），真正要存储的数据都放在ComponentDbData中，对应于ECS中的C（Component），同时，EntityDbData和ComponentDbData都实现了DbData接口，通过观察DbData接口的定义，可以知道：</p>
<ul>
<li>它包含一个String类型的Id，映射到MongoDB的Document的_id字段</li>
<li>它包含一个更新器，代表着这个DbData内的属性都可以通过$set操作符进标脏</li>
</ul>
<p>在gamedo.persistence的实现中，EntityDbData中含有一个Map&lt;String, ComponentDbData&gt;的成员变量，其中Key为ComponentDbData所代表的java.lang.Class的getSimpleName()返回值，Value为ComponentDbData的子类实现。DbData、EntityDbData、ComponentDbData的继承关系如图所示：</p>
<p><img src="https://raw.githubusercontent.com/pcloves/gamedo.persistence/main/images/gamedo.persistence.DbData-UML.png" alt="gamedo.persistence.DbData-UML.png"></p>
<h3 id="高性能：化整为零"><a href="#高性能：化整为零" class="headerlink" title="高性能：化整为零"></a>高性能：化整为零</h3><p>在游戏服务器框架的持久化业务场景中，一般情况都是游戏逻辑线程负责对游戏持久化对象数据进行修改，而在另外一个线程（以下简称为db线程）对该持久化数据进行读操作，并将之持久化到db中。这样读写分离的操作是为了带来更好的性能，假设对于持久化数据的修改和持久化操作都在业务线程中，这将会极大地影响业务线程。而读写操作不在同一个线程也带来了java编程中最常见的多线程问题：内存可见性和并发竞争。总而言之，就是要解决如何将游戏持久化对象数据安全地发布到db线程中，一种经典的做法是先将持久化对象数据序列化成中间状态，发布到db线程后再反序列化为原来状态后执行持久化操作。而这种操作带来了一个缺点，就是：带来了无谓的性能损耗。当持久化对象数据非常大时，这种性能损耗将会更加明显，即使仅修改一个简单的成员变量，也要执行全局序列化&#x2F;反序列化。</p>
<p>由于gamedo.persistence模块的底层数据库是MongoDB，而后者提供了 <strong>“$set”</strong>操作符，这允许用户可以对MongoDB中文档（甚至是内嵌的文档）的字段进行局部更新，gamedo.persistence正是利用了这个特性，设计了一个线程安全的更新器（Updater），并为每个Entity和Component配备了一个独立的Updater， 并通过一系列的封装和设计，使之具有简单易用的特性。此外Updater内部使用了spring-data-mongodb的Update，当安全地发布到db线程后，可以直接执行持久化操作，而不会带来额外的性能反序列化性能开销。这种化整为零的拆分思想保证了只有需要更新的字段才会进行持久化操作，而无需进行无谓的全局序列化&#x2F;反序列化。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.gamedo.org/2020/12/15/Maven%E9%A1%B9%E7%9B%AE%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="临江听雨">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="听雨">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 听雨">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/15/Maven%E9%A1%B9%E7%9B%AE%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/" class="post-title-link" itemprop="url">Maven项目开源操作指南</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-15 23:00:00" itemprop="dateCreated datePublished" datetime="2020-12-15T23:00:00+08:00">2020-12-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-03-15 15:19:42" itemprop="dateModified" datetime="2021-03-15T15:19:42+08:00">2021-03-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AE%9E%E8%B7%B5%E7%BB%8F%E9%AA%8C/" itemprop="url" rel="index"><span itemprop="name">实践经验</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ol start="0">
<li><p>一句话概括：把托管在github上的代码发布到sonatype nexus仓库，后者通过自动机制同步到maven中央仓库，可以参考官方的帮助文档：<a href="https://central.sonatype.org/pages/ossrh-guide.html">OSSRH Guide</a></p>
</li>
<li><p>创建<a href="https://issues.sonatype.org/secure/Signup!default.jspa">sonatype jira账号</a>，创建一个<a href="https://issues.sonatype.org/browse/OSSRH-65516">jira issue</a>，如果是groupId是自有域名需要证明，例如增加<strong>TXT</strong>记录</p>
</li>
<li><p>由于执行maven的deploy phase时，需要将代码推送到sonatype的仓库，因此需要配置用户名和密码，方法就是在.m2&#x2F;setting.xml里配置server字段，配置内容为：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">                          https://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">localRepository</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">interactiveMode</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">offline</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginGroups</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>ossrh<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">username</span>&gt;</span>sonatype jira&#x27;s user name<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">password</span>&gt;</span>sonatype jira&#x27;s password<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrors</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">proxies</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-release<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">gpg.passphrase</span>&gt;</span>gpg&#x27;s passphrase<span class="tag">&lt;/<span class="name">gpg.passphrase</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activeProfiles</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activeProfile</span>&gt;</span>nexus-release<span class="tag">&lt;/<span class="name">activeProfile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activeProfiles</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如上所示，需要配置servers.server节点，至于profiles.profile节点，后面会用到</p>
</li>
<li><p>当执行到maven的<code>verify</code> phase时，需要调用<code>maven-gpg-plugin</code>插件的<code>sign</code>这个goal，目的是对推送到仓库的所有文件进行签名，而这个goal又会默认调用gpg这个系统命令，因此需要提前安装gpg，如果是在windows，需要下载windows下的<a href="https://www.gpg4win.org/">gpg4win</a>，安装后生成gpg key：<code>gpg  --generate-key</code>，并将公钥分发到远程服务器：<code>gpg --keyserver hkp://pool.sks-keyservers.net --send-keys B87AC4F5C8D3C23B</code>，也可以使用gpg4win附带的可视化工具Kleopatra对gpg paire进行备份、生成吊销证书、分发到远程服务器。</p>
</li>
<li><p>创建开源项目，并托管到github，保证pom.xml内必备字段都完备，比如：GAV、licenses、developers、scm、issueManagement，如果是非pom打包，还要求有doc的jar包和源码的jar包，因此需要配置：<code>maven-source-plugin</code>和<code>maven-javadoc-plugin</code>插件，详情可以参考<a href="https://central.sonatype.org/pages/apache-maven.html#performing-a-snapshot-deployment">sonatype官方文档说明</a>，详情参考的<a href="https://raw.githubusercontent.com/pcloves/gamedo/main/pom.xml">gamedo</a>项目的配置，配置过程中需要注意：</p>
<ol>
<li>snapshotRepository.id需要保持和setting.xml中的server.id一致，maven通过pom.xml和setting.xml实现配置分离和继承，公共数据配置在pom.xml中，私密数据配置在setting.xml中</li>
<li>maven-gpg-plugin插件中的<code>configuration.gpgArguments</code>内的两个参数的目的是让gpg插件自动输入密码，该配置参考自<a href="https://myshittycode.com/2017/08/07/maven-gpg-plugin-prevent-signing-prompt-or-gpg-signing-failed-no-such-file-or-directory-error/">该链接</a></li>
</ol>
</li>
<li><p>进入发布循环流程（<a href="https://itnext.io/publishing-artifact-to-maven-central-b160634e5268">参考文档</a>）：</p>
<ol>
<li><p>开发，开发，开发</p>
</li>
<li><p>发布snapshots版本：<code>mvn clean deploy -P nexus-release</code>（需要保证版本号以 <strong>-SNAPSHOT</strong> 结尾）</p>
</li>
<li><p>版本稳定，准备发布release版本，设置新版本：<code>export newVersion=1.0.0 &amp;&amp; mvn versions:set -DnewVersion=$&#123;newVersion&#125;</code>（该操作是去掉 <strong>-SNAPSHOT</strong> 后缀）</p>
</li>
<li><p>发布新版本到nexus：<code>mvn clean deploy -P nexus-release</code>，由于<code>nexus-staging-maven-plugin</code>插件中的<code>autoReleaseAfterClose</code>设置为false，发布后会驻留在staging库，不会自动同步到release库</p>
</li>
<li><p>如果发现版本有问题，可以从staging库删除：<code>mvn nexus-staging:drop</code>，当确认无误后，可以发布到release库：<code>mvn nexus-staging:release</code>，nexus会在十分钟后自动同步到maven中央库，并且会在jira里自动评论：<a href="https://issues.sonatype.org/browse/OSSRH-65516">OSSRH-65516</a>。</p>
</li>
<li><p>提交新的tag到git中</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;Release <span class="variable">$&#123;newVersion&#125;</span>&quot;</span></span><br><span class="line">git tag <span class="variable">$&#123;newVersion&#125;</span></span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure>
</li>
<li><p>开启下一次版本迭代，修改新的版本号<code>export newVersion=1.1.0-SNAPSHOT &amp;&amp; mvn versions:set -DnewVersion=$&#123;newVersion&#125; &amp;&amp; git commit -m &quot;new feature version&quot;</code></p>
</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.gamedo.org/2020/12/13/spring-data-mongodb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="临江听雨">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="听雨">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 听雨">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/13/spring-data-mongodb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">spring-data-mongodb源码阅读笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-13 22:00:00" itemprop="dateCreated datePublished" datetime="2020-12-13T22:00:00+08:00">2020-12-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-12 14:45:04" itemprop="dateModified" datetime="2025-08-12T14:45:04+08:00">2025-08-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E6%B2%89%E6%B7%80/" itemprop="url" rel="index"><span itemprop="name">技术沉淀</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ol>
<li><p>spring-data-mongodb向mongodb-driver执行find指令时，后者解析后返回一个BsonDocument，BsonDocument继承自BsonValue，并且implements了Map&lt;String, Bsonvalue&gt;接口（内部通过LinkedHashMap实现），其成员如下，可以参考<a href="https://docs.mongodb.com/manual/reference/command/find/index.html#output">mongodb API</a>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">waitedMS		--&gt; BsonInt64</span><br><span class="line">cursor			--&gt; BsonDocument</span><br><span class="line">firstBatch	--&gt; BsonArrayWrapper	//第一批读取到的document列表（ArrayList&lt;Document&gt;），当decode后被wrapper到BsonArrayWrapper</span><br><span class="line"><span class="built_in">id</span>					--&gt; BsonInt64					//游标的Id，</span><br><span class="line">ns					--&gt; BsonString				//NameSpace的缩写，组成为：数据库名.文档名，例如：test.Bag</span><br><span class="line">ok					--&gt; bsonDouble				//标明命令是否执行成功：1：成功；0：失败</span><br></pre></td></tr></table></figure>
</li>
<li><p>spring-data-mongodb的基础事件：<code>org.springframework.data.mongodb.core.mapping.event.MongoMappingEvent</code>，可以继承<code>AbstractMongoEventListener</code>，当执行document在进行删除前、删除后、存储前、存储后、转换前、转换后、加载后时，可以执行自定义操作。</p>
</li>
<li><p>MongoDb生成唯一Id最佳实践（<a href="https://www.baeldung.com/spring-boot-mongodb-auto-generated-field">来源</a>）：</p>
<ul>
<li><p>定义生成唯一Id的java类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Document(collection = &quot;database_sequences&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatabaseSequence</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> seq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义生成唯一Id的函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">generateSequence</span><span class="params">(String seqName)</span> &#123;</span><br><span class="line">    <span class="type">DatabaseSequence</span> <span class="variable">counter</span> <span class="operator">=</span> mongoOperations.findAndModify(query(where(<span class="string">&quot;_id&quot;</span>).is(seqName)),</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Update</span>().inc(<span class="string">&quot;seq&quot;</span>,<span class="number">1</span>), options().returnNew(<span class="literal">true</span>).upsert(<span class="literal">true</span>),</span><br><span class="line">      DatabaseSequence.class);</span><br><span class="line">    <span class="keyword">return</span> !Objects.isNull(counter) ? counter.getSeq() : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以使用<code>AbstractMongoEventListener</code>实现自动化设置，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user.setId(sequenceGenerator.generateSequence(User.SEQUENCE_NAME));	<span class="comment">//User.SEQUENCE_NAME为static string类型</span></span><br><span class="line">user.setEmail(<span class="string">&quot;john.doe@example.com&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>spring-data-mongodb实例化entity的算法如下所示（<a href="https://docs.spring.io/spring-data/mongodb/docs/3.1.6/reference/html/#mapping.object-creation">原文地址</a>）：</p>
<ul>
<li>如果包含无参构造参数，则使用该构造函数，其他有参构造函数被忽视</li>
<li>如果只有一个含有参数的构造函数，将该构造函数将会被使用</li>
<li>如果有多个有参构造函数，那么含有<code>@PersistenceConstructor</code>注解的构造函数将会被使用。</li>
</ul>
</li>
<li><p>在加载数据并创建领域对象时，Spring Data会在运行时生成对象工厂（继承自接口：<strong>ObjectInstantiator</strong>），并且调用领域对象的构造函数，而并没有使用反射，这提升了10%性能，但是如果要是用该特性必须满足以下条件（<a href="https://docs.spring.io/spring-data/mongodb/docs/3.1.6/reference/html/#mapping.object-creation">原文地址</a>）：</p>
<ul>
<li>不能是私有类</li>
<li>不是是非静态的内部类</li>
<li>不能是CGLib代理类</li>
<li>被Spring Data选中的构造函数不能是私有的</li>
</ul>
</li>
<li><p>Spring Data给予的一般性建议（(原文地址)[<a href="https://docs.spring.io/spring-data/mongodb/docs/3.1.6/reference/html/#mapping.general-recommendations]%EF%BC%89%EF%BC%9A">https://docs.spring.io/spring-data/mongodb/docs/3.1.6/reference/html/#mapping.general-recommendations]）：</a></p>
<ul>
<li>尽量使用不可变实体对象（<em>immutable objects</em>）</li>
<li>如果无法将实体设计为不可变对象，那么提供一个全参构造函数，如此一来Spring Data可以将对象属性一次性赋值成功，从而跳过属性设置，最终获得最佳性能。</li>
<li>全参构造函数可以提供最佳的性能，所以要尽量避免由于出现多个重载构造函数而使用*<code>@PersistenceConstructor</code>* 注解，而要防止多个重载的构造函数，那就尽量使用静态的工厂方法</li>
<li>确保Spring Data的对象工厂（<em>instantiator</em> ）和属性访问器（<em>property accessor classes</em>）可以正常被使用，也即第5条的4个条件都要被满足</li>
<li>对于标识符字段（也即将会被序列化为_id字段的属性），声明为final，并且优先使用全参构造函数，其次使用with…方法</li>
<li>使用<em>Lombok</em> 来避免样板代码，并且使用*<code>@AllArgsConstructor</code>*来生成全参构造函数</li>
</ul>
</li>
<li><p>Spring Data在映射层处理_id字段的规则</p>
<ul>
<li>如果类的成员变量被增加了<code>@Id</code> （<code>org.springframework.data.annotation.Id</code>）注解，那么将会被映射为MongoDB的_id字段</li>
<li>如果类的成员变量没有<code>@Id</code>注解，但是被命名为id，那么也会被解析映射为_id字段</li>
<li>作为标识符字段的默认类成员变量名_id，并且可以被<code>@Field</code>字段注解</li>
<li></li>
</ul>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.gamedo.org/2020/12/06/AQS%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="临江听雨">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="听雨">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 听雨">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/06/AQS%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">AQS源码阅读笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-06 22:00:00" itemprop="dateCreated datePublished" datetime="2020-12-06T22:00:00+08:00">2020-12-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-12 14:47:53" itemprop="dateModified" datetime="2025-08-12T14:47:53+08:00">2025-08-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E6%B2%89%E6%B7%80/" itemprop="url" rel="index"><span itemprop="name">技术沉淀</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ol>
<li><p>Doug Lea在他的<a href="http://gee.cs.oswego.edu/dl/papers/aqs.pdf">论文</a>中写道：</p>
<ul>
<li>JUC同步器框架的主要性能目标是实现可伸缩性，也即：当发生锁竞争时，可预测地保持效率。在理想的情况下，无论多少线程尝试通过同步点，所需的开销都是常量。（更确切的讲）其中一个主要目标是：某一线程被允许通过同步点但还没有通过的情况下，使其耗费的总时间最少。</li>
<li>实现同步器的上述目标包含了两种不同的使用类型。大部分应用程序是最大化其总的吞吐量，容错性，并且最好保证尽量减少饥饿的情况（非公平锁）。然而，对于那些控制资源分配的程序来说，更重要是去维持多线程读取的公平性，可以接受较差的总吞吐量（公平锁）。没有任何框架可以代表用户去决定应该选择哪一个方式，因此，应该提供不同的公平策略。</li>
</ul>
</li>
<li><p>AQS队列的head node很特殊，它属于一个<strong>占位node</strong>，其成员变量pre、next、thread都为null，也就是说队列中第2个node才是真正排队的队首。</p>
</li>
<li><p>对于AbstractQueuedSyncchronizer的入队函数：enq，当第一次调用（也即初始化队列）时，内部的for循环至少循环2次，第一次设置head、第二次设置tail。</p>
</li>
<li><p>AQS的公平锁实现FairSync中，获取锁的流程为（假定请求锁的线程名为t2）：</p>
<ul>
<li>首先尝试获取锁（FairSync::tryAcquire）：<ul>
<li>如果发现state &#x3D;&#x3D; 0（没有人拿到锁），并且有资格拿锁（也即hasQueuedPredecessors返回false，从字面意思讲，这个函数代表是否有线程在当前线程前面排队中，返回true的条件需要同时满足两个：1、队列已经初始化，2、队列中只有一个占位node（前面有一个node在enq一半时会出现这种情况）<strong>或者</strong>首个排队node的线程不是本线程），则尝试CAS设置state为0，如果设置成功，则获取锁成功并返回。</li>
<li>如果发现state !&#x3D; 0，并且当前线程获取了锁，则增加锁的数量，并且获取锁成功并返回。</li>
</ul>
</li>
<li>如果没有获取到锁：先CAS入队（AbstractQueuedSynchronizer::addWaiter，重点1），其流程为：<ul>
<li>检查队列是否已经初始化（tail !&#x3D; null），如果已经初始化则CAS设置当前node为队尾</li>
<li>如果队列已经初始化或者上一步CAS设置队尾失败，则自旋进行入队操作（AbstractQueuedSynchronizer::enq）。</li>
</ul>
</li>
<li>入队后，开始自旋（AbstractQueuedSynchronizer::acquireQueued），其流程为：<ul>
<li>先再一次检测能否获取锁（设计思路是：t2入队后，可能前面的线程正好释放了锁，此时t2虽然在队中，但是可能就是队首（也即是队列的第2个node），那就不需要排队）</li>
<li>如果还是拿不到；检测是否需要park，检测条件为：pre.waitState &#x3D;&#x3D; 0（并且前前一个node的waitState是由当前节点修改为0的，为什么呢？因为前一个node已经睡眠中，无法修改自己，有意思！），如果需要（第一次自旋时必然不成立，乐观锁的天性：尽量不park），则调用LockSupport.park阻塞当前线程。</li>
<li>如果拿到锁直接返回</li>
</ul>
</li>
</ul>
</li>
<li><p>一个线程尝试获取ReentrantLock公平锁时，最多会尝试3次获取锁，发生的场景是锁已经被其他线程占有，但是该请求线程是队列的队首，该请求首先会尝试获取，获取失败后，在入队park前会自旋2次尝试获取。最少会1次尝试锁，发生的场景是锁已经被其他线程占有，且该请求线程入队后也不是队首。</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.gamedo.org/2020/09/11/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="临江听雨">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="听雨">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 听雨">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/09/11/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">《Java并发编程实战》阅读笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-09-11 12:00:00" itemprop="dateCreated datePublished" datetime="2020-09-11T12:00:00+08:00">2020-09-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-04-01 19:47:45" itemprop="dateModified" datetime="2021-04-01T19:47:45+08:00">2021-04-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E6%B2%89%E6%B7%80/" itemprop="url" rel="index"><span itemprop="name">技术沉淀</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ol>
<li><p>（2.2.1 竞态条件）静态条件的两种场景类型：“先检查后执行（Check-Then-Act）”和“读取-修改-写入”，例如对于线程安全的Vector，当执行如下代码时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!vector.contains(element))</span><br><span class="line">	vector.add(element);</span><br></pre></td></tr></table></figure>

<p>就存在“先检查后执行”的竞态条件。</p>
</li>
<li><p>（2.4 用锁来保护状态）一种常见的加锁约定是，将所有的可变状态都封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码路径进行同步，使得在该对象上不会发生并发访问。换一个方式解读就是：如果存在的可变状态多于一个，并且要保证这些可变状态的修改是原子的，那么约定做法就是封装在一个类中，并且对该类进行操作时，都要先获取该类对象的内置锁。</p>
</li>
<li><p>（2.5　活跃性与性能）如果只有一个变量需要原子操作，那么使用<strong>Atomic</strong><em>是很有用的，但是如果多个变量需要原子性操作，那么就比较适合使用同步代码块，并且取消<strong>Atomic</strong></em>的使用。</p>
</li>
<li><p>（3.1.3　加锁与可见性）这一节有一个重要的结论：</p>
<blockquote>
<p><strong>加锁的含义不仅仅局限于互斥行为，还包括内存可见性</strong>。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。</p>
</blockquote>
<p>换句话说，加锁有两层用途：互斥排他和内存可见性。而后者是大家很容易忽视的。那内存可见性的一个应用场景就是：某一个线程写，其他线程读，这种情况下不存在并发竞争，而值存在内存可见性的问题。而这种情况下，大部分都是使用<strong>volatile</strong>，这也是为什么加锁的内存可见性的用途被忽视的另外一个原因。</p>
</li>
<li><p>（3.2　发布与逸出）构造函数中this逸出的三种场景：</p>
<ul>
<li>在构造函数中new了内部匿名类，那么匿名类中就包含this指针</li>
<li>在构造函数中启用了新的线程，并且构造后直接启动</li>
<li>在构造函数中调用一个可改写的实例方法时（既不是私有方法，也不是终结方法）</li>
</ul>
</li>
<li><p>（3.3.1　Ad-hoc线程封闭）只要你能确保只有单个线程对共享的volatile变量执行写入操作，那么就可以安全地在这些共享的volatile变量上执行“读取-修改-写入”的操作。在这种情况下，相当于将修改操作封闭在单个线程中以防止发生竞态条件，并且volatile变量的可见性保证还确保了其他线程能看到最新的值。</p>
</li>
<li><p>（3.5.1　不正确的发布：正确的对象被破坏）本节中的<code>AssertionError</code>异常的例子的简单解释：1、JMM规范中并没有要求对象字段的初始化要happens before与另一个线程对该对象的可见性；2、<code>if(n != n)</code>并非一个原子性操作，而需要3步操作，因此会出现第一次读取的n值和第二次读取的n值不相同的情况。而如果将对象的字段改成volatile后就能避免<code>AssertionError</code>，这是因为JMM有规范要求：volatile sore要可见于其他线程。关于本节例子的两个很好的补充解释：<a href="https://www.zhihu.com/question/264579989">知乎</a>、<a href="https://stackoverflow.com/questions/16107683/improper-publication-of-java-object-reference">StackOverflow</a></p>
<blockquote>
<p>由<code>if(n != n)</code>这行代码可以联想到一种并发编程易出错场景:某个函数里引用一个会被并发修改的字段，那么可能会出现在函数逻辑过程中发生变化的情况。这就引入了<code>4.1.2　依赖状态的操作</code>的内容，已经并发编程的一个基本思想：但在并发程序中，先验条件可能会由于其他线程执行的操作而变成真。在并发程序中要一直等到先验条件为真，然后再执行该操作（死循环加CAS？）。</p>
</blockquote>
</li>
<li><p>（4.3.3　当委托失效时）虽然AtomicInteger是线程安全的，但经过组合得到的类却不是。也就是说，如果一个类中的字段即使都是线程安全的，但是这个类也不一定是线程安全的。当这些字段之间存在某些不变性条件时，就会导致“先检查后执行”操作的出现。而这是前面所讲的竞态条件的一种常见场景。</p>
</li>
<li><p>（4.3.5　示例：发布状态的车辆追踪器）注意本节的批注[1]，很重要但是很容易忽视的一个并发编程错误场景！</p>
</li>
<li><p>（5.1.3　隐藏迭代器）Synchronized*容器的<code>toString</code>、<code>hashCode</code>、<code>equals</code>函数会调用迭代器，因此在调用这些方法时，记得加锁，例如记录日志时或者将这些容器作为另一个容器的key或value时。这都是很容易忽视的！否则在迭代的过程中如果其他线程执行了并发增删操作，很有可能抛出<code>ConcurrentModificationException</code>。另外Synchronized*容器没有<code>putIfAbsent</code>之类的函数，如果要实现类似的<strong>检查并执行</strong>的操作，需要自己加锁！或者使用专用的并发容器，例如：ConcurrentMap</p>
</li>
<li><p>（5.4 阻塞方法与中断方法）当捕获到<code>InterruptedException</code>时，不要私自吞掉该异常，要么继续向上传递该异常或者干脆不不捕获该异常，要么重新恢复中断：<code>Thread.currentThread().interrupt();</code></p>
</li>
<li><p>（5.5 同步工具类）闭锁（CountDownLatch）：属于消耗性的只减不增的递减计数器，计时器为零时解锁；FutureTask：属于特殊的二元闭锁，运行中时阻塞，运行结束时解锁；信号量（Semaphore）：属于池化的计数器，可赠可减，当池中计数器为0时阻塞，可以用任何容器加Semphore组合为有界容器。栅栏（CyclicBarrier）：可以复用的递增计数器，初始化时，计数器为0，计数器未满时阻塞，计时器满时解锁，并且重置计数器。Exchanger：特殊的两方栅栏，任何一方都先发起交换请求，等待另一方响应后，交换达成，适用于读写线程进行无GC的缓冲交换（示例：<a href="https://www.baeldung.com/java-exchanger">baeldung</a>）。</p>
</li>
<li><p>（7.1.1 中断）对中断的正确理解是：它并不会真正地中断一个正在运行的线程，而是发出中断请求，然后由线程（自己决定）在下一个合适的时刻中断自己。<strong>通常，中断是实现取消的最合理方式。</strong>这句话的意思是，程序不需要自己顶一个类似volatile的cancelled的状态，并轮询检测该状态，已决定是否取消。如果采用中断的方式，那么可以调用：inerrupt()，如果线程处于阻塞中，会收到<code>InterruptedException</code>，如果处于非阻塞中，其interrupted状态会被标记。因此完整的程序框架类似于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    	<span class="keyword">while</span>(!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">      	<span class="comment">//执行业务逻辑</span></span><br><span class="line">    	&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">    	<span class="comment">//线程退出</span></span><br><span class="line">  	&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cancel</span><span class="params">()</span> &#123;interrupt();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>（7.1.2 中断策略）这一节有时间再继续消化！</p>
</li>
<li><p>（7.1.5 通过Future来实现取消）<code>Future.get(long, TimeUnit)</code>会返回4种异常，需要对这4种异常进行进行处理，特别是<code>InterruptedException</code>，不要私自吞掉！当一个Future已经完成后，再次调用cancel也不会有什么影响。</p>
</li>
<li><p>（7.1.7 通过newTaskFor来封装非标准的取消）这一节主要讲了一件事：如果想在执行<code>Future.cancel</code>时执行额外的操作，那么：1、集成Callable接口，实现自己的Callable；2、继承<code>ThreadPoolExecutor</code>，重写newTaskFor函数，如果发现不是自己实现的Callable，那么调用super，否则返回一个自己实现的FutureTask，这个FutureTask的cancel函数先执行自己的一些操作，然后再调用super。</p>
</li>
<li><p>（7.2 停止基于线程的服务）一个重要的概念：只有线程的所有者有权关闭线程，而线程池是其工作线程的所有者。</p>
</li>
<li><p>（8.1.1 线程饥饿死锁）在单线程的Executor中，如果任务一将任务二提交到同一个Executor，那么会导致饥饿死锁！而在多线程的Executor中，如果这种现象比较多，也可能发生死锁。因此有一条规则：不要在同一个Executor中递归提交任务。当Executor A依赖Executor B时，A的有效线程数量（有可能）实际上隐式地依赖于B的线程数量。例如某逻辑线程池使用了包含10个连接的JDBC线程池。</p>
</li>
<li><p>（8.2 设置线程池的大小）对于计算密集型任务，线程池的大小为<strong>CPU数量 + 1</strong>时，能实现最优利用率。而对于IO密集型线程池大小的评估公式为：<strong>CPU数量 * CPU利用率（大于等于0且小于等于1）* ( 1 + IO等待时间 &#x2F; 计算时间)</strong></p>
</li>
<li><p>（12.3.5 无用代码的消除）在性能测试过程中，有一些技巧可以避免编译器对某些无用的代码进行消除，大致思路就是保证计算结果被使用，但是不要引入IO操作，而导致了性能偏差。下面的例子是一个很好的技巧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(foo.x.hashCode() == System.nanoTime())</span><br><span class="line">  System.out.print(<span class="string">&quot; &quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这段代码绝大数情况下不会成功，即使成功，也只是输出一个空字符。</p>
</li>
<li><p>（14.2.2 过早唤醒）Object的内置对象锁存在一个条件队列，而唤醒这个条件队列的<strong>条件谓词</strong>可能不止一个，也就是说导致唤醒一个Object线程的条件不止是一个，因此当Object在wait后被唤醒时，仍然需要继续检测当时导致wait的同一个条件谓词，这也从另外一个角度说明了为什么要循环检测条件谓词（另外一个条件是：<a href="#spuriousWakeUp">唤醒现象的发生</a>）</p>
</li>
<li><p>（14.2.4 通知）<strong>每当在等待一个条件时，一定要确保在条件谓词变为真时通过某种方式发出通知。</strong>换句话说：wait和notify（notifyAll）一般都是在同一个函数内成对出现？另外由于同一个条件队列可以对应于多个条件谓词，因此尽量使用notifyAll而非notify（如果非得使用notify，需要满足两个条件：1、唯一条件谓词：条件谓词只有一个；2、单进单出：最多只能唤醒一个线程来执行，换句话说就是唤醒后，只有一个线程可以继续工作，剩下的线程会竞争失败而继续wait），否则会面临信号丢失的风险。</p>
</li>
<li><p>（14.2.5 示例：阀门类）这一节的例子中，generation字段可以理解为批次，用一个形象的比喻就是这个Gate前可以等待一批又一批的线程，在await函数里，当线程被notifyAll后，当且仅当门是关闭状态并且当前的批次还是自己等待时的批次，才会再次wait（如果门已经开启，或者已经换了批次，那就证明gate肯定是开过，那我必须过去！）。</p>
</li>
<li><p>（14.3 显示的Condition对象）与内置锁和条件队列一样，当使用显示的Lock和Condition时，也必须满足锁、条件谓词和条件变量之间的三元关系。在条件谓词中包含的变量必须有Lock来保护，并且在检查条件谓词以及调用await和signal时，必须持有Lock对象。</p>
</li>
<li><p>（15.3 原子变量类）原子标量类（AtomicInteg、AtomicLong、AtomicBoolean、AtomicReference）没有重新定义hashCode和equals方法，因此每一个实例都是不同的，因此也不适用于做散列容器的键值。</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.gamedo.org/2020/09/11/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="临江听雨">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="听雨">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 听雨">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/09/11/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">《深入理解Java虚拟机》（第三版）阅读笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-09-11 12:00:00" itemprop="dateCreated datePublished" datetime="2020-09-11T12:00:00+08:00">2020-09-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-04-01 19:47:42" itemprop="dateModified" datetime="2021-04-01T19:47:42+08:00">2021-04-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E6%B2%89%E6%B7%80/" itemprop="url" rel="index"><span itemprop="name">技术沉淀</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ol>
<li><p>（2.2 运行时数据区域）jvm内存划分为5个区域，简单说就是2个堆（堆和非堆（方法区的别称））、2个栈（虚拟机栈和本地方法栈）、1个程序计数器</p>
</li>
<li><p>（2.2.5 方法区）方法区和永久代的区别在于（JDK 8以前），前者是java虚拟机规范的定义，而永久代是HotSpot虚拟机下特有的实现，且属于方法区的一部分，这么设计的目的就是为了垃圾收集器能够像管理Java堆一样管理这部分内存，省去专门为方法区编写内存管理代码的 工作。</p>
</li>
<li><p>（2.3.1 对象的创建）本节讲到：<strong>由字节码流中new指令后面是否跟随invokespecial指令所决定，Java编译器会在遇到new关键字的地方同时生成 这两条字节码指令</strong>，验证测试代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Test2</span> <span class="variable">test2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test2</span>();</span><br><span class="line">        System.out.println(test2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行：<code>javac Test2.java</code>，然后执行：<code>javap -v Test2.class</code>查看字节码文件，输出内容为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">Classfile /mnt/f/Develop/Project/demo/src/main/java/com/example/demo/test/Test2.class</span><br><span class="line">  Last modified Dec 14, 2020; size 436 bytes</span><br><span class="line">  MD5 checksum b6b5fa11a474d65891c6991ba0d7143a</span><br><span class="line">  Compiled from <span class="string">&quot;Test2.java&quot;</span></span><br><span class="line">public class com.example.demo.test.Test2</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   <span class="comment">#1 = Methodref          #6.#15         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   <span class="comment">#2 = Class              #16            // com/example/demo/test/Test2</span></span><br><span class="line">   <span class="comment">#3 = Methodref          #2.#15         // com/example/demo/test/Test2.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   <span class="comment">#4 = Fieldref           #17.#18        // java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">   <span class="comment">#5 = Methodref          #19.#20        // java/io/PrintStream.println:(Ljava/lang/Object;)V</span></span><br><span class="line">   <span class="comment">#6 = Class              #21            // java/lang/Object</span></span><br><span class="line">   <span class="comment">#7 = Utf8               &lt;init&gt;</span></span><br><span class="line">   <span class="comment">#8 = Utf8               ()V</span></span><br><span class="line">   <span class="comment">#9 = Utf8               Code</span></span><br><span class="line">  <span class="comment">#10 = Utf8               LineNumberTable</span></span><br><span class="line">  <span class="comment">#11 = Utf8               main</span></span><br><span class="line">  <span class="comment">#12 = Utf8               ([Ljava/lang/String;)V</span></span><br><span class="line">  <span class="comment">#13 = Utf8               SourceFile</span></span><br><span class="line">  <span class="comment">#14 = Utf8               Test2.java</span></span><br><span class="line">  <span class="comment">#15 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  <span class="comment">#16 = Utf8               com/example/demo/test/Test2</span></span><br><span class="line">  <span class="comment">#17 = Class              #22            // java/lang/System</span></span><br><span class="line">  <span class="comment">#18 = NameAndType        #23:#24        // out:Ljava/io/PrintStream;</span></span><br><span class="line">  <span class="comment">#19 = Class              #25            // java/io/PrintStream</span></span><br><span class="line">  <span class="comment">#20 = NameAndType        #26:#27        // println:(Ljava/lang/Object;)V</span></span><br><span class="line">  <span class="comment">#21 = Utf8               java/lang/Object</span></span><br><span class="line">  <span class="comment">#22 = Utf8               java/lang/System</span></span><br><span class="line">  <span class="comment">#23 = Utf8               out</span></span><br><span class="line">  <span class="comment">#24 = Utf8               Ljava/io/PrintStream;</span></span><br><span class="line">  <span class="comment">#25 = Utf8               java/io/PrintStream</span></span><br><span class="line">  <span class="comment">#26 = Utf8               println</span></span><br><span class="line">  <span class="comment">#27 = Utf8               (Ljava/lang/Object;)V</span></span><br><span class="line">&#123;</span><br><span class="line">  public com.example.demo.test.Test2();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial <span class="comment">#1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         4: <span class="built_in">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=2, args_size=1</span><br><span class="line">         0: new           <span class="comment">#2                  // class com/example/demo/test/Test2</span></span><br><span class="line">         3: dup</span><br><span class="line">         4: invokespecial <span class="comment">#3                  // Method &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         7: astore_1</span><br><span class="line">         8: getstatic     <span class="comment">#4                  // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">        11: aload_1</span><br><span class="line">        12: invokevirtual <span class="comment">#5                  // Method java/io/PrintStream.println:(Ljava/lang/Object;)V</span></span><br><span class="line">        15: <span class="built_in">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 6: 0</span><br><span class="line">        line 7: 8</span><br><span class="line">        line 8: 15</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;Test2.java&quot;</span></span><br></pre></td></tr></table></figure>

<p>上述输出中，第54行为源码第6行的<code>final Test2 test2 = new Test2();</code>，第56行就是文中说的invokespecial。</p>
</li>
<li><p>（2.3.2 对象的内存布局）源码地址：<a href="http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/87ee5ee27509/src/share/vm/oops/markOop.hpp">jdk8</a></p>
<table>
<thead>
<tr>
<th align="right">Mark Word(64 bits)</th>
<th align="center">锁状态</th>
</tr>
</thead>
<tbody><tr>
<td align="right">unused:25                                                     | hash:31                                                               | unused:1 | age:4 | biased_lock:0 | lock:01</td>
<td align="center">正常</td>
</tr>
<tr>
<td align="right">thread:54                                                                                                                    | epoch:2 | unused:1 | age:4 | biased_lock:1 | lock:01</td>
<td align="center">偏向锁</td>
</tr>
<tr>
<td align="right">ptr_to_lock_record:62                                                                                         | lock:00</td>
<td align="center">轻量级锁</td>
</tr>
<tr>
<td align="right">ptr_to_heavyweight_monitor:62                                                                               | lock:10</td>
<td align="center">重量级索</td>
</tr>
<tr>
<td align="right">| lock:11</td>
<td align="center">GC标记</td>
</tr>
</tbody></table>
<p>当开启指针压缩（UseCompressdOops）时，正常状态和偏向锁状态下的两个unused字段会变成：cms_free，具体参考：<a href="https://stackoverflow.com/questions/60985782/details-about-mark-word-of-java-object-header">stackoverflow</a></p>
</li>
<li><p>（2.3.3 对象的访问定位）句柄访问和直接指针访问的本质区别在于：前者是间接引用（相当于中间又增加了一层，从而带来了更好的灵活性），后者是直接引用。</p>
</li>
<li><p>（2.4.2 虚拟机栈和本地方法栈溢出）经测试64位Linux下Xss最小值为：228k，默认值为：1024K（64位Windows 10下，两个值分别为：108K和0）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">java -Xss128K com.example.demo.test.Test2                                                                             </span><br><span class="line">The stack size specified is too small, Specify at least 228k</span><br><span class="line">Error: Could not create the Java Virtual Machine.</span><br><span class="line">Error: A fatal exception has occurred. Program will <span class="built_in">exit</span>.</span><br><span class="line"></span><br><span class="line">java -XX:+PrintFlagsFinal -version | grep ThreadStackSize                                                             </span><br><span class="line">     intx CompilerThreadStackSize                   = 0                                   &#123;pd product&#125;</span><br><span class="line">     intx ThreadStackSize                           = 1024                                &#123;pd product&#125;</span><br><span class="line">     intx VMThreadStackSize                         = 1024                                &#123;pd product&#125;</span><br><span class="line">openjdk version <span class="string">&quot;1.8.0_275&quot;</span></span><br><span class="line">OpenJDK Runtime Environment (build 1.8.0_275-8u275-b01-0ubuntu1~18.04-b01)</span><br><span class="line">OpenJDK 64-Bit Server VM (build 25.275-b01, mixed mode)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>TIPS：</p>
<ul>
<li>如果运行程序出现了OutOfMemoryError异常，发生的区域很小的几率发生在虚拟机栈（主要发生区域是堆），理由是：HotSpot虚拟机不支持栈的动态扩展，所以线程运行期间不会申请内存扩展，从而不会导致OOM，那么只会出现在创建线程申请内存时出现OOM，有3种措施会可以促进这种OOM：1、虚拟机栈空间尽量小；2、每个线程的栈内存尽量大（Xss）；3、创建的线程足够多。更详细地说，如果是在32位Windows系统下，由于单个进程最大内存限制是2G，那么排除掉Xmx的堆最大容量、直接内存、jvm本身消耗内存以及程序计数器（可以忽略不计）内存，剩下的内存才是虚拟机栈和本地方法栈的可用内存，如果虚拟机栈内存足够小，而且Xss配置得又偏大，那么，如果创建非常多线程的情况下，是有可能出现创建线程时导致虚拟机栈OOM的。</li>
<li>如果允许程序出现了StackOverflowError异常，比较大的可能性是递归调用导致了栈溢出，比较小的可能性是因为调用堆栈过深导致栈溢出，因为对于后者来说，默认Xss的大小为1024k，是很难导致溢出的。</li>
</ul>
</blockquote>
</li>
<li><p>（2.4.3 方法区和运行时常量池溢出）自JDK 7起，原本存放在永久代的字符串常量池被移至Java堆之中</p>
</li>
<li><p>（2.4.4 本机直接内存溢出）OOM后，dump文件比较小，而且又使用的Direct Memory，那么就要考虑是否是直接内存OOM</p>
</li>
<li><p>（3.2.3 再谈引用）强引用：打死也不能回收；软引用（SoftReference）：OOM前回收；弱引用（WeakReference）：下次GC时回收；虚引用（PhantomReference）：根本不算引用，因为无法获得引用对象，应用场景：为了能在这个对象被收集器回收时收到一个系统通知。</p>
</li>
<li><p>（3.3.1 分代收集理论）</p>
<ul>
<li>垃圾分代收集的本质在于对象的年龄。朝生夕灭的小鲜肉放在一起管理（称之为年轻代），相亲无数（也就是躲过了多次垃圾回收）的大龄青年（称之为老年代）放在一起管理，这可真够现实的。</li>
<li>除了CMS收集器，其他都不存在只针对老年代的收集</li>
</ul>
</li>
<li><p>（3.3.2 标记-清除算法（Mark-Sweep））原理：标记处房间内的垃圾，然后直接清理掉，缺点：房间还是很乱（内存碎片），因为只清理了垃圾，而没有整理房间</p>
</li>
<li><p>（3.3.3 标记-复制算法（Mark-Copy））多用于年轻代垃圾收集器，原理：</p>
<ul>
<li>基础版：房间分成两部分，每次只用其中一部分，每次回收时，清理垃圾，并将物品搬到另一个房间，缺点：浪费空间。</li>
<li>进阶版：房间分成三部分，一大两小（8:1:1），每次只用一大和一小，每次回收时，清理垃圾，并将物品搬到另一个房间</li>
</ul>
</li>
<li><p>（3.3.4 标记-整理算法（Mark-Compact））多用于老年代垃圾收集器，原理：在标记-清除算法的基础上，额外增加整理（更形象的说，是“压缩整理”，从标记-整理算法的英文名：Mark-Compact就能看出来）的功能。</p>
<blockquote>
<p>TIPS:</p>
<ul>
<li>对于CMS收集器，平时多数时间都采用（并发）标记-清除算法，这也应对CMS的全称：Concurrent Mark Sweep，当空间碎片过多时采用标记-整理算法。这也对应CMS算法的缺点：1、容易产生内存碎片；2、一旦由于碎片过多触发了标记整理算法，就会导致长时间的STW</li>
</ul>
</blockquote>
</li>
<li><p>（3.4.2 安全点）安全点停顿：几乎所有虚拟机不再采用抢先式中断（Preemptive Suspension）而是采用主动式中断（Voluntary Suspension），也即虚拟机负责设置标记位，各个线程负责轮询检查标记位，然后运行到安全点上（有点类似于游戏服务器的某个全局模块设置标记位，在线玩家心跳逻辑里轮询检测这个标记位）。</p>
</li>
<li><p>（3.4.4 记忆集与卡表）通俗地讲，从垃圾收集区域来看，Remembered Set指的是谁指向了我的集合（如果有人指向了我，那么这个“我”就不能当做垃圾被回收）！这是一个抽象的逻辑概念模型。从具体实现的角度来看，最原始的Remembered Set就是存储对方所有跨带引用对象的集合，但是这是非常低效的，因此可以把这个“我”的区域（也即垃圾收集区域）划分成若干子区域（每个区域称之为卡页：Card Page），然后用一个数组标记该区域是否含有跨代引用指针（这个数组就是卡表：Card Table），在GC时将Card Table中存在跨代引用的Card Page进行扫描，从而减少GC Roots的扫描的范围（这种分组的思想是不是很熟悉，想一下武汉市在医疗资源紧缺时采取的新冠核酸筛的混检模式，就是讲每10人混合成一个样本，筛查效率理论上可以提升到原来的10倍）。</p>
</li>
<li><p>（3.4.5 写屏障）这一节讲了两件事：</p>
<ul>
<li><p>卡表的状态维护机制：写屏障，通俗讲就是虚拟机层面的AOP</p>
</li>
<li><p>当多线程写同一块内存时，如果这块内存被同一个缓存行的卡表对应，那么意味着这个位于同一个缓存行的卡表会被多个线程修改，导致性能降低，优化机制为：不要无条件修改卡表，而是加一个判断（额，这个优化真的非常非常初级啊）</p>
</li>
</ul>
</li>
<li><p>（3.4.6 并发的可达性分析）</p>
<ul>
<li>三色标记：白色：还未过安检；黑色：已经过安检，安全；灰色：安检中</li>
<li>两种条件同时满足时，会出现白色误判为垃圾：1、扫描期间某黑色新指向了白色对象；2、同时某灰色到该白色的直接或间接引用也恰巧删除。这就导致了该白色对象仅被黑色对象引用，而黑色对象是安全的，不会再次扫描，这就导致错过扫描而被误判为垃圾。举一个形象的例子：三个包过机场的安检仪：黑包–灰包–白包这3个包用绳子相继连着，此时黑包已过安检，灰包安检中，白包等待安检，突然风雨突变，灰包和白包的绳子莫名断掉，同时有一股神秘力量将黑包和小白连起来（来自用户线程），但是这个连线却没穿过安检仪，那这种情况下白包就会错过安检（这个例子真是绝，我真是大聪明！）</li>
<li>消除白色误判的两种策略：1、破除上述条件一，也即增量更新（Incremental Update）：如果黑色在扫描期间指向了白色，那就让它变灰；2、破除上述条件二，也即原始快照（Snapshot At The Beginning， SATB）：先拍个照，当进行扫描时，不管灰色是否删除了白色的指向，都按照这个快照扫描。CMS是基于增量更新，G1、Shenandoah则是用原始快照。</li>
</ul>
</li>
<li><p>（3.5.6 CMS收集器）</p>
<ul>
<li><p>收集过程分成4个阶段：</p>
<ol>
<li>初始标记（CMS initial mark）：标记GC Roots能直接关联到的对象，会引发短暂的STW</li>
<li>并发标记（CMS concurrent mark）：也即三色标记阶段，会导致某些白色被误判垃圾，也会导致漏过某些白色而产生浮动垃圾</li>
<li>重新标记（CMS remark）：采用增量更新策略，重新标记，会引发STW</li>
<li>并发清除（CMS concurrent sweep）：这也是CMS名称的由来，并发清除（concurrent sweep）</li>
</ol>
</li>
<li><p>缺点：</p>
<ol>
<li>并发标记对CPU敏感（默认GC线程数&#x3D;处理器核心数量 +3）&#x2F; 4）：CPU核心数大于等于4个时，并发标记线程数不超过25%，当并发线程数小于4个时，有一半运算能力执行GC，因此CPU敏感。</li>
</ol>
</li>
</ul>
<ol start="2">
<li>由于GC过程中浮动垃圾无法收集（要留到下一次），因此需要为老年代预留出一部分空闲空间（-XX：CMSInitiatingOccupancyFraction，JDK 6以后该默认值从JDK 5的68%提升至92%），防止并发失败（Concurrent Mode Failure）导致临时启用Serial Old。</li>
<li>CMS正如它的名字所示，属于标记清除算法，因此在GC结束后会导致大量内存碎片。当申请大对象内存时，可能会出现内存碎片过多无法分配，导致提前触发Full GC（有两个参数：-XX：+UseCMSCompactAtFullCollection和-XX：CMSFullGCsBeforeCompaction可以相对改善，具体细节可以使用时查看相关资料）。</li>
</ol>
<blockquote>
<p>TIPS:</p>
<ul>
<li>所有收集器中只有CMS有针对老年代的Old GC</li>
</ul>
</blockquote>
</li>
<li><p>（3.5.7 Garbage First收集器）</p>
<ul>
<li><p>JDK 7 Update 4时，G1的”Experimental“的标识被移除，到JDK 8 Update 40，提供类卸载的支持，变成了Oracle官方称为“全功能的垃圾收集 器”（Fully-Featured Garbage Collector）</p>
</li>
<li><p>G1的Remembered Set结构：由于存在多个Region，而每个Region都要维护的Remembered Set都需要存储谁引用了我，因此Remembered本质上是哈希表，key为其他Region的起始地址，value为一个集合，存储的是该Region中卡表的索引号。这存在两个问题：1、Remembered Set是一个双向索引，这维护起来就麻烦了；2、Remembered Set比较多，因此要消耗额外的堆内存，大约在10%~20%之间。</p>
</li>
<li><p>Region中有一部分内存用于GC并发回收中的对象分配，这个区域都位于TAMS（Top at Mark Start）指针之上。G1默认TAMS地址以上的对象都是存活的，不进行GC。</p>
</li>
<li><p>G 1停顿预测模型一句话总结：每个Region进行回收统计，包括：回收耗时、Remember Set中脏卡数量等，G1根据每个Region的统计状态的新旧评价回收价值，并预测哪些Region集合可以在-XX:MaxGCPauseMillis内回收时获得最高收益。</p>
</li>
<li><p>收集过程同样（相对于CMS）分成4个阶段：</p>
<ol>
<li>初始标记（Initial Marking）：标记GC Roots能直接关联到的对象，还要额外（相对于CMS）修改TAMS指针的值，会引发短暂的<strong>STW</strong></li>
<li>并发标记（Concurrent Marking）：也即三色标记阶段，还要额外重新处理SATB记录上并发标记期间引用改动的对象。</li>
<li>最终标记（Final Marking）：短暂的<strong>STW</strong>，处理上一步中遗留的少量的SATB记录。</li>
<li>筛选回收（Live Data Counting and Evacuation）：1、更新Region的统计数据，并根据统计价值和成本进行排序；2、筛选Region回收集合；3、把回收Region集合中的存活对象移动到空的Region中，然后清空所有回收集合Region全部空间，由于需要移动存活对象，因此会引发<strong>STW</strong>，但是会多线程并行完成。</li>
</ol>
</li>
<li><p>从G1开始，垃圾收集器的设计导向发生变化：追求全堆清理转向追赶内存分配速率（Allocation Rate）。我个人把这个新原则称之为遇熊逃命原则，也即不追求跑得最快，只要求不是最慢即可，换到GC角度上，那就是只要应付得了内存分配的速率即可。只要我打扫垃圾的速度比你制造垃圾的速度足够快，足以。这个理念非常牛B啊，所以才说G1是收集器的一个里程碑。</p>
</li>
</ul>
<blockquote>
<p>TIPS:</p>
<ul>
<li><p>按理来说，G1是全堆回收的，那为什么仍然存在年轻代和老年代？个人推测是因为仍然沿用了HotSopt垃圾分代框架，而书中也多次用了“扮演新生代”或“扮演老年代”的说法，这也可以证明这个推测。</p>
</li>
<li><p>书中没讲到的G1的思想：G1实际上采取的是分治算法的思想，将大问题分解成小问题，逐个击破。从整体上讲，它属于标记-整理算法（根据前文内容，整理算法是让所有存活对象移动到内存一端，如果按照这个标准，那G1整体上并非严格意义上的标记-整理算法），而从局部上讲，又属于标记复制算法（Region A移动到Region B）。</p>
</li>
</ul>
</blockquote>
</li>
<li><p>（3.6 低延迟垃圾收集器）</p>
<ul>
<li>Shenandoah和G1的3个不同之处：<ul>
<li>支持并发整理算法，G1在第4个阶段进行筛选回收时，是多线程并行处理，但是不会并发。</li>
<li>默认不使用分代收集，不存在新生代和老年代的Region</li>
<li>将G1的Remembered Set改为连接矩阵（Connection Matrix）：降低维护成本，也降低伪共享的发生概率。</li>
</ul>
</li>
<li>Shenandoah收集过程：<ul>
<li>初始标记（Initial Marking），标记GC Roots能直接关联到的对象，会引发短暂的与堆大小无关的<strong>STW</strong></li>
<li>并发标记（Concurrent Marking）：与G1一样，并发且并行</li>
<li>最终标记（Final Marking）：与G1一样，处理剩余的SATB扫描，引发短暂的<strong>STW</strong></li>
<li>并发清理（Concurrent Cleanup）：清理连一个存活对象都没有找到的Region</li>
<li>并发回收（Concurrent Evacuation）：这是Shenandoah的核心改进，通过读屏障和Brooks Pointers转发指针实现并发回收。</li>
<li>初始引用更新（Initial Update Reference）：确保上一个并发回收阶段的线程都已经完成对象移动任务，会引发<strong>STW</strong>。</li>
<li>最终引用更新（Final Update Reference）：修正存在于GC Roots 中的引用，最后一次引发<strong>STW</strong>，停顿时间只与GC Roots数量有关。</li>
<li>并发清理（Concurrent Cleanup）：清理Immediate Garbage Regions。</li>
</ul>
</li>
</ul>
<blockquote>
<p>TIPS:</p>
<ul>
<li>本节开头提了：内存占用（Footprint）、吞吐量（Throughput）、延迟（Latency）组成了三元悖论，意指三者只能得其二，类似的三元悖论还有很多，例如分布式系统中著名的CAP定理：一致性（<strong>C</strong>onsistency）、可用性（<strong>A</strong>vailability）、分区容忍性（<strong>P</strong>artition Tolerance）。详情可以参考：周大的另外一本<a href="https://icyfenix.cn/architect-perspective/general-architecture/transaction/distributed.html#cap%E4%B8%8Eacid">开源书籍</a>或<a href="https://www.ibm.com/cloud/learn/cap-theorem">IBM Cloud Learn Hub</a></li>
<li>Shenandoah将Remembered Set改为连接矩阵，从数据管理的视角上来看，实际上是把数据分散处理调整为全局集中处理，这也符合数据驱动开发的思想。例如在游戏开发领域，双向游戏好友是比较常见的社交功能，相比于把好友数据存储到每个玩家身上，维护一系列全局的好友关系数据将是更好的选择。因为如果使用前一个方案，那么在分布式环境下，单就数据一致性的这个问题，就会要求架构底层需要很好的支持，功能逻辑的复杂性也会大大增加。</li>
<li>Brooks Pointer通过CAS操作保证并发时对象访问的正确性，CAS真是并发编程一大神器啊！</li>
</ul>
</blockquote>
</li>
<li><p>（3.6.2 ZGC收集器）：</p>
<ul>
<li>Region分成3种：Small Region（2MB，存储&lt;256KB对象）、Medium Region（32MB，存储&gt;&#x3D;256KB&amp;&amp;&lt;4MB 对象）、Large Region（2MB的整数倍，最小为4MB，存储&gt;&#x3D;4MB对象）</li>
<li>Shenandoah收集过程：<ul>
<li>并发标记（Concurrent Mark）：操作与G1、Shenandoah类似，也会引发<strong>STW</strong>，区别在于标记是在指针上而不是在对象上进行的，标记阶段会更新染色指针中的Marked 0、Marked 1标志 位。</li>
<li>并发预备重分配（Concurrent Prepare for Relocate）：1、根据特定的查询条件统计得出 本次收集过程要清理哪些Region，将这些Region组成重分配集（Relocation Set）；2、类卸载和弱引用处理（从JDK 12开始支持）。</li>
<li>并发重分配（Concurrent Relocate）：复制Relocation Set中的存活对象到新Region，每个Region维护转发表（Forward Table），记录转发关系。并发期间，如果对象访问，由于染色指针的存在，ZGC知道该对象是否处于Reloaction Set，因此会被内存屏障截获，转发到新Region上，并同时更新引用（指针自愈）。</li>
<li>并发重映射（Concurrent Remap）：重映射所做的就是修正整个堆中指向重分配集中旧对象的所 有引用。实际上即使没有这一步，这些对象也可以在之后的访问时，通过指针自愈实现重映射。ZGC将此工作合并到下一次垃圾收集循环的并发标记阶段中，从而更加节省了一次对象图的遍历。</li>
</ul>
</li>
</ul>
<blockquote>
<p>TIPS:</p>
<ul>
<li>在上述第3个“并发重分配”过程，当复制Relocation Set中的存活对象到新Region时，周大没有详述实现细节，推测应该有类似的CAS操作来更新对象指针的染色指针，这是一个小遗憾。</li>
<li>根据上述第4个“并发重映射”过程的描述，其过程被合并到下一次GC中，那ZGC岂不是只有3个大的过程？这是一个不太大的疑惑点。</li>
</ul>
</blockquote>
</li>
<li><p>（3.8.5 空间分配担保）在JDK 6 Update 24以前，当老年代最大连续可用空间小于新生代所有对象总和时，两种情况下会触发Full GC：</p>
<ul>
<li>-XX:+HandlePromotionFailure允许担保失败，但是老年代最大可用的连续空间是否小于历次晋升到老年代对象容量的平均大小</li>
<li>-XX:-HandlePromotionFailure不允许担保失败</li>
</ul>
<blockquote>
<p>TIPS：</p>
<p>在JDK 6 Update 24之后，HandlePromotionFailure参数已经被去掉，测试代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">☺  java -XX:+PrintFlagsFinal -XX:+HandlePromotionFailure  -version</span><br><span class="line">Unrecognized VM option <span class="string">&#x27;HandlePromotionFailure&#x27;</span></span><br><span class="line">Did you mean <span class="string">&#x27;(+/-)PromotionFailureALot&#x27;</span>?</span><br><span class="line">Error: Could not create the Java Virtual Machine.</span><br><span class="line">Error: A fatal exception has occurred. Program will <span class="built_in">exit</span>.</span><br></pre></td></tr></table></figure>

<p>上述规则调整为：只要老年代的连续空间大于等于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行Full GC，换言之只有这两个条件同时满足，蔡楚发Full GC。</p>
</blockquote>
</li>
<li><p>（4.2.2 jstat：虚拟机统计信息监视工具）：远程虚拟机进程的VMID为：[protocol:][&#x2F;&#x2F;]lvmid[@hostname[:port]&#x2F;servername]</p>
</li>
<li><p>（7.3.5 初始化）关于代码清单7-6中，字段B的值将会是2而不是1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">A</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    A = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">B</span> <span class="operator">=</span> A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	System.out.println(Sub.B);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>书中的解释并不是很彻底，可以使用javac编译，然后借助<code>javap -v</code> 命令得到更清新的答案，其Parent的javap命令解析如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">javap -v StaticMethod\<span class="variable">$Parent</span>                                                                                                                                                   master ✗</span><br><span class="line">Warning: Binary file StaticMethod<span class="variable">$Parent</span> contains com.example.demo.test.StaticMethod<span class="variable">$Parent</span></span><br><span class="line">Classfile /mnt/f/Develop/Project/demo/src/main/java/com/example/demo/test/StaticMethod<span class="variable">$Parent</span>.class</span><br><span class="line">  Last modified Dec 24, 2020; size 399 bytes</span><br><span class="line">  MD5 checksum 0f4fdfb9857a60ee769dbb6b4a2f3a0d</span><br><span class="line">  Compiled from <span class="string">&quot;StaticMethod.java&quot;</span></span><br><span class="line">class com.example.demo.test.StaticMethod<span class="variable">$Parent</span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   <span class="comment">#1 = Methodref          #4.#14         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   <span class="comment">#2 = Fieldref           #3.#15         // com/example/demo/test/StaticMethod$Parent.A:I</span></span><br><span class="line">   <span class="comment">#3 = Class              #17            // com/example/demo/test/StaticMethod$Parent</span></span><br><span class="line">   省略……</span><br><span class="line">&#123;</span><br><span class="line">  省略……</span><br><span class="line"></span><br><span class="line">  static &#123;&#125;;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=0, args_size=0</span><br><span class="line">         0: iconst_1</span><br><span class="line">         1: putstatic     <span class="comment">#2                  // Field A:I</span></span><br><span class="line">         4: iconst_2</span><br><span class="line">         5: putstatic     <span class="comment">#2                  // Field A:I</span></span><br><span class="line">         8: <span class="built_in">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 6: 0</span><br><span class="line">        line 8: 4</span><br><span class="line">        line 9: 8</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;StaticMethod.java&quot;</span></span><br><span class="line">InnerClasses:</span><br><span class="line">     static <span class="comment">#18= #3 of #16; //Parent=class com/example/demo/test/StaticMethod$Parent of class com/example/demo/test/StaticMethod</span></span><br></pre></td></tr></table></figure>

<p>通过上述代码可以发现，Line 54-55应对与源码中的类变量的定义：<code>public static int A = 1;</code>，而Line 56-57应对与有静态语句块中的赋值：<code>A = 2;</code>，也就是说：<strong>编译后的static静态语句块除了包含程序员的逻辑代码，还额外插入了编译器自动生成的对静态变量初始化的代码</strong>，且这些插入代码的位置符合如下原则：<strong>如果静态变量定义在static静态语句块上面，那么在程序员逻辑代码上面按照声明顺序插入，否则在程序员的逻辑代码下面按照声明顺序插入</strong>。当Parent类完成<strong>初始化</strong>后，成员变量A的值为2，当Sub类进行初始化时，要调用自己的<code>&lt;clinit&gt;()</code>，按照文中所述：<strong>Java虚拟机会保证在子类的()方法执行前，父类的()方法已经执行 完毕。</strong>Sub进行初始化时A的值已经是2，因此赋值给B后就是2了。</p>
</li>
<li><p>（7.4.2 双亲委派模型）</p>
<blockquote>
<p>“双亲委派”这个术语实在是翻译得败笔，根据<a href="https://www.zhihu.com/question/24923480">知乎</a>上一个比较形象的回答，翻译为“啃老模式”更为形象。也就是说遇到类加载请求时，先让父加载器去加载，父加载器加载不了了自己才去加载。</p>
</blockquote>
</li>
<li><p>（8.3.1 解析）静态方法、私有方法、实例构造器、父类以及final方法（由于历史设计的原因，final方法是使用invokevirtual指令来调用）在类加载的时候就可以把符号引 用解析为该方法的直接引用。这些方法统称为“非虚方法”（Non-Virtual Method）</p>
</li>
<li><p>（8.3.2 分派）</p>
<blockquote>
<ul>
<li>静态分派对应的是方法的重载（Overload），动态分配对应的是类的重写（Override）。</li>
<li>当子类声明了与父类同名的字段时，虽然在子类的内存中两 个字段都会存在，但是子类的字段会遮蔽父类的同名字段</li>
</ul>
</blockquote>
</li>
<li><p>（8.4.3 java.lang.invoke包）一句话解释Reflection和MethodHandle的区别：Reflection是重量级，而MethodHandle 是轻量级。</p>
</li>
<li><p>主内存与工作内存之间具体的交互协议：<br><a href="https://imgtu.com/i/6QaSat"><img src="https://s3.ax1x.com/2021/03/08/6QaSat.png" alt="6QaSat.png"></a></p>
</li>
<li><p>对于普通变量（相对于volatile变量）：要求read&#x2F;load、write&#x2F;store<strong>成对</strong>、<strong>顺序</strong>出现，但是允许不连续出现（也即中间可以插入其他指令）。</p>
</li>
<li><p>对于volatile变量：</p>
<ul>
<li>只有当前一个指令是load时，才允许执行use；且只有后一个动作是use时，才能执行load动作。换句话说：额外要求load和use是<strong>连续成对</strong>出现的，结合上面第2条，那就是use&#x2F;load&#x2F;read一条龙。这条规则要求在工作内存中，每次使用volatile变量前都必须先从主内存刷新最新的值，保证能看见其他线程对该变量的修改。</li>
<li>只有当前一个指令是assign时，才允许执行store；且只有后一个动作是store时才能执行assign动作。换句话说：额外要求assign和store是<strong>连续成对</strong>出现，结合上面第2条，那就是assign&#x2F;store&#x2F;write一条龙。这条规则要求在工作内存中，每次修改volatile变量后都必须立刻同步回主内存中，用于保证其他线程可以看到自己对该变量所做的修改。</li>
<li>对于任意两条龙A和B，如果A的龙头（assign或use）发生在B的龙头之前，那么A的龙尾要在B的龙尾之前（我这个解释真是太牛了！）</li>
</ul>
</li>
<li><p>关于互斥量（mutex）和信号量（semaphore）的区别：</p>
<ul>
<li>正如他们的名字一样，前者的使用场景是保护资源的独占性，注重的是竞争关系；而后者的场景是等待“信号”的发生，更倾向于生产者&#x2F;消费者模型中的消费者，注重的是供需关系。[知乎回答](semaphore和mutex的区别？ - 人马座的回答 - 知乎 <a href="https://www.zhihu.com/question/47704079/answer/528324049">https://www.zhihu.com/question/47704079/answer/528324049</a>)</li>
<li>对于mutex，只有上锁的线程才有资格解锁；而对于semaphore，它可以被任意的线程获取和释放。</li>
</ul>
</li>
<li><p>简述java的synchronized关键字：</p>
<ul>
<li>它是java中最基本的互斥同步的手段，属于一种块结构的同步语法。</li>
<li>被javac编译后，会在同步块的前后分别形成moniterenter和moniterexit两个字节码指令</li>
<li>这两个字节码都需要一个reference类型参数指明要锁定的和解锁的对象。如果没有指明，那么就根据synchronized修饰的方法类型决定是锁对象实例还是Class对象。</li>
<li>在执行monitorenter指令时，首先要去尝试获取对象的锁，并且锁计数器加一，执行 monitorexit指令时会将锁计数器的值减一。计数器清零时，锁被释放。并且可以推论出：对于同一个线程来说，synchronized是可重入的。</li>
</ul>
</li>
<li><p>简述java的并发机制（或者同步机制）</p>
<ul>
<li>同步的定义：同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条（或者是一些， 当使用信号量的时候）线程使用。</li>
<li>基于同步的定义或者目的，有两种实现思路：1、互斥同步，其基本思想是对于共享资源的获取是悲观的（也即悲观锁），因此在访问资源时，都进行加锁操作，例如java语言层面提供的synchronized关键字。2、非阻塞同步，其基本思想是对于共享资源的获取时保持乐观的。不管风险，先进行操作，如果没有其他线程争用共享数据，那操作就直接成功了；如果共享的数 据的确被争用，产生了冲突，那再进行其他的补偿措施。</li>
</ul>
</li>
<li><p>关于JDK 6引入的自适应自旋锁的机制</p>
<ul>
<li>自旋时间不再固定，而是由同一把锁前一次的自旋时间以及锁拥有者的状态决定。</li>
<li>假如刚刚自旋等待获取过<strong>同一把锁</strong>，并且持有锁的线程正在运行中，虚拟机会认为很可能再次成功，就会增加自旋次数</li>
<li>假如很少成功获得过锁，那么可能直接省略掉自旋，避免浪费CPU资源。</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.gamedo.org/2020/05/11/SED%E5%91%BD%E4%BB%A4%E5%AE%9E%E8%B7%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="临江听雨">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="听雨">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 听雨">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/05/11/SED%E5%91%BD%E4%BB%A4%E5%AE%9E%E8%B7%B5/" class="post-title-link" itemprop="url">SED命令实践</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-05-11 22:00:00" itemprop="dateCreated datePublished" datetime="2020-05-11T22:00:00+08:00">2020-05-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-03-13 19:39:30" itemprop="dateModified" datetime="2021-03-13T19:39:30+08:00">2021-03-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AE%9E%E8%B7%B5%E7%BB%8F%E9%AA%8C/" itemprop="url" rel="index"><span itemprop="name">实践经验</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ol>
<li><p>sed命令执行时包含了若干个循环（cycle），而每个循环又包含若干个命令（command），完整的执行流程图为（<a href="https://linux.cn/article-10232-1.html">图片来源</a>）：</p>
<p><img src="https://img.linux.net.cn/data/attachment/album/201811/14/190635j1ycygaxrcj1vege.png" alt="The Sed execution model"></p>
</li>
<li><p><strong>tips:</strong> 如果sed语法的第一个字符是“&#x2F;”，那么表示这是一个正则表达式的地址定位方式。（细品）</p>
</li>
<li><p>sed使用场景示例：</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;line 1\nline 2\nline 3&#x27;</span> | sed <span class="string">&#x27;s/line/&quot;&amp;&quot;/g&#x27;</span> <span class="comment">#将所有的line加上双引号</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;line\t1\nline\t2\nline\t3&#x27;</span> | sed -n <span class="string">&#x27;l&#x27;</span> <span class="comment">#显示文本中的控制字符</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;line 1\nline 2\nline 3&#x27;</span> | sed -n <span class="string">&#x27;/1/=&#x27;</span> <span class="comment">#显示包含1的行的行号，输出：1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;line 1\nline 1\nline 2\nline 3&#x27;</span> | sed -n <span class="string">&#x27;$=&#x27;</span> <span class="comment">#显示总行数，输出：3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#删除某几行文字（可以延伸到保留某几行，或删除或保留匹配的行）</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;line 1\nline 2\nline 3&#x27;</span> | sed  <span class="string">&#x27;1d&#x27;</span> <span class="comment">#删除第1行</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;line 1\nline 2\nline 3&#x27;</span> | sed -n <span class="string">&#x27;1!p&#x27;</span> <span class="comment">#功能同上</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#sed默认会将pattern space中的数据输出到屏幕，如果使用FLAG p，还会每次额外把current pattern space输出到屏幕，举例</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;line 1\nline 2\nline 3&#x27;</span> | sed  <span class="string">&#x27;/.*/p&#x27;</span> <span class="comment">#匹配所有的字符，并且会把pattern space和current pattern space中的内容都输出到屏幕上，因此每一行文字都会重复输出两次</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;line 1\nline 2\nline 3&#x27;</span> | sed -n <span class="string">&#x27;/1/p&#x27;</span> <span class="comment">#匹配包含“1”的行，但是-n选项会禁止pattern space输出到屏幕，而FLAG p又会把current pattern space中的内容都输出到屏幕上，因此屏幕上显示的是：line 1，也即实现了grep的功能。记住：option -n和command p是一家。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在日常工作中，经常需要使用sed进行替换（例如部署服务器时，进行模板变量的替换），而需求是屏幕上只输出被修改的行，可以使用FLAG w将修改内容输出的stdout，如下所示：</span></span><br><span class="line">☺  <span class="built_in">cat</span> 1.txt</span><br><span class="line">123</span><br><span class="line">456</span><br><span class="line">789</span><br><span class="line">zhengtongshan@DESKTOP-R7DT0R0 /mnt/e/Tetris/src/1_Branches/rtm_tetris_zhugan</span><br><span class="line">☺  sed -i <span class="string">&#x27;s/1/s/gw /dev/stdout&#x27;</span> 1.txt</span><br><span class="line">s23</span><br><span class="line">zhengtongshan@DESKTOP-R7DT0R0 /mnt/e/Tetris/src/1_Branches/rtm_tetris_zhugan</span><br><span class="line">☺  <span class="built_in">cat</span> 1.txt</span><br><span class="line">s23</span><br><span class="line">456</span><br><span class="line">789</span><br><span class="line"></span><br><span class="line"><span class="comment">#在日常工作中，会遇到将制定的两行合并为一行的情况，情景为：如果发现某行包含某个字符，则将下面一行和本行合并，如下面的例子，如果行的第一个字符为a，则将后面的一行合并过来</span></span><br><span class="line">☺  <span class="built_in">echo</span> <span class="string">&#x27;a\nb\nc\na\nb&#x27;</span>  |sed -e <span class="string">&#x27;/^a/N&#x27;</span> -e <span class="string">&#x27;s/\n//&#x27;</span></span><br><span class="line">ab</span><br><span class="line">c</span><br><span class="line">ab</span><br><span class="line"></span><br><span class="line"><span class="comment">#下面两个语句是等效的：（细品）</span></span><br><span class="line">man <span class="built_in">cp</span> | sed <span class="string">&#x27;s/copy/&#123;&amp;&#125;/w cp.txt&#x27;</span>  <span class="comment">#将man page中的〝copy〞字串加上大括号〝&#123;&#125;〞，并将current pattern space写入“cp.txt”</span></span><br><span class="line">man <span class="built_in">cp</span> | sed -n <span class="string">&#x27;s/copy/&#123;&amp;&#125;/p&#x27;</span> &gt; cp.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">#多个FLAG可以叠加使用，但是和其他Linux指令一样，与文件有关的FLAG要放在最后</span></span><br><span class="line">man <span class="built_in">cp</span> | sed <span class="string">&#x27;s/copy/&#123;&amp;&#125;/Igpw cp.txt&#x27;</span> <span class="comment">#不区分大小写（FLAG I）将每行	（FLAG g）的“copy”加上大括号（Command s），将pattern space输出到屏幕（FLAG p），并将current pattern space写入文件“cp.txt”(FLAG w)</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;line 1\n\nline 2\nline 3&#x27;</span> | sed  <span class="string">&#x27;/^$/d&#x27;</span> <span class="comment">#删除空白行</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;line 1\nline 2\nline 3\nline 4&#x27;</span> | sed -e <span class="string">&#x27;N&#x27;</span> -e <span class="string">&#x27;N&#x27;</span> -e <span class="string">&#x27;s/\n/+/g&#x27;</span> <span class="comment">#用两次N连续读取两个下一行（此时pattern space里有三行），然后把换行符都换成+，执行完毕后，输出为：</span></span><br><span class="line">line 1+line 2+line 3</span><br><span class="line">line 4 </span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>使用t label可以实现事务性的修改，比如两个替换要么同时进行，要么就都不做。</p>
</li>
<li><p>command n命令的流程是：1、如果没有配置地址或匹配则输出pattern space（如果不满足则跳过下一步）；2、然后读取下一行到pattern space。详情参考：<a href="https://linux.cn/article-10232-1.html">Sed 命令完全指南</a>中的<strong>次行命令</strong>一节，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;line 1\nline 2\nline 3\nline 4\nline 5\nline 6&#x27;</span> | sed -e <span class="string">&#x27;n&#x27;</span> -e <span class="string">&#x27;n&#x27;</span> -ne <span class="string">&#x27;p&#x27;</span> <span class="comment">#当第1个n执行后，pattern space变成：line 2，当第2个n执行后，pattern space变成：line 3，然后执行p后，打印current pattern space：line 3，然后进入下一个循环，打印出：line 6，上述sed可以简写成：sed -ne &#x27;n;n;p&#x27;，此外我们发现p命令的n选项是一个全局选项，它对整个sed语句生效而不仅限于p命令自己</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>command N、D可以实现联合多行条件判断（例如：满足某一行有ID字符串，且下面两行分别包含NAME和ADDRESS字符串，则执行删除ID行的操作），实现更复杂的操作，如果不使用command N、D，那么sed的操作仅限于行内。</p>
</li>
<li><p>command D为删除current pattern space的第一个字符到换行，而command P类似，只是将删除变为打印。</p>
</li>
<li><p>command c和s的区别在于，前者是整行替换，后者还需要指定要替换的pattern。</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.gamedo.org/2020/05/11/Windows%E4%B8%8A%E6%90%AD%E5%BB%BASOCKS%E4%BB%A3%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="临江听雨">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="听雨">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 听雨">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/05/11/Windows%E4%B8%8A%E6%90%AD%E5%BB%BASOCKS%E4%BB%A3%E7%90%86/" class="post-title-link" itemprop="url">Windows上搭建SOCKS代理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-05-11 22:00:00" itemprop="dateCreated datePublished" datetime="2020-05-11T22:00:00+08:00">2020-05-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-03-15 15:21:25" itemprop="dateModified" datetime="2021-03-15T15:21:25+08:00">2021-03-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AE%9E%E8%B7%B5%E7%BB%8F%E9%AA%8C/" itemprop="url" rel="index"><span itemprop="name">实践经验</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="问题提出："><a href="#问题提出：" class="headerlink" title="问题提出："></a>问题提出：</h4><p>驻厂深圳后，办公地点的网络不再是专线，因此IP不再是固定的，而是由运营商动态分配，而线上某些业务都开启了IP白名单，如果仍然通过添加白名单的方式，那么将会非常麻烦。总结一下受限的业务场景，包括：</p>
<ol>
<li>ssh连接腾讯云服务器</li>
<li>http访问蓝鲸运维平台</li>
<li>Jenkins Slave（Windows 7）服务器拷贝服务器版本到腾讯云</li>
</ol>
<h3 id="方案思路："><a href="#方案思路：" class="headerlink" title="方案思路："></a>方案思路：</h3><p>考虑到ssh提供了socks代理，因此可以在北京公司部署一台固定IP且已经加入IP白名单的服务器（假设为HostA，IP为：10.12.28.114，OS为Windows 10），然后开启socks代理，受限业务的流量都通过socks代理。</p>
<h3 id="方案实施："><a href="#方案实施：" class="headerlink" title="方案实施："></a>方案实施：</h3><ol>
<li>安装OpenSSH（windows 10 version 1803及以后的版本已经集成），在HostA上：设置–&gt;应用–&gt;应用和功能–&gt;可选功能–&gt;添加功能–&gt;OpenSSH服务器</li>
<li>开启sshd服务：在HostA上，控制面板–&gt;系统和安全-&gt;管理工具–&gt;服务–&gt;OpenSSH SSH Server</li>
<li>开启socks代理：ssh -f -N -D 0.0.0.0:1080 <a href="mailto:&#119;&#x69;&#x6e;&#49;&#48;&#64;&#49;&#x32;&#55;&#x2e;&#48;&#46;&#48;&#46;&#49;">&#119;&#x69;&#x6e;&#49;&#48;&#64;&#49;&#x32;&#55;&#x2e;&#48;&#46;&#48;&#46;&#49;</a>，此命令会在1080端口上开启sockets代理（关于如何使用ssh-key登录，可以参考这篇文章：<a href="http://woshub.com/using-ssh-key-based-authentication-on-windows/">Configuring SSH Key-Based Authentication on Windows 10&#x2F; Server 2019</a>，并着重关注： <strong>How to Login Windows Using SSH Key Under Local Admin?</strong> ）</li>
</ol>
<h3 id="问题解决："><a href="#问题解决：" class="headerlink" title="问题解决："></a>问题解决：</h3><ol>
<li>受限场景1：SSH连接工具上设置socks代理，如图所示：<br> <a href="https://imgtu.com/i/6QUzVI"><img src="https://s3.ax1x.com/2021/03/08/6QUzVI.png" alt="6QUzVI.png"></a></li>
<li>受限场景2：到<strong>控制面板–&gt;Internet选项–&gt;连接–&gt;局域网设置–&gt;代理服务器–&gt;高级</strong> 里设置socks代理，然后使用IE访问蓝鲸运维平台<br> <a href="https://imgtu.com/i/6QUvqA"><img src="https://s3.ax1x.com/2021/03/08/6QUvqA.png" alt="6QUvqA.png"></a></li>
<li>受限场景3：由于jenkins slave机器是windows 7系统，本身没有集成OpenSSH Client组件，因此考虑在slave上安装ssh客户端，最终考虑使用git附带的Unix tools中的ssh功能（安装时需要把Unix tools加入环境变量），在<code>%USERPROFILE%/.ssh/config</code>内增加ProxyCommand命令行进行代理，命令如下：<code>ProxyCommand connect -S 10.12.28.114:1080 %h %p</code> 如果要是用http代理，需要把 <strong>-S</strong> 改为 <strong>-H</strong> ，回到jenkins配置界面，配置scp命令拷贝版本即可。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.gamedo.org/2020/03/15/csharp%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="临江听雨">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="听雨">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 听雨">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/03/15/csharp%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/" class="post-title-link" itemprop="url">C#高级特性拾遗</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-03-15 22:00:00" itemprop="dateCreated datePublished" datetime="2020-03-15T22:00:00+08:00">2020-03-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-14 10:45:10" itemprop="dateModified" datetime="2025-08-14T10:45:10+08:00">2025-08-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E6%B2%89%E6%B7%80/" itemprop="url" rel="index"><span itemprop="name">技术沉淀</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><ul>
<li><p><code>Conditional(&quot;some condition&quot;)</code> 可以优雅地替代宏定义</p>
</li>
<li><p>泛型类中的static字段和非泛型类的字段有所区别，后者中该static字段属于该类，而前者中该static字段仅属于该泛型类，例如<code>Generic&lt;A&gt;.staticField</code>和<code>Generic&lt;B&gt;.staticField</code>是不同的。对于这个特性，可以有比较进阶的用法，例如：</p>
  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Foo</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> lastId;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Foo</span>&lt;<span class="title">T</span>&gt; : <span class="title">Foo</span> &#123; </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> id = ++lastId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么对于每一个<code>Foo&lt;T&gt;</code>的子类，启id都是唯一的，从而实现id自我管理（而这里的泛型T只是被借壳而已，没有任何用处）。</p>
</li>
<li><p>使用<code>Type.MakeGenericType</code>，可以在运行时生成泛型类，这是一个java不具备的特性，举例：</p>
 <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> type = <span class="keyword">typeof</span>(Dictionary&lt;,&gt;);</span><br><span class="line">Type[] typeArgs = &#123;<span class="keyword">typeof</span>(<span class="built_in">string</span>), <span class="keyword">typeof</span>(<span class="built_in">int</span>)&#125;;</span><br><span class="line"><span class="keyword">var</span> genericType = type.MakeGenericType(typeArgs)</span><br></pre></td></tr></table></figure>
</li>
<li><p>default关键字：在泛型类和泛型方法中产生的一个问题，给定参数化类型 T 的一个变量 t，只有当 T 为引用类型时，语句 t &#x3D; null 才有效；只有当 T 为数值类型而不是结构时，语句 t &#x3D; 0 才能正常使用。 解决方案是使用default 关键字，此关键字对于引用类型会返回null，对于数值类型会返回零。</p>
</li>
<li><p>对于<code>ManualResetEvent</code>：</p>
<ol>
<li>可以通过构造函数初始化为有信号或无信号状态。</li>
<li>当且仅当<code>ManualResetEvent</code>处于无信号状态时（也即Set没有被调用或者初始化为无信号状态），其他线程调用了<code>ManualResetEvent.WaitOne</code>才会被阻塞。</li>
<li>调用<code>ManualResetEvent.Reset</code>可以阻塞所有其他调用了<code>ManualResetEvent.WaitOne</code>的线程</li>
<li>应用场景：工作A和B需要并发执行，但是需要A执行完毕后再执行B。最佳实践：a、A线程（称之为<code>ManualResetEvent</code>控制线程）调用<code>ManualResetEvent.Reset</code>使之进入非信号状态；b、B线程（称之为被控制线程或等待线程？阻塞线程？）在适当位置调用<code>ManualResetEvent.WaitOne</code>等待信号；c、A线程调用ManualResetEvent.Set通知B线程继续执行。</li>
</ol>
</li>
<li><p>可以通过实现一个public的无参的返回<code>IEnumerator</code>的<code>GetEnumerator()</code><br>为一个类扩展foreach语法，例如（<a href="https://youtu.be/94ZElZQhu88?t=1782">详情</a>）：</p>
  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IEnumerator&lt;Tile&gt; <span class="title">GetEnumerator</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> x = <span class="number">0</span>; x &lt; <span class="keyword">this</span>.size.x; x++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> y = <span class="number">0</span>; y &lt; <span class="keyword">this</span>.size.y; y++) &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">this</span>[x, y];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="GetAwaiter"><a href="#GetAwaiter" class="headerlink" title="GetAwaiter()"></a>GetAwaiter()</h1><ul>
<li>在C#中，任意类只要实现了：<code>GetAwaiter()</code> 函数，就可以被<code>await</code>关键字异步等待<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> Delay</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> TimeSpan TimeSpan &#123;<span class="keyword">get</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Delay</span>(<span class="params">TimeSpan timeSpan</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        TimeSpan = timeSpan;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Delay <span class="title">Second</span>(<span class="params"><span class="built_in">int</span> seconds</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Delay(TimeSpan.FromSeconds(seconds));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TaskAwaiter <span class="title">GetAwaiter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Task.Delay(TimeSpan).GetAwaiter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
由于 <code>Delay</code> 实现了 <code>GetAwaiter</code> 方法，现在就可以使用： <code>await Delay.Seconds(2);</code> 而在实际应用中，可以使用C#的扩展功能对<code>Delay</code> 进行扩展，而不必侵入修改，例如：<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Extensions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TaskAwaiter <span class="title">GetAwaiter</span>(<span class="params"><span class="keyword">this</span> Delay delay</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Task.Delay(delay.TimeSpan).GetAwaiter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这意味着：可以使用扩展的方式可以实现对任意类的 <code>await</code> 异步等待，基于该理念，<code>Delay</code> 这个结构体已经没有存在的必要，因为可以对TimeSpan进行扩展，例如：<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Extensions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TaskAwaiter <span class="title">GetAwaiter</span>(<span class="params"><span class="keyword">this</span> TimeSpan timeSpan</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Task.Delay(timeSpan).GetAwaiter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
而现在可以使用：<code>await TimeSpan.FromSeconds(2);</code> 更加简洁的一个操作是继续对<code>int</code>进行扩展，例如：<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Extensions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TaskAwaiter <span class="title">GetAwaiter</span>(<span class="params"><span class="keyword">this</span> TimeSpan timeSpan</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Task.Delay(timeSpan).GetAwaiter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TimeSpan <span class="title">Seconds</span>(<span class="params"><span class="keyword">this</span> <span class="built_in">int</span> integer</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> TimeSpan.FromSeconds(integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
现在就可以使用：<code>await 3.Seconds();</code> 了</li>
</ul>
<h1 id="required关键字"><a href="#required关键字" class="headerlink" title="required关键字"></a>required关键字</h1><p><code>required</code>关键字子在C# 11中被引入，表示字段必须由构造函数或<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/object-and-collection-initializers">对象初始化器</a>进行初始化：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">required</span> <span class="built_in">string</span> Title &#123;<span class="keyword">get</span>; <span class="keyword">init</span>;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="尽量避免使用Async-void方法"><a href="#尽量避免使用Async-void方法" class="headerlink" title="尽量避免使用Async void方法"></a><a href="https://www.devleader.ca/2024/03/07/async-void-methods-in-c-the-dangers-that-you-need-to-know/?utm_source=newsletter.csharpdigest.net&utm_medium=newsletter&utm_campaign=a-primer-on-transaction-management-in-entity-framework">尽量避免使用Async void方法</a></h1><p>在下面代码中，如果<code>ProcessDataAsync()</code>方法中抛出异常，<code>HandleButtonClick</code>无法正常捕获！而如果把<code>ProcessDataAsync</code>的返回值改成<code>async Task</code>则可以正常捕获：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">ProcessDataAsync</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Some asynchronous operations</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">HandleButtonClick</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        ProcessDataAsync();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// This will never catch the async exceptions!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="接口中的静态方法"><a href="#接口中的静态方法" class="headerlink" title="接口中的静态方法"></a><a href="https://www.bilibili.com/video/BV11w411j78c">接口中的静态方法</a></h1><h2 id="接口中的静态方法-1"><a href="#接口中的静态方法-1" class="headerlink" title="接口中的静态方法"></a><a href="https://www.bilibili.com/video/BV11w411j78c/?share_source=copy_web&vd_source=650872b82d3f8afa3cd791e577357475&t=1632">接口中的静态方法</a></h2><p>C# 8.0引入了接口的静态方法，该静态方法只能通过接口访问（不能通过实现类访问）。接口的静态方法具有很大的局限性，一般的应用场景是在泛型接口上使用静态方法，举例如下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//约束T必须实现IDeserializable</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IDeserializable</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">IDeserializable</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">static</span> T? Deserialize(<span class="built_in">string</span> json) =&gt; JsonSerializer.Deserialize&lt;T&gt;(json);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Student</span> : <span class="title">IDeserializable</span>&lt;<span class="title">Student</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，虽然接口的静态方法的使用场景具有局限性，但是我们同时也对泛型接口的类型<code>T</code>进行了<strong>约束</strong>。通过该约束，是的泛型接口的静态方法具备了实现基础，此时我们可以对<code>Student</code>类进行反序列化，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> student = IDeserializable&lt;Student&gt;.Deserialize(<span class="string">&quot;&#123; \&quot;Id\&quot; : 42, \&quot;Name\&quot; : \&quot;Tom\&quot; &#125;&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="接口中的抽象静态方法"><a href="#接口中的抽象静态方法" class="headerlink" title="接口中的抽象静态方法"></a><a href="https://www.bilibili.com/video/BV11w411j78c/?share_source=copy_web&vd_source=650872b82d3f8afa3cd791e577357475">接口中的抽象静态方法</a></h2><p>C# 10.0 进一步引入了抽象静态方法，在工厂设计模式中可以使用抽象静态方法，例如：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IFactory</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">abstract</span> T <span class="title">Create</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这要求所有实现了<code>IFactory&lt;T&gt;</code>泛型接口的类都要实现  <code>Student</code> 抽象静态方法。另外一种应用场景是单例模式，例如：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">ISingleton</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">ISingleton</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">abstract</span> T Instance &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">SingletonClass</span> : <span class="title">ISingleton</span>&lt;<span class="title">SingletonClass</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> SingletonClass Instance =&gt; <span class="keyword">new</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">临江听雨</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
