<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"blog.gamedo.org","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.24.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="听雨">
<meta property="og:url" content="https://blog.gamedo.org/index.html">
<meta property="og:site_name" content="听雨">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="临江听雨">
<meta property="article:tag" content="GameDev">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://blog.gamedo.org/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>听雨</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.9.0/mermaid.min.js","integrity":"sha256-Cz7UN0EXNjgV2u/a38wg/3BNfdRRO1XtgDq93L2GqJg="}}</script>
  <script src="/js/third-party/tags/mermaid.js" defer></script>





  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">听雨</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">临江听雨</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/pcloves" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;pcloves" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.gamedo.org/2025/07/03/Vert.x%20%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="临江听雨">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="听雨">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 听雨">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/07/03/Vert.x%20%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">Vert.x 网络通讯机制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-07-03 03:09:38" itemprop="dateCreated datePublished" datetime="2025-07-03T03:09:38+08:00">2025-07-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-13 18:22:16" itemprop="dateModified" datetime="2025-08-13T18:22:16+08:00">2025-08-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E6%B2%89%E6%B7%80/" itemprop="url" rel="index"><span itemprop="name">技术沉淀</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><ul>
<li>以下流程图展示了：<code>val netSocket = vertx.createNetClient().connect(6379, &quot;localhost&quot;).coAwait()</code> 连接到服务器的过程<pre>
<code class="mermaid">
sequenceDiagram
%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头
    participant NetClientImpl
    participant VertxHandler
    participant NetSocketImpl
    participant ChannelProvider
	Note over VertxHandler : VertxHandler&lt;C extends VertxConnection&gt; extends ChannelDuplexHandler
	loop NetClientImpl::connectInternal2(...)
		NetClientImpl --&gt;&gt; NetClientImpl : channelProvider &#x3D; new ChannelProvider(...)
		NetClientImpl -&gt;&gt; ChannelProvider : channelProvider.handler(ch -&gt; NetClientImpl::connected(..., ch, ...))
		NetClientImpl -&gt;&gt; ChannelProvider : channelProvider.connect(...)
		loop ChannelProvider::handleConnect
			ChannelProvider -&gt;&gt; ChannelProvider : bootStrap.handler(new ChannelInitializer&lt;Channel&gt;() {... initSSL ...})
			ChannelProvider -&gt;&gt; ChannelProvider : bootStrap.connect(...)
			Note over ChannelProvider : ChannelFuture.isSuccess()
			loop ChannelProvider::connected(handler, channel, ssl, ...)
				ChannelProvider -&gt;&gt; ChannelProvider : context.dispatch(channel, handler)				
			end
		end
	end
	loop NetClientImpl::connected(..., ch, ...)
		NetClientImpl --&gt;&gt; NetClientImpl : channelGroup.add(ch)
		loop NetClientImpl::initChannel(ch.pipeline(), ssl)
			NetClientImpl --&gt;&gt; NetClientImpl : pipeline.addLast(&quot;logging&quot;, new LoggingHandler(...))
			NetClientImpl --&gt;&gt; NetClientImpl : pipeline.addLast(&quot;chunkedWriter&quot;, new ChunkedWriteHandler())
			NetClientImpl --&gt;&gt; NetClientImpl : pipeline.addLast(&quot;idle&quot;, new IdleStateHandler(...))
		end
		NetClientImpl --&gt;&gt; NetClientImpl : handler &#x3D; VertxHandler.create(ctx -&gt; new NetSocketImpl(...))
		NetClientImpl --&gt;&gt; NetClientImpl : handler.removeHandler(NetSocketImpl::unregisterEventBusHandler)
		NetClientImpl --&gt;&gt; NetClientImpl : handler.addHandler(sock -&gt; {sock.registerEventBusHandler()})
		NetClientImpl --&gt;&gt; NetClientImpl : ch.pipeline().addLast(&quot;handler&quot;, handler)
	end

	loop VertxHandler的各种回调
		loop VertxHandler::handlerAdded(ChannelHandlerContext ctx)
			VertxHandler --&gt;&gt; VertxHandler : setConnection(connectionFactory.apply(ctx))
			VertxHandler --&gt;&gt; VertxHandler : addHandler.hander(connection)
		end
		loop VertxHandler::channelRead(ChannelHandlerContext ctx, Object msg)
			VertxHandler --&gt;&gt; NetSocketImpl : conn.read(msg)
			loop NetSocketImpl::handleMessage
				Note over NetSocketImpl : messageHandler为用户指定的消息处理器
				NetSocketImpl --&gt;&gt; NetSocketImpl : messageHandler.handler(msg)
			end
		end	
	end
</code>
</pre></li>
</ul>
<h1 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h1><p>TODO: 也没啥看的，和客户端一个调性~，不过有一点：vert.x的netty服务器端无法自定义Netty handler，不过也不是完全没有办法，可以参考：</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.gamedo.org/2025/07/02/Vert.x%20%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="临江听雨">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="听雨">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 听雨">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/07/02/Vert.x%20%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" class="post-title-link" itemprop="url">Vert.x 源码阅读</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-07-02 23:09:38" itemprop="dateCreated datePublished" datetime="2025-07-02T23:09:38+08:00">2025-07-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-13 18:16:07" itemprop="dateModified" datetime="2025-08-13T18:16:07+08:00">2025-08-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E6%B2%89%E6%B7%80/" itemprop="url" rel="index"><span itemprop="name">技术沉淀</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="VertxImpl"><a href="#VertxImpl" class="headerlink" title="VertxImpl"></a>VertxImpl</h1><ul>
<li><code>sharedNetServers（Map&lt;ServerID, NetServerInternal&gt;）</code><ul>
<li>解决多个<code>Verticle</code>实例监听同一个<code>host</code>和<code>port</code>的问题</li>
<li>key为<code>ServerID</code>，当ServerID内的<code>host</code>和<code>port</code>都相同时，代表同一个ServerID</li>
<li>可以参考文档：<a href="https://vertx-china.github.io/docs/vertx-core/java/#_scaling_sharing_tcp_servers">共享 TCP 服务端</a></li>
</ul>
</li>
</ul>
<h2 id="线程相关"><a href="#线程相关" class="headerlink" title="线程相关"></a>线程相关</h2><h3 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h3><ul>
<li>VertxImpl#eventLoopGroup（EventLoopGroup）<ul>
<li>源于transport的默认实现：<code>Transport#eventLoopGroup(int type, int nThreads, ThreadFactory threadFactory, int ioRatio)</code></li>
<li>本质为：<code>MultiThreadIoEventLoopGroup</code>，其<code>children</code>数量为：<strong>2 * CPU核数</strong>，每个child是一个：<code>SingleThreadIoEventLoop</code></li>
<li>线程前缀：<code>vert.x-eventloop-thread-</code></li>
</ul>
</li>
<li>VertxImpl#acceptorEventLoopGroup（EventLoopGroup）<ul>
<li>源于transport的默认实现：<code>Transport#eventLoopGroup(int type, int nThreads, ThreadFactory threadFactory, int ioRatio)</code></li>
<li>本质为：<code>MultiThreadIoEventLoopGroup</code>，其<code>children</code>数量为：<strong>1</strong>，每个child是一个：<code>SingleThreadIoEventLoop</code></li>
<li>线程前缀：<code>vert.x-acceptor-thread-</code></li>
</ul>
</li>
<li>VertxImpl#virtualThreadExecutor（ExecutorService）<ul>
<li>通过反射的方式获取到<code>VirtualThreadBuilder</code></li>
<li>本质为：<code>ThreadPerTaskExecutorService</code></li>
<li>线程前缀：<code>vert.x-virtual-thread-</code></li>
</ul>
</li>
</ul>
<h3 id="WorkerPool（包含一个ExecutorService和PoolMetrics）"><a href="#WorkerPool（包含一个ExecutorService和PoolMetrics）" class="headerlink" title="WorkerPool（包含一个ExecutorService和PoolMetrics）"></a>WorkerPool（包含一个ExecutorService和PoolMetrics）</h3><ul>
<li>VertxImpl#workerPool<ul>
<li><code>ExecutorService</code>本质为：<code>ThreadPoolExecutor</code></li>
<li>corePoolSize&#x2F;maximumPoolSize默认为：<strong>2 * CPU核数</strong></li>
<li>当使用<code>WORKER</code>的方式部署一个<code>Verticle</code>时，如果没有指定<code>workerPoolName</code>，默认是该WorkerPool</li>
</ul>
</li>
<li>VertxImpl#internalWorkerPool<ul>
<li><code>ExecutorService</code>本质为：<code>ThreadPoolExecutor</code></li>
<li>corePoolSize&#x2F;maximumPoolSize默认为：<strong>2 * CPU核数</strong></li>
</ul>
</li>
<li>VertxImpl#virtualThreaWorkerPool<ul>
<li><code>ExecutorService</code>本质为：ThreadPerTaskExecutorService</li>
<li>其内部的<code>ExecutorService</code>和<code>VertxImpl#virtualThreadExecutor</code>共享同一个实例引用</li>
</ul>
</li>
</ul>
<h3 id="stickyEventLoop"><a href="#stickyEventLoop" class="headerlink" title="stickyEventLoop"></a>stickyEventLoop</h3><ul>
<li>本质为：<code>ThreadLocal&lt;WeakReference&lt;EventLoop&gt;&gt;</code></li>
<li>起到线程<code>亲和</code>作用，同一个线程调用<code>stickyEventLoop()</code>时，尽量返回之前的线程</li>
<li>每次从<code>eventLoopGroup.next()</code>返回一个线程</li>
</ul>
<h1 id="ContextImpl"><a href="#ContextImpl" class="headerlink" title="ContextImpl"></a>ContextImpl</h1><p>当调用<code>Vertx#deployVerticle(...)</code>部署一个<code>Verticle</code>时，被<code>VertxImpl#getOrCreateContext()</code>创建，内部包含的重要变量：</p>
<ul>
<li><code>threadingModel（ThreadingModel）</code>：可选值为：<code>EVENT_LOOP</code>、<code>WORKER</code>、<code>VIRTUAL_THREAD</code>、<code>EXTERNAL</code></li>
<li><code>eventLoop（EventLoopExecutor）</code>：TODO</li>
<li><code>executor（EventExecutor）</code>：TODO</li>
<li><code>workerPool（WorkerPool）</code>：TODO<br>根据<code>threadingModel</code>的不同，决定了<code>eventLoop</code>、<code>executor</code>、<code>workerPool</code>使用不同的线程及线程池</li>
</ul>
<h3 id="ThreadModel"><a href="#ThreadModel" class="headerlink" title="ThreadModel"></a>ThreadModel</h3><ul>
<li><code>EVENT_LOOP</code><ul>
<li><code>executor</code><ul>
<li>本质为<code>EventLoopExecutor</code>，内部包含1个netty的<code>EventLoop（SingleThreadIoEventLoop）</code>的引用</li>
<li>线程来自于：<code>VertxImpl#stickyEventLoop()</code>也即<code>VertxImpl#eventLoopGroup.next()</code></li>
</ul>
</li>
<li><code>eventLoop</code><ul>
<li>和<code>executor</code>共享同一个实例引用</li>
</ul>
</li>
<li><code>workerPool</code><ul>
<li>线程来自于调用函数的参数或者<code>VertxImpl#workerPool</code>（当参数为空时）</li>
</ul>
</li>
</ul>
</li>
<li><code>WORKER</code><ul>
<li><code>executor</code><ul>
<li>本质为：<code>WorkerExecutor</code>，内部包含1个<code>WorkerPool</code>的引用</li>
<li>线程来自于调用函数的参数或者<code>VertxImpl#workerPool</code>（当参数为空时）</li>
</ul>
</li>
<li><code>eventLoop</code><ul>
<li>同<code>EVENT_LOOP</code>下的<code>eventLoop</code></li>
</ul>
</li>
<li><code>workerPool</code><ul>
<li>当进行部署时，如果指定了<code>workerPoolName</code>，则新创建一个<code>WorkerPool</code>，否则使用默认的：<code>VertxImpl#workerPool</code></li>
<li><code>workerPool</code>的线程池和<code>executor</code>的线程池共享同一个实例引用</li>
</ul>
</li>
</ul>
</li>
<li><code>VIRTUAL_THREAD</code><ul>
<li><code>executor</code><ul>
<li>本质为：<code>WorkerExecutor</code>，内部包含1个<code>WorkerPool</code>的引用</li>
<li>线程来自于<code>VertxImpl#virtualThreaWorkerPool</code></li>
</ul>
</li>
<li><code>eventLoop</code><ul>
<li>同<code>EVENT_LOOP</code>下的<code>eventLoop</code></li>
</ul>
</li>
<li><code>workerPool</code><ul>
<li>线程来自于<code>VertxImpl#virtualThreaWorkerPool</code></li>
<li><code>workerPool</code>的线程池和<code>executor</code>的线程池共享同一个实例引用</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="NetServerImpl"><a href="#NetServerImpl" class="headerlink" title="NetServerImpl"></a>NetServerImpl</h1><p>可以通过<code>Vertx#createNetServer</code>创建，其实例也被<code>HttpServerImpl#tcpServer</code>持有，可以内部实现基于Netty。当其<code>bind(...)</code>被调用时，并非真正执行绑定，当且仅当<code>vertx.sharedTcpServers()</code>不存在相同的绑定时，执行真正的Netty <code>Bootstrap</code>的创建及绑定操作（可以参考文档：<a href="https://vertx-china.github.io/docs/vertx-core/java/#_scaling_sharing_tcp_servers">共享 TCP 服务端</a>），主要成员包括：</p>
<ul>
<li><code>worker（Handler&lt;Channel&gt;）</code><ul>
<li>当<code>Channel</code>初始化时，将channel加入到<code>NetServerImpl#channelGroup</code>中</li>
<li>为<code>Channel</code>配置<code>Pipeline</code></li>
</ul>
</li>
<li><code>listenContext（ContextInternal）</code><ul>
<li>如果是在<code>VertxThread</code>线程（例如在<code>Verticle#start()</code>函数）中调用了<code>listen(...)</code>，则<code>listenContext</code>为当前线程（或Verticle）的Context，否则会触发<code>Vertx#getOrCreateContext</code>创建一个新的<code>Context</code></li>
</ul>
</li>
<li><code>eventLoop（EventLoop）</code>：<ul>
<li>线程来自于<code>ContextInternal#nettyEventLoop()</code>也即<code>ContextImpl#eventLoop#eventLoop</code></li>
<li>在执行<code>bind(...)</code>操作时<code>eventLoop</code>也会被加入到<code>channelBalancer</code>的workers（被用作Netty的<code>Bootstrap</code>的<strong>子</strong><code>EventLoopGroup</code>）列表，也就是说：Verticle的线程会参与到Netty的子<code>EventLoopGroup</code>中，当一个<code>Channel</code>被创建时，Netty会从所有的子<code>EventLoopGroup</code>选择一个<code>EventLoop</code>，当进行初始化时，Vert.x会通过<code>Channel</code>身上的<code>EventLoop</code>，找到</li>
</ul>
</li>
<li><code>channelGroup（ChannelGroup）</code><ul>
<li>本质为：<code>DefaultChannelGroup</code></li>
<li>线程来自于<code>ContextInternal#nettyEventLoop()</code>也即<code>ContextImpl#eventLoop#eventLoop</code></li>
<li>和<code>eventLoop</code>共享同一个实例引用</li>
<li>每一个<code>NetServerImpl</code></li>
</ul>
</li>
<li><code>handler（Handler&lt;NetSocket&gt;）</code><ul>
<li>提供给上层逻辑的回调接口，上层逻辑在调用<code>NetServer#listen</code>之前必须先赋值</li>
<li>具体作用TODO</li>
</ul>
</li>
<li><code>exceptionHandler（Handler&lt;Throwable&gt;）</code><ul>
<li>提供给上传逻辑的回调接口，HttpServerImpl的默认实现为：<code>t -&gt; log.trace(&quot;Connection failure&quot;, t);</code></li>
</ul>
</li>
<li><code>channelBalancer（ServerChannelLoadBalancer）</code><ul>
<li>继承自<code>ChannelInitializer&lt;Channel&gt;</code>，实现<code>Channel</code>的初始化</li>
<li>被用作Netty的<code>Bootstrap</code>的<code>childHandler</code></li>
<li>其内部成员：<code>workers（VertxEventLoopGroup）</code>被用作Netty的<code>Bootstrap</code>的子<code>EventLoopGroup</code></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.gamedo.org/2025/07/02/Vert.x%20JWT%E8%AE%A4%E8%AF%81%E5%AE%9E%E6%88%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="临江听雨">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="听雨">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 听雨">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/07/02/Vert.x%20JWT%E8%AE%A4%E8%AF%81%E5%AE%9E%E6%88%98/" class="post-title-link" itemprop="url">Vert.x JWT认证实战</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-07-02 18:09:38" itemprop="dateCreated datePublished" datetime="2025-07-02T18:09:38+08:00">2025-07-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-13 18:13:19" itemprop="dateModified" datetime="2025-08-13T18:13:19+08:00">2025-08-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E6%B2%89%E6%B7%80/" itemprop="url" rel="index"><span itemprop="name">技术沉淀</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="生成KeyStore"><a href="#生成KeyStore" class="headerlink" title="生成KeyStore"></a>生成KeyStore</h1><ul>
<li>通过<strong>openssl</strong>生成公私钥对：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">openssl genpkey -algorithm RSA -out private.key -pkeyopt rsa_keygen_bits:2048</span><br><span class="line">````</span><br><span class="line">* 通过**openssl**生成自签名证书</span><br><span class="line">``` bash</span><br><span class="line">openssl req -new -x509 -key private.key -out certificate.crt -days 3650</span><br><span class="line">````</span><br><span class="line">* 通过**openssl**将证书和公私钥存储到**keystore**</span><br><span class="line">    * 由于Vert.x的[源码](https://github.com/eclipse-vertx/vertx-auth/blob/76717f72da6977e14394ef4ca67dfca47d430f31/vertx-auth-common/src/main/java/io/vertx/ext/auth/impl/jose/JWK.java#L168)中加载keystore时，仅识别指定的别名，因此这里选择对应的别名：**RS256**，也即**RSA**秘钥及**SHA256**哈希算法</span><br><span class="line">    * keystore的密码为：`123456`</span><br><span class="line">``` bash</span><br><span class="line">openssl pkcs12 -<span class="built_in">export</span> -<span class="keyword">in</span> certificate.crt -inkey private.key -out keystore.p12 -name <span class="string">&quot;RS256&quot;</span> -password pass:123456</span><br><span class="line"></span><br><span class="line"><span class="comment">#另外，keystore提取私钥的方式：</span></span><br><span class="line">openssl pkcs12 -<span class="keyword">in</span> keystore.p12 -nodes -nocerts -out extracted_private.key -password pass:123456</span><br><span class="line">````</span><br><span class="line">* 将生成的`keystore.p12`文件拷贝到项目工程的`resources`目录下</span><br><span class="line"><span class="comment"># JWT认证及授权服务端</span></span><br><span class="line">* 编写vert.x http服务端，并且使用jwt认证</span><br><span class="line">``` java</span><br><span class="line">package com.example.vertxStudy</span><br><span class="line"></span><br><span class="line">import io.vertx.core.Future</span><br><span class="line">import io.vertx.core.VerticleBase</span><br><span class="line">import io.vertx.core.json.JsonObject</span><br><span class="line">import io.vertx.ext.auth.JWTOptions</span><br><span class="line">import io.vertx.ext.auth.KeyStoreOptions</span><br><span class="line">import io.vertx.ext.auth.authorization.PermissionBasedAuthorization</span><br><span class="line">import io.vertx.ext.auth.jwt.JWTAuth</span><br><span class="line">import io.vertx.ext.auth.jwt.JWTAuthOptions</span><br><span class="line">import io.vertx.ext.auth.jwt.authorization.impl.JWTAuthorizationImpl</span><br><span class="line">import io.vertx.ext.web.Router</span><br><span class="line">import io.vertx.ext.web.handler.AuthorizationHandler</span><br><span class="line">import io.vertx.ext.web.handler.BodyHandler</span><br><span class="line">import io.vertx.ext.web.handler.JWTAuthHandler</span><br><span class="line">import io.vertx.ext.web.handler.SecurityAuditLoggerHandler</span><br><span class="line">import io.vertx.kotlin.core.http.httpServerOptionsOf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class JWTAuthVerticle : <span class="function"><span class="title">VerticleBase</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">  override fun start(): Future&lt;*&gt; &#123;</span><br><span class="line"></span><br><span class="line">    val router = Router.router(vertx)</span><br><span class="line">    router.route().handler(SecurityAuditLoggerHandler.create()).handler(BodyHandler.create())</span><br><span class="line"></span><br><span class="line">    val config = JWTAuthOptions()</span><br><span class="line">      .setKeyStore(</span><br><span class="line">        KeyStoreOptions()</span><br><span class="line">          .setType(<span class="string">&quot;pkcs12&quot;</span>) // 或 <span class="string">&quot;pkcs12&quot;</span></span><br><span class="line">          .setPath(<span class="string">&quot;keystore.p12&quot;</span>)</span><br><span class="line">          .setPassword(<span class="string">&quot;123456&quot;</span>)</span><br><span class="line">      )</span><br><span class="line">      .setJWTOptions(JWTOptions().setAlgorithm(<span class="string">&quot;RS256&quot;</span>))</span><br><span class="line"></span><br><span class="line">    val jwtAuthProvider = JWTAuth.create(vertx, config)</span><br><span class="line">    val jWTAuthHandler = JWTAuthHandler.create(jwtAuthProvider)</span><br><span class="line"></span><br><span class="line">    router.post(<span class="string">&quot;/login&quot;</span>).handler &#123; ctx -&gt;</span><br><span class="line"></span><br><span class="line">      val body = ctx.body().asJsonObject()</span><br><span class="line">      <span class="keyword">if</span> (body == null) &#123;</span><br><span class="line">        ctx.response()</span><br><span class="line">          .setStatusCode(400) // Bad Request</span><br><span class="line">          .end(<span class="string">&quot;Bad Request: Body is missing or not a valid JSON. Please ensure the &#x27;Content-Type&#x27; header is &#x27;application/json&#x27;.&quot;</span>)</span><br><span class="line">        <span class="built_in">return</span>@handler</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 现在可以安全地访问 body</span><br><span class="line">      val role = body.getString(<span class="string">&quot;role&quot;</span>)</span><br><span class="line"></span><br><span class="line">      // 为简单起见，我们为示例用户创建一个token</span><br><span class="line">      val claims = JsonObject()</span><br><span class="line">        //这里应该使用真正的用户</span><br><span class="line">        .put(<span class="string">&quot;sub&quot;</span>, <span class="string">&quot;987654321&quot;</span>)</span><br><span class="line">        .put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Nancy&quot;</span>)</span><br><span class="line">        //指定授权，可以不用放在realm_access下，而是直接放在roles下，这里是为了后面的演示特意为之</span><br><span class="line">        .put(<span class="string">&quot;realm_access&quot;</span>, JsonObject().put(<span class="string">&quot;roles&quot;</span>, listOf(role)))</span><br><span class="line">      val token = jwtAuthProvider.generateToken(claims)</span><br><span class="line"></span><br><span class="line">      ctx.response().putHeader(<span class="string">&quot;content-type&quot;</span>, <span class="string">&quot;text/plain&quot;</span>).end(token)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //指定permission列表所在的路径，需要和login返回的token的路径保持一致</span><br><span class="line">    val rootClaim = <span class="string">&quot;realm_access/roles&quot;</span></span><br><span class="line">    val authorizationProvider = AuthorizationHandler</span><br><span class="line">      .create(PermissionBasedAuthorization.create(<span class="string">&quot;admin&quot;</span>))</span><br><span class="line">      .addAuthorizationProvider(JWTAuthorizationImpl(rootClaim))</span><br><span class="line"></span><br><span class="line">    router.route(<span class="string">&quot;/protected&quot;</span>)</span><br><span class="line">      //先认证身份</span><br><span class="line">      .handler(jWTAuthHandler)</span><br><span class="line">      //再验证授权（需要有admin的授权）</span><br><span class="line">      .handler(authorizationProvider)</span><br><span class="line"></span><br><span class="line">    router.get(<span class="string">&quot;/protected&quot;</span>).handler &#123; ctx -&gt;</span><br><span class="line">      ctx.response().end(<span class="string">&quot;Hello <span class="variable">$&#123;ctx.user().get&lt;String&gt;(&quot;name&quot;)&#125;</span>!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> vertx</span><br><span class="line">      .createHttpServer(httpServerOptionsOf(registerWriteHandler = <span class="literal">true</span>))</span><br><span class="line">      .requestHandler(router)</span><br><span class="line">      .listen(8888).onSuccess &#123; http -&gt;</span><br><span class="line">        println(<span class="string">&quot;HTTP server started on port <span class="variable">$&#123;http.actualPort()&#125;</span>&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="生成token"><a href="#生成token" class="headerlink" title="生成token"></a>生成token</h1><h2 id="方式1"><a href="#方式1" class="headerlink" title="方式1"></a>方式1</h2><ul>
<li>打开<a href="https://jwt.rocks/">Online JWT tool</a>，在Decoded Header中输入：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span><span class="string">&quot;RS256&quot;</span><span class="punctuation">,</span><span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span><span class="string">&quot;JWT&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>在Decoded Payload中输入授权服务器生成的业务数据（本示例没有admin身份）：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1234567890&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;John Doe&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;admin&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;iat&quot;</span><span class="punctuation">:</span> <span class="number">1516239022</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;realm_access&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;roles&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;user&quot;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>在Private Key中，输入<code>private.key</code>中的私钥，例如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN PRIVATE KEY-----</span><br><span class="line">MIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQDSXVvT5zcW3laj</span><br><span class="line">0FUZELJrJUpKhsguYCBnWFJIk/54IxEuLh53G6xeI8dWhhSIRwDy6wr/UFfx40pD</span><br><span class="line">44WUBtrOREC599g2yCaUku1b8hf6T7+gU4vpGdBt5HEggGWf9vVsIy6AEFiFx6ta</span><br><span class="line">0wqU2EfX6tVeU37KLmAboRNhQQmsFdxl0TaYv8Z3sVN3UQ61axL/1gpcTQqGw0TC</span><br><span class="line">hvDwXXAodSj6/3LPEts707IJ5S5QKanKEjdLdO0JOdcaR69k5iG+1NMgktQBm5Wb</span><br><span class="line">/ym0rAfP5syC0hhHY+EfLl8sqOzls4u1L4zsr0pTZmDd+IV/GcbeR6saxskQW10J</span><br><span class="line">IWwuNh3FAgMBAAECggEBAIGV1wJS9SGWNwLUTAeTvIS6ROhh3KCMwIlI4+8nk2MI</span><br><span class="line">HwY2jLfMiUK4gYvwLmfAbXo2heC+6l3sKIxndJq6GkFj1Ad7AGrGotV1KNgx6slc</span><br><span class="line">JOwraw1dxIJdbb6auX9vzsEdbwCekRlf5VOem28TSDZex69CeeEr7jI26ExJlx60</span><br><span class="line">fZOVm9f6sqH8xs2w1Subdsjrpcqv11TZJ0D9RwhBZYBnE1bP70LzCUlOYl2KAEFT</span><br><span class="line">ob/oh34Xr0Ra1kdwWPsPbCXFs5JGqEW8IGUZcA/YpADNOEsw2f4arbHFs5nGUrRb</span><br><span class="line">4+dkTVLquIQm3AmQyPucx/Wpd9pfpZqnsgMXUIFvHiECgYEA/uqIMZpLOLk2WhCf</span><br><span class="line">Kk9cPy2pGO7htUBtm5pRkQCD+GUsYYDzrGXQTLLKuH1+Cqr7TnDpu1/CZjJGJnOB</span><br><span class="line">/IsS3LbQ6t5wwXEqfi44vIpOGF9Uw6ESoNQhiYl29QmgqkxeWgIzpMSwmXvwlTJl</span><br><span class="line">9GK4rnzfbh0C4+ysc1chFXjijCkCgYEA00JVeIuwZ31cMggEV1YRWUZwPnBiB8zT</span><br><span class="line">/T2C8kNCO2pAGYnqjzfd2dWu3L9NH2ah4UvKBfIBd0JVOETFh/Z9wEigZjHFeZzC</span><br><span class="line">maziNmUWlDMvtSmzTzP4SOITEvYn+2iSVyx8dQl2OCnRK74o3/RjDRCkpCAUnlaQ</span><br><span class="line">IobAmyM7+D0CgYEAlZOanLhzgPI0sT5llpcAgtXRDh9Fc2w9pHs1d0b9KOh81S2s</span><br><span class="line">TbFkO00B5KVGKw5O7aUVkOvMjtjbDr7iPASC6d2f0uD4+pjjnSyUABWLY4O0oiHG</span><br><span class="line">Y3Z1w1VU5s1iZ+rtxhTapsj+8uClt3XeGzs+MKx3Eg6V3pXGTtuGPyoyjJkCgYEA</span><br><span class="line">0eYXe+T2yWxhnQggIBJQvG3i+fa5P9zAR93E7CXteZEQzQ8dsVylnVjVG1krLGbR</span><br><span class="line">skKWICAaWr7aY0TZKkS7HsBKNh9/gFxDcWK3g6oeq/LLlOkw0iHlr6yHnRBcG0wE</span><br><span class="line">En8NzU8wWY8a16ZhgFqVy5ZcrwF82vFQ1i0i00FHxVUCgYBUc6JC1DePyCApdQXJ</span><br><span class="line">Qn/pYtPwBKSmllLkEkrzUPmJSlWVgdzfynjGU5WF/2DFOaKHxoKW+npaRnXgi3c4</span><br><span class="line">oJs1Ow/nrYFZZSxnXgI/hWCC/+eu2JfHOnPqIcgRniJ25jEINcoK+LjSAVthfad7</span><br><span class="line">vjkKAV0kmZtN6kmFfBNS34k+XA==</span><br><span class="line">-----END PRIVATE KEY-----</span><br></pre></td></tr></table></figure></li>
<li>生成token，例如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMiwicmVhbG1fYWNjZXNzIjp7InJvbGVzIjpbImFkbWluIiwidXNlciJdfX0.QPrVDABsyOkI4qUhxhhWis5o21T1xYYJqWw5Itp31jirQLHREvwF3lx0DEkFESguJ95qcnwJH9HHAcOT-y_BGyQaosktnBRJsgedAr4FByRO2hwzrAvUpAYHXcLfzbL_5H8KmuheN5sf3TxdFp3LWdvFSiHhom3oPALIkdrOzwSGx75ET4O6SvTTO86N6XimIPbJuhPRl7QIDzYKMPELiQH7LyooXlS0-hQCRIV6n82wYOH8UM1lM75lp4bUtPM4F3w7__Fc3LFzBKSMiOs-fkn-oYkRpv8d6fbjMA39HkN0AOZj4RmCM54-HCFETIWvLuOZ2Yivt6QgCO-F2Su6SQ</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="方式2"><a href="#方式2" class="headerlink" title="方式2"></a>方式2</h2><ul>
<li>通过<code>/login</code>动态下发token<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">token=$(curl -XPOST -d <span class="string">&#x27;&#123;&quot;role&quot; : &quot;admin&quot;&#125;&#x27;</span> -H <span class="string">&#x27;Content-Type: application/json&#x27;</span> http://10.12.16.218:8888/login) &amp;&amp; <span class="built_in">echo</span> <span class="variable">$token</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="验证token"><a href="#验证token" class="headerlink" title="验证token"></a>验证token</h1><ul>
<li>在curl中发送请求：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#针对方式1（且没有admin授权）</span></span><br><span class="line">$ curl -i -H <span class="string">&#x27;Authorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMiwicmVhbG1fYWNjZXNzIjp7InJvbGVzIjpbInVzZXIiXX19.mQm9BLP-RkKJDaiiuzy-YmtO8-wQyjOpHlb2i_hrrTjwoYFx1AqdP7egvaAhxLdxwgMI9qgstTA-WOA6Vi01jfVoTk0RfV0rzocDDMOHrNaevlqkBSPIB2Jx8EYWQNCTZ8vjvTPezmgWgQjxaA7l21IwzOqA23N-v9ziEdJx46EkRCeee6EO-Bb9jN63DekbiYAz-ccsPT3PxjdFtSklxLmDePNNXeS7HjwnHqbYj6fFAd0RlbXq71lQS5MfgPhkC_SdCjdtOUIe6v6twSMDZcDrpGfX47RY1jDOJ-f-QjnbKbyWdZ6j7_uasgDr9BGlIpcXVV7F4nkeuNMA4kQp7g&#x27;</span> http://10.12.16.218:8888/protected</span><br><span class="line">HTTP/1.1 403 Forbidden</span><br><span class="line">content-length: 9</span><br><span class="line"></span><br><span class="line">Forbidden</span><br><span class="line"></span><br><span class="line"><span class="comment">#针对方式2</span></span><br><span class="line">$ curl -H <span class="string">&quot;Authorization: Bearer <span class="variable">$&#123;token&#125;</span>&quot;</span> http://10.12.16.218:8888/protected                  Hello Nancy!</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.gamedo.org/2025/07/01/Vert.x%20OAuth2%E8%AE%A4%E8%AF%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="临江听雨">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="听雨">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 听雨">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/07/01/Vert.x%20OAuth2%E8%AE%A4%E8%AF%81/" class="post-title-link" itemprop="url">Vert.x OAuth2认证</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-07-01 17:50:00" itemprop="dateCreated datePublished" datetime="2025-07-01T17:50:00+08:00">2025-07-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-13 18:04:49" itemprop="dateModified" datetime="2025-08-13T18:04:49+08:00">2025-08-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E6%B2%89%E6%B7%80/" itemprop="url" rel="index"><span itemprop="name">技术沉淀</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="OAuth2认证（记忆法则：3次302）"><a href="#OAuth2认证（记忆法则：3次302）" class="headerlink" title="OAuth2认证（记忆法则：3次302）"></a>OAuth2认证（记忆法则：3次302）</h1><ol>
<li><strong>用户请求登录（第1次302）</strong>：<ul>
<li>用户在你的应用中点击“使用GitHub登录”，本例为：**&#x2F;login**</li>
<li>Vert.x 服务器（通过 <code>OAuth2AuthHandler</code>）响应用户的浏览器，发送一个 <strong>HTTP 302 重定向</strong>响应，其location为<strong>OAuth2</strong>服务器地址。</li>
<li><code>Location</code> Header 指向 GitHub 的授权页面，并附带 <code>client_id</code> 和 <code>redirect_uri</code> (<code>http://localhost:8888/callback</code>) 等参数。</li>
</ul>
</li>
<li><strong>用户在GitHub授权</strong>：<ul>
<li>用户的浏览器跳转到 GitHub 网站。</li>
<li>用户输入用户名密码，并点击“授权”，同意让你的应用访问其信息。</li>
</ul>
</li>
<li><strong>GitHub重定向回你的应用（第2次302跳转）</strong>：<ul>
<li>GitHub 的服务器在用户授权后，并<strong>不会直接调用</strong>你的服务器。</li>
<li>它会向用户的<strong>浏览器</strong>发送一个 <strong>HTTP 302 重定向</strong>响应。</li>
<li>这个响应的 <code>Location</code> Header 就是你在第一步中提供的回调URL，并且附加上了授权码 <code>code</code> 和一个 <code>state</code> 值，例如：<a href="http://localhost:8888/callback?code=ABCDEFG&state=HIJKLMNOP%60%E3%80%82">http://localhost:8888/callback?code=ABCDEFG&state=HIJKLMNOP</a></li>
</ul>
</li>
<li><strong>浏览器发起回调请求</strong>：<ul>
<li>用户的<strong>浏览器</strong>收到这个 302 响应后，会立即根据 <code>Location</code> Header 的指示，向 <code>http://localhost:8888/callback?code=...</code> <strong>发起一个新的GET请求</strong>。</li>
<li>所以，最终是用户的浏览器，而不是 GitHub 的服务器，向你的 Vert.x 应用发起了 <code>/callback</code> 请求。</li>
</ul>
</li>
<li><strong>你的服务器处理回调（第3次302）</strong>：<ul>
<li>你的 Vert.x 应用收到来自浏览器的 <code>/callback</code> 请求。</li>
<li>后续流程就和我们之前讨论的一样了：<code>Router</code> 将这个请求交给了 <code>oauth2Handler</code> 设置的内部处理器。</li>
<li>这个处理器从 URL 中提取 <code>code</code>，然后在<strong>后台</strong>（服务器到服务器的通信）向 GitHub 的 API 发送请求，用 <code>code</code> 换取最终的 <code>access_token</code></li>
<li>向用户的<strong>浏览器</strong>发送一个 <strong>HTTP 302 重定向</strong>响应，location为：&#x2F;login（也即第1次请求的路径）。</li>
</ul>
</li>
<li><strong>浏览器继续发起登录请求</strong><ul>
<li>进入到用户路由<strong>Handler</strong></li>
</ul>
</li>
</ol>
<h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><pre>
<code class="mermaid">
sequenceDiagram
%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头
    participant 浏览器
    participant OAuth2AuthHandlerImpl
    participant OAuth2AuthProviderImpl
    participant OAuth2API
    participant GitHub
    Note over OAuth2AuthHandlerImpl,OAuth2API: Vert.x OAuth2框架
    浏览器 -&gt;&gt; OAuth2AuthHandlerImpl: &#x2F;login
	Note over 浏览器,OAuth2AuthHandlerImpl: http:&#x2F;&#x2F;localhost:8888&#x2F;login
    loop ctx.user()为空
        OAuth2AuthHandlerImpl --&gt;&gt; OAuth2AuthHandlerImpl: HttpException(302, redirect_url)
        OAuth2AuthHandlerImpl --&gt;&gt; OAuth2AuthHandlerImpl: session.put(&quot;state&quot;, wj9awH9D)
        OAuth2AuthHandlerImpl -&gt;&gt; 浏览器: http status: 302
        Note over 浏览器,OAuth2AuthHandlerImpl: location:&lt;br&#x2F;&gt;https:&#x2F;&#x2F;github.com&#x2F;login&#x2F;oauth&#x2F;authorize?&lt;br&#x2F;&gt;redirect_uri&#x3D;http:&#x2F;&#x2F;localhost:8888&#x2F;callback&amp;&lt;br&#x2F;&gt;state&#x3D;wj9awH9D&amp;response_type&#x3D;code&amp;&lt;br&#x2F;&gt;client_id&#x3D;xxx
    end
    浏览器 -&gt;&gt; GitHub: https:&#x2F;&#x2F;github.com&#x2F;login&#x2F;oauth&#x2F;authorize?redirect_uri&#x3D;http:&#x2F;&#x2F;localhost:8888&#x2F;callback&amp;state&#x3D;wj9awH9D&amp;response_type&#x3D;code&amp;client_id&#x3D;xxx
    Note over 浏览器,GitHub: 用户在GitHub登录并授权
    GitHub -&gt;&gt; 浏览器: http status: 302
    Note over 浏览器,GitHub: http:&#x2F;&#x2F;localhost:8888&#x2F;callback?code&#x3D;172376f83cd7cd78f6d3&amp;state&#x3D;wj9awH9D
    浏览器 -&gt;&gt; OAuth2AuthHandlerImpl: &#x2F;callback
    Note over 浏览器,OAuth2AuthHandlerImpl: http:&#x2F;&#x2F;localhost:8888&#x2F;callback?&lt;br&#x2F;&gt;code&#x3D;172376f83cd7cd78f6d3&amp;&lt;br&#x2F;&gt;state&#x3D;wj9awH9D
    OAuth2AuthHandlerImpl -&gt;&gt; OAuth2AuthHandlerImpl: callback.handler
    OAuth2AuthHandlerImpl --&gt;&gt; OAuth2AuthHandlerImpl: check state &amp;&amp; session.remove(&quot;state&quot;)
    Note over OAuth2AuthHandlerImpl,OAuth2AuthHandlerImpl: 防止重放攻击
    OAuth2AuthHandlerImpl -&gt;&gt; OAuth2AuthProviderImpl: authProvider.authenticate
    OAuth2AuthProviderImpl -&gt;&gt; OAuth2API: api.token(grantType, params)
    OAuth2API -&gt;&gt; GitHub: POST &#x2F;login&#x2F;oauth&#x2F;access_token
    Note over OAuth2API,GitHub: header&lt;br&#x2F;&gt;User-Agent : vertx-auth-oauth2&lt;br&#x2F;&gt;Accept : application&#x2F;json,...&lt;br&#x2F;&gt;Content-Type : application&#x2F;x-www-form-urlencoded
    GitHub -&gt;&gt; OAuth2AuthHandlerImpl: response
    Note over GitHub, OAuth2AuthHandlerImpl: {&quot;access_token&quot; :&quot;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&quot;,&lt;br&#x2F;&gt;  &quot;token_type&quot; : &quot;bearer&quot;,&lt;br&#x2F;&gt;  &quot;scope&quot; : &quot;user:email&quot;}
    OAuth2AuthHandlerImpl -&gt;&gt; OAuth2AuthHandlerImpl: session.regenerateId()
    OAuth2AuthHandlerImpl -&gt;&gt; 浏览器: http status 302
    Note over OAuth2AuthHandlerImpl, 浏览器: cache-control : no-cache, no-store, must-revalidate&lt;br&#x2F;&gt;expires : 0&lt;br&#x2F;&gt;location : &#x2F;login&lt;br&#x2F;&gt;set-cookie : vertx-web.session&#x3D;dfdxxxx950bfe1ac580
	loop ctx.user()不为空
	    浏览器 -&gt;&gt; OAuth2AuthHandlerImpl: &#x2F;login
	    Note over 浏览器,OAuth2AuthHandlerImpl: vertx-web.session : dfdxxxx950bfe1ac580
	    OAuth2AuthHandlerImpl -&gt;&gt; OAuth2AuthHandlerImpl: postAuthentication(ctx)
	    OAuth2AuthHandlerImpl -&gt;&gt; OAuth2AuthHandlerImpl: 检查用户的scope是否满足路由的scope
	    OAuth2AuthHandlerImpl -&gt;&gt; OAuth2AuthHandlerImpl: ctx.next()继续流转到用户路由
	end
</code>
</pre>












































































      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.gamedo.org/2022/01/11/%E7%AC%AC1%E9%83%A8%E5%88%86%EF%BC%9AG1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="临江听雨">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="听雨">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 听雨">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/01/11/%E7%AC%AC1%E9%83%A8%E5%88%86%EF%BC%9AG1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%AE%80%E4%BB%8B/" class="post-title-link" itemprop="url">[译]第一篇：G1垃圾回收器简介</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-01-11 17:57:00" itemprop="dateCreated datePublished" datetime="2022-01-11T17:57:00+08:00">2022-01-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-12 14:47:53" itemprop="dateModified" datetime="2025-08-12T14:47:53+08:00">2025-08-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E6%B2%89%E6%B7%80/" itemprop="url" rel="index"><span itemprop="name">技术沉淀</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>对大多数人来说，Java垃圾回收器是一个可以让用户愉快处理业务的黑匣子。程序开发程序，测试（QE）验证功能，运维负责部署。在这个过程中，你可能会对堆大小、PermGen&#x2F;Metaspace或线程进行一些调整，除此之外，似乎一切都运行正常。那么问题来了，当你准备打开这个匣子时会发生什么？当这些默认值不再满足需求时又将怎样呢？作为一名开发人员、测试人员、性能工程师或架构师，了解垃圾收集工作原理的基础知识，以及如何收集和分析相应的数据并将其转化为有效的调优实践，都是非常宝贵的技能。在本系列文章中，我将带你体验G1垃圾收集器，并把你从G1初学者转变为G1爱好者，并且将GC的性能优化到极致。</p>
<p>我们从最基本的话题开始：G1收集器的关键是什么？它是如何工作的？如果对于它的设计目标、如何决策以及如何设计没有一个综合性的理解。这就好比你设定好了目的地，但是却没有准备好交通工具或者导航地图。</p>
<p>G1收集器的核心目标是实现一个可预测的，软性的暂停时间，这个目标就是通过参数 <code>-XX:MaxGCPauseMillis</code> 定义的，与此同时也保持一贯的（consistent ）应用吞吐量。最终目标是满足当今高性能的、多线程的以及堆内存不断增大的应用程序的业务需求。G1的一般性原则是：暂停时间设置得越大，可实现的吞吐量和总延迟就越高。而暂停时间目标设置得越小，可实现的吞吐量和总延迟就越低。而你使用G1的目标就是结合应用程序的运行需求、自身特性以及对于G1的理解，调整出一组参数（options），并实现业务需求下的最佳运行状态。有一点需要牢记的是：调优是一个不断循序渐进的过程，在这个过程中，你需要通过反复地测试和评估来建立测试基线和调优设置。而对于调优这件事，并不存在一个明确的指南或者说万金油参数，你需要对性能进行评估，然后调整参数，再次评估，直到达到目标要求。</p>
<p>对于G1来说，它通过几种不同的方式来实现这些目标。首先，就像它的名字一样，G1收集存活对象数量最少的region（也即垃圾优先！），并将存活对象压缩&#x2F;转移（compacts&#x2F;evacuates）到新region。其次，G1使用了一系列逐步的、并行的、多阶段的循环来满足软暂停的目标。这允许G1在规定的时间内做最必要的事情，而不必考虑整个堆的大小。</p>
<p>在上文中，我们引入了一个新的概念： <code>区域</code> （regions）（译注：后文统一使用region）。简单来说，一个region代表一个已分配的堆内存区间，它可以存储任何分代的对象，并且不需要和同一代的其他region保持地址连续性。在G1中，传统的年轻代（Young ）和老年代（Tenured ）的概念仍然存在。年轻代包含Eden区和Survivor区，对象在Eden区创建，当发生GC时，对象被转移到Survivor区。存活对象一直待在Survivor区直到它们被回收或者由于年龄超过 <code>XX:MaxTenuringThreshold</code> （默认值为15）晋升到老年代。老年代包括Old region，当存活对象的年龄达到 <code>XX:MaxTenuringThreshold</code> 时就从Survivor区晋升到该区。当然万事都有例外，我们会在后文详细讨论。当虚拟机启动时，region的数量就被计算出来了。并且遵循这么一个原则：region的数量尽量的接近2048，每个region的大小都是1MB到64MB之间，并且该值是2的指数幂（2^n）。简单举例，假设存在一个12GB大小的堆，那么：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">12288 MB / 2048 = 6 MB  - 6不是2的指数幂，不符合要求</span><br><span class="line">12288 MB / 8 MB = 1536  - 1536个region有些小</span><br><span class="line">12288 MB / 4 MB = 3072  - 嗯，可以接受</span><br></pre></td></tr></table></figure>

<p>根据上面的计算，默认情况下JVM虚拟机会分成3072个region，每个region的大小为4MB，正如如下图所示。当然，你也可以通过设置参数： <code>-XX:G1HeapRegionSize</code> 显式的设置region的个数。当手动设置region数量时，理解堆大小与region数量的比值就显得非常重要，因为region数量越少，G1的灵活性就会越低，扫描、标记和收集每个region所需的时间也就越长。不管什么情况下，空的region都会添加到被称为“<strong>空闲列表</strong>”（free list）的无序链表中。</p>
<p><img src="https://www.redhat.com/cms/managed-files/heap-empty-regions.png"></p>
<p>虽然G1是一个分代的垃圾收集器，但是在堆空间上分配和使用并非连续的，因为它需要动态调整年轻代和老年代的配比，以达到最佳性能。当对象开始被分配时，会从<strong>空闲列表</strong>中分配一个region作为<strong>本地线程分配缓冲区</strong>（TLAB），该分配操作通过CAS确保同步性。之后对象就从该缓存区中创建而不需要额外同步。当某region的空间被对象填满后，会选择一个新的region继续填充。当所有Eden区的region都被填满时，会触发一次 <code>转移暂停</code>（<code>evacuation pause</code> ， 也称作 young collection &#x2F; young gc &#x2F; young pause或者mixed collection &#x2F; mixed gc &#x2F; mixed pause），Eden区内region的数量就大致就代表了软暂停时间内需要垃圾回收的region数量。整个堆分配的Eden region的数量介于5%和60%之间，并且在每次young gc后基于本次yong gc的性能情况进行动态调整。</p>
<p>以下是将对象分配到非连续Eden区的示意图</p>
<p><img src="https://www.redhat.com/cms/managed-files/heap-eden-regions.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GC pause (young); #1</span><br><span class="line">          [Eden: 612.0M(612.0M)-&gt;0.0B(532.0M) Survivors: 0.0B-&gt;80.0M Heap: 612.0M(12.0G)-&gt;611.7M(12.0G)]</span><br><span class="line">GC pause (young); #2</span><br><span class="line">          [Eden: 532.0M(532.0M)-&gt;0.0B(532.0M) Survivors: 80.0M-&gt;80.0M Heap: 1143.7M(12.0G)-&gt;1143.8M(12.0G)]</span><br></pre></td></tr></table></figure>

<p>根据上面的 <code>GC pause (young)</code> 日志，我们可以发现在 <strong>#1</strong>所示的暂停中，由于Eden区达到了 <strong>612.0M</strong> （总空间为也<strong>612.0M</strong>，一共153个region）而触发转移（evacuation）操作。整个Eden区域都被转移（<strong>0.0B</strong>）。鉴于本次GC所消耗的时间，Eden区还被缩减到<strong>532.0M</strong>（133个region）。在**#2<strong>所示的暂停中，我们看到由于达到了</strong>532.0M<strong>的上限，转移操作再次触发。并且由于暂停时间符合预期，Eden区仍然保持在</strong>532.0M**。</p>
<blockquote>
<p>译注：</p>
<p>有些文章会把evacuation翻译为<strong>拷贝</strong>或<strong>疏散</strong>，本文使用《深入Java虚拟机：JVM G1GC的算法与实现》一书中的译法，翻译为<strong>转移</strong></p>
</blockquote>
<p>当上述young gc发生时，死亡对象被回收，存活对象被转移并压缩到Survivor区。G1收集器包含一个由<strong>G1ReservePercent</strong>（默认值为10%）明确定义的硬性边界，这个边界保证了在转移时整堆中总有一部分空间作为Survivor区。而如果没有这个硬性边界，整个堆都会被耗光直到没有内存空间用来做转移。我们并不能拍胸脯说这种情况绝对不会发生，所以说这也是一个调优参数。这一原则可以确保在每次成功转移后，之前所有分配的Eden region都返回到<strong>空闲列表</strong>中，所有被转移的生存对象最终进入Survivor区。</p>
<p>下图是一个标准的young gc的示意图：</p>
<p><img src="https://www.redhat.com/cms/managed-files/heap-survivor-region.png"></p>
<p>我们继续上面的流程，新对象会再次被分配到Eden区。当Eden空间被填满时，又会触发一次young gc。根据现有存活对象的年龄(所谓年龄，就是对象撑过了多少次的young gc)，对象将会晋升到Old region。由于Survivor空间是年轻代的一部分，在年轻代gc（young pauses）期间，对象会被回收或者晋升。</p>
<p>下面是一个young gc的示例，Survivor区的存活对象被转移到一个新的Old region，而来自Eden区的存活对象被转移到新的Survivor区。而那些执行转移的region（删除线所示）会变成空的，并且重新回到空闲列表中。</p>
<p><img src="https://www.redhat.com/cms/managed-files/heap-old-region.png"></p>
<p>G1会按照这种方式持续执行，直到遇到如下三种事件中的任意一种：</p>
<ol>
<li>当G1触及到一个可配置的被称为<strong>InitiatingHeapOccupencyPercent</strong>（IHOP）的软边界。</li>
<li>当G1触及到一个可配置的硬边界：<strong>G1ReservePercent</strong></li>
<li>当G1触发了一次大对象分配（humongous allocation，这正是上文说的那个例外，下面会详细介绍）</li>
</ol>
<p>先讨论最常见的情形，IHOP事件代表young gc期间的某个时间点，此时Old region内的对象超过了整堆的45%（默认值）。该百分比作为young gc的一个组成部分，被不断地计算和评估。当三种情形中的任意一种被触发，就会发出请求启动<strong>并发标记周期</strong>（concurrent marking cycle）。</p>
<blockquote>
<p>译注：</p>
<ol>
<li>关于<strong>InitiatingHeapOccupencyPercent</strong>参数，在JDK-6976060之前，计算方式为：整堆的使用量 &#x2F; 整堆大小，而之后是：Old region（包括humongous region）的使用量 &#x2F; 整堆大小，具体详情可以参考 [R大的解答]([<a href="https://hllvm-group.iteye.com/group/topic/44381?page=3">HotSpot VM] 请教G1算法的原理讨论第3页: - 资料 - 高级语言虚拟机 - ITeye群组</a>)</li>
<li>这里所说的<strong>并发标记周期</strong>也叫做<strong>全局并发标记</strong>（global concurrent marking），指的是包括：初始标记、并发标记、最终标记、清理这几个阶段的统称，不要和其中的并发标记阶段混淆</li>
</ol>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">8801.974: [G1Ergonomics (Concurrent Cycles) request concurrent cycle initiation, reason: occupancy higher than threshold, occupancy: 12582912000 bytes, allocation request: 0 bytes, threshold: 12562779330 bytes (45.00 %), source: end of GC]</span><br><span class="line">8804.670: [G1Ergonomics (Concurrent Cycles) initiate concurrent cycle, reason: concurrent cycle initiation requested]</span><br><span class="line">8805.612: [GC concurrent-mark-start]</span><br><span class="line">8820.483: [GC concurrent-mark-end, 14.8711620 secs]</span><br></pre></td></tr></table></figure>

<p>G1的并发标记基于初始快照（snapshot-at-the-beginning, SATB）的原理。这意味着只有被快照“拍下”的存活对象才会参与是否为垃圾的识别，这当然是出于效率考虑。而并发标记期间任何新分配的对象都被认为是绝对存活的对象，不管它的实际存活状态如何。意识到这么一点非常重要：并发标记的时间越长，可收集对象和绝对存活对象的比值就会越大（译注：原文为：This is important because the longer it takes for concurrent marking to complete, the higher the ratio will be of what is collectible versus what is considered to be implicitly live.）。如果在并发标记期间分配的对象多于最终回收的对象，堆内存最终会被耗尽。在<strong>并发标记周期</strong>中，你会发现young gc会持续进行，因为在并发标记周期中，不是每个子阶段都会导致STW（stop-the-world）。</p>
<p>下图展示了当一次young gc结束后且达到IHOP 阈值时堆空间。</p>
<p><img src="https://www.redhat.com/cms/managed-files/heap-fillingup.png"></p>
<p>一旦并发标记周期完成，紧接着就是一次young gc，随后是第2种类型的转移，这被称为mixed gc。mixed gc和young gc的工作方式几乎相同，但是有两个主要区别。首先，mixed gc还会回收、转移并压缩被选定的Old region。其次，mixed gc的转移不同于young gc的转移。它的工作目标是尽可能快速、频繁的回收。这样做的目的是为了在软性暂停时间内最小化Eden &#x2F; Survivor区的数量，使得Old region的数量最大化。</p>
<blockquote>
<p>译注：</p>
<p>关于上面说的：最小化Eden &#x2F; Survivor区的数量，可以参考：[G1Policy::calculate_young_list_desired_min_length](<a href="https://github.com/openjdk/jdk17u/blob/master/src/hotspot/share/gc/g1/g1Policy.cpp#L183">jdk17u&#x2F;g1Policy.cpp at master · openjdk&#x2F;jdk17u (github.com)</a>)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8821.975: [G1Ergonomics (Mixed GCs) start mixed GCs, reason: candidate old regions available, candidate old regions: 553 regions, reclaimable: 6072062616 bytes (21.75 %), threshold: 5.00 %]</span><br></pre></td></tr></table></figure>

<p>上面的log日志展示了一次mixed gc，候选Old region的数量（553）含有21.75%的可回收空间，这个值高于<strong>G1HeapWastePercent</strong>所规定的5%的最小阈值（JDK8u40+默认为5%，JDK7默认为10%），正因如此mixed gc被触发。鉴于不能执行费时的操作，G1会恪守垃圾优先的策略：根据候选Old region存活对象占比，决定是否将其加入到有序的回收候选列表中。如果一个Old region内的存活对象小于<strong>G1MixedGCLiveThresholdPercent</strong> 所规定的百分比（JDK8u4+默认为85%，JDK7默认值为65%），该Old region就被加入到回收候选列表中。反而言之，如果一个Old region内存活对象的比率大于65%（JDK7）或85%（JDK8u40+），G1就不再浪费时间在这次mixed gc中对其进行回收和转移。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8822.178: [GC pause (mixed) 8822.178: [G1Ergonomics (CSet Construction) start choosing CSet, _pending_cards: 74448, predicted base time: 170.03 ms, remaining time: 829.97 ms, target pause time: 1000.00 ms]</span><br></pre></td></tr></table></figure>

<p>与young gc相比，mixed gc使用相同的暂停时间，而回收的region却横跨3个region（译注：Eden、Survivor、Old）。它是通过<strong>G1MixedGCCountTarget</strong> （默认值为8）实现对Old region的逐步（incremental ）回收的。具体来讲，它是将候选回收列表中Old region的数量除以<strong>G1MixedGCCountTarget</strong> （译注：假设商为<strong>X</strong>），然后在接下来的mixed gc循环中每次最少都要收集<strong>X</strong>个Old region。回收完毕后，如果可回收region仍然大于<strong>G1HeapWastePercent</strong>，mixed gc循环就会持续下去。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8822.704: [G1Ergonomics (Mixed GCs) continue mixed GCs, reason: candidate old regions available, candidate old regions: 444 regions, reclaimable: 4482864320 bytes (16.06 %), threshold: 10.00 %]</span><br></pre></td></tr></table></figure>

<p>下图展示了一次mixed gc。所有的Eden区都会被回收并转移到Survivor区。所有的Survivor区也会被回收，根据年龄的不同，足够老的存活对象会晋升到老年代。与此同时，也会选择一组Old region进行回收，这些region内的存活对象会被压缩并转移到新的Old region中。这种压缩和转移的过程可以显著减少内存碎片，同时保证空闲列表中有足够的空闲region。</p>
<p><img src="https://www.redhat.com/cms/managed-files/heap-mixed-cycle.png"></p>
<p>下图展示了当mixed gc结束后堆内存的状态。所有的Eden区域都被回收，存活对象被转移到新分配的Survivor区域。原来的Survivor也被回收，（满足条件的）存活对象晋升到Old region中。回收候选列表中的Old region会重新返回空闲列表，同时仍然存活的对象被压缩、转移到新的Old region。</p>
<p><img src="https://www.redhat.com/cms/managed-files/heap-mixed-cycle-after.png"></p>
<p>mixed gc会持续进行直到这个8次（译注：也即<strong>G1MixedGCCountTarget</strong> ）循环结束，或者可回收百分比小于<code>G1HeapWastePercent</code>。此时，mixed gc循环结束，接下来回归到标准的young gc中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8830.249: [G1Ergonomics (Mixed GCs) do not continue mixed GCs, reason: reclaimable percentage not over threshold, candidate old regions: 58 regions, reclaimable: 2789505896 bytes (9.98 %), threshold: 10.00 %]</span><br></pre></td></tr></table></figure>

<p>目前我们已经讨论了常见的场景。我们回过头来讨论前面提到的异常情况。这种异常就是当分配的对象大于region的50%。在这种情况下，这个对象就被认为是大对象（humongous），并且会执行专门的大对象分配（humongous allocations）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Region Size: 4096 KB</span><br><span class="line">Object A: 12800 KB</span><br><span class="line">Result: Humongous Allocation across 4 regions</span><br></pre></td></tr></table></figure>

<p>下图展示了一个<strong>12.5MB</strong>的大对象横跨4个连续region的情况</p>
<p><img src="https://www.redhat.com/cms/managed-files/heap-humongous.png"></p>
<ol>
<li>大对象仅仅是一个对象，因此需要被分配到连续的region中，这可能会导致严重的碎片化。</li>
<li>大对象被直接分配到老年代中特殊的大对象region（humongous region）中。这是因为如果分配到年轻代，那么转移和复制这个大对象的成本太高。</li>
<li>尽管上图中的对象只有<strong>12.5MB</strong>，他也必须使用4个完整的region，总容量为16MB</li>
<li>大对象分配总是会触发一次并发标记循环，不管是否达到IHOP的阈值</li>
</ol>
<p>少量的大对象分配可能不会引起什么问题，但是如果它们被持续地分配就会导致明显的碎片化，同时带来显著的性能影响。在JDK8u40之前，大对象仅在Full gc时才会被回收，对于JDK7和JDK8的早期版本来说，这个影响非常大。这就是为什么掌握应用程序中对象大小和G1的region大小是至关重要的。尽管如此，在最新的JDK8中（译注：本文写于2016年12月6日），如果你的应用程序需要分配大量的大对象，那么反复的评估和调优绝对是一件好事。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4948.653: [G1Ergonomics (Concurrent Cycles) request concurrent cycle initiation, reason: requested by GC cause, GC cause: G1 Humongous Allocation]</span><br><span class="line">7677.280: [G1Ergonomics (Concurrent Cycles) do not request concurrent cycle initiation, reason: still doing mixed collections, occupancy: 14050918400 bytes, allocation request: 16777232 bytes, threshold: 12562779330 32234.274: [G1Ergonomics (Concurrent Cycles) request concurrent cycle initiation, reason: occupancy higher than threshold, occupancy: 12566134784 bytes, allocation request: 9968136 bytes, threshold: 12562779330 bytes (45.00 %), source: concurrent humongous allocation]</span><br></pre></td></tr></table></figure>

<p>最后也是最不幸的是，G1也不得不执行可怕的Full GC。尽管G1会极力避免Full gc，但如果调优不当，那么Full gc就仍然是一个很残酷的现实。鉴于G1的目标是管理更大的堆内存，Full gc可能会对线上业务和SLA（译注：这是什么）造成灾难性的影响。一个最主要的原因就是G1的Full gc是单线程的。如果讨论Full gc的原因，第一个也最应该避免的原因就和元空间（Metaspace）有关。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Full GC (Metadata GC Threshold) 2065630K-&gt;2053217K(31574016K), 3.5927870 secs]</span><br></pre></td></tr></table></figure>

<p>一个最新消息是：当更新到JDK8u40+，类卸载就不再需要一次Full gc！仍然可能遇到和元空间有关的 Full gc，但这已经是UseCompressedOops及UseCompressedClassSpoInters或并发标记所需的时间有关了（我们将在以后的文章中讨论）。</p>
<p>接下来导致Full gc的两个原因很真实，而且往往是不可避免的。作为码农，我们的工作是尽最大努力优化和评估创建对象的代码，从而延后和避免这两种情况的发生。其中一个原因是“转移目标空间耗尽”（to-space exhausted），随之而来的是一次Full gc。这说明转移失败（evacuation failures）了，也即堆空间无法再扩展（译注：也就是达到Xmx的配置）且没有可用空间执行转移操作。如果您还记得的话，我们之前讨论过由<strong>G1ReservePercent</strong>定义的硬边界事件。这表示需要转移到to-space的空间超出了您的可用（reserve）空间，并且堆空间已经彻底满了，因此没有可用region执行转移操作。在某些情况下，如果JVM能够解决空间问题，那么后面就不会有Full gc，但这仍然是一个代价非常昂贵的STW事件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6229.578: [GC pause (young) (to-space exhausted), 0.0406140 secs]</span><br><span class="line">6229.691: [Full GC 10G-&gt;5813M(12G), 15.7221680 secs]</span><br></pre></td></tr></table></figure>

<p>如果你发现这种情形经常发生，你应该立刻意识到有很大的调优空间。另外一个原因就是并发标记期间的Full gc。在这种情况下，g1并没有转移失败，只是在并发标记完成并触发mixed gc之前用光了堆空间。这两个原因根源要么是内存泄漏，要么是对象分配和晋升的速度超过了g1的回收速度。如果 Full gc的占比很大，那么可以假设是因为对象分配和晋升有关。如果占比很小，并且最终遇到 OutOfMemoryError，那么就应该排查是否有内存泄漏。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">57929.136: [GC concurrent-mark-start]</span><br><span class="line">57955.723: [Full GC 10G-&gt;5109M(12G), 15.1175910 secs]</span><br><span class="line">57977.841: [GC concurrent-mark-abort]</span><br></pre></td></tr></table></figure>

<p>最后，我希望这篇文章能够帮助你了解G1的设计方式，以及它是如何做出垃圾回收决策的。我希望您继续关注本系列的下一篇文章，我们将深入挖掘各种JVM参数，以收集和解释通过GC日志产生的海量数据。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.gamedo.org/2021/05/20/Spring%20Boot%20Actuator%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="临江听雨">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="听雨">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 听雨">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/20/Spring%20Boot%20Actuator%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/" class="post-title-link" itemprop="url">Spring Boot Actuator官方参考文档（2.5.0）翻译（完结）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-05-20 20:00:00" itemprop="dateCreated datePublished" datetime="2021-05-20T20:00:00+08:00">2021-05-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-12 14:47:53" itemprop="dateModified" datetime="2025-08-12T14:47:53+08:00">2025-08-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E6%B2%89%E6%B7%80/" itemprop="url" rel="index"><span itemprop="name">技术沉淀</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p><strong>乔梁</strong>大神曾经在他的<a href="https://book.douban.com/subject/30419555/">《持续交付2.0》</a>一书的第5.1.1节：《持续交付架构要求》中明确指出：为了提升交付速度，获得持续交付能力，系统架构在设计时应该考虑如下因素。</p>
<p>（1）<strong>为测试而设计（design for test）</strong>。如果我们每次写好代码以后，需要花费很大的精力，做很多的准备工作才能对它进行测试的话，那么从写好代码到完成质量验证就需要很长周期，当然无法快速发布。</p>
<p>（2）<strong>为部署而设计（design for development）</strong>。如果我们开发完新功能，当部署发布是，需要花费很长时间准备，甚至需要停机才能部署，当然就无法快速发布。</p>
<p>（3）<strong>为监控而设计（design for monitor）</strong>。如果我们的功能上线以后，无法对齐进行监控，除了问题只能通过用户反馈才发现。那么，持续交付的收益就会大幅降低了。</p>
<p>（4）<strong>为扩展而设计（design for scale）</strong>。这里的扩展性指两个方面，意识支持团队成员规模的扩展，而是支持系统自身的扩展。</p>
<p>（5）<strong>为失效而设计（design for failure）</strong>。俗话说：“常在河边走，哪能不湿鞋。”快速地部署发布总会遇到问题。因此，在开发软件功能之前，就应该考虑的一个问题是：一旦部署或发布失败，如何优雅且快速地处理。</p>
<p>在这5个设计原则中，为<strong>为监控而设计（design for monitor）</strong>属于游戏（服务器）开发中最容易被轻视甚至是忽视的原则之一，而在<a href="https://github.com/pcloves/gamedo.core">gamedo.core</a>的开发设计过程中，译者本人也一直在思考如何实现系统监控的最佳实践，直到最近算是确定了技术栈，那就是站在巨人的肩上，使用<a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator">Spring Boot Actuator</a>和<a href="https://micrometer.io/docs">MicroMeter</a>。</p>
<p>正是由于<a href="https://github.com/pcloves/gamedo.core">gamedo.core</a>最终要选用Spring Boot Actuator作为系统监控的关键技术，因此需要其进行相对深入的研究，这也是本笔记的产生的原因。而本文的所有内容都源于阅读<a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator">参考文档</a>（Spring Boot版本：2.5.0）以及阅读源码时的随读、随想和随写，为了便于以后查找，章节也完全和参考文档保持一致，并且由于某些章节比较简单，所以就被忽略掉，这可能导致本文的章节不是连续的。</p>
<h1 id="启用产品就绪特性（Enabling-Production-ready-Features）"><a href="#启用产品就绪特性（Enabling-Production-ready-Features）" class="headerlink" title="启用产品就绪特性（Enabling Production-ready Features）"></a>启用产品就绪特性（Enabling Production-ready Features）</h1><p>Spring Boot的所有产品就绪特性是都是由 <a href="https://github.com/spring-projects/spring-boot/tree/v2.4.6/spring-boot-project/spring-boot-actuator"><code>spring-boot-actuator</code></a>模块提供的，开启该特性的最佳方式就是引入专有的<code>Starter</code>，也即：<code>spring-boot-starter-actuator</code></p>
<blockquote>
<center><b>执行器的定义</b></center>

<p><a href="https://www.termonline.cn/search?k=actuator">执行器</a>（actuator）是一个制造业术语，是指用于移动或控制某些物体的机械设备。可以通过执行器的微小变化带来巨大的变化。</p>
</blockquote>
<p>对于使用Maven构建的项目，可以添加如下<code>Starter</code>依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>对于使用Gradle的项目，使用如下配置：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-actuator&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="端点（Endpoints）"><a href="#端点（Endpoints）" class="headerlink" title="端点（Endpoints）"></a>端点（Endpoints）</h1><p>通过端点可以监控应用程序，和应用程序交互。Spring Boot内置了一堆端点，用户也可以自行添加。比如<code>health</code>端点，它可以提供应用的基本健康信息。</p>
<p>每一个端点都可以被<a href="##%E5%BC%80%E5%90%AF%E7%AB%AF%E7%82%B9%EF%BC%88Enabling-Endpoints%EF%BC%89">开启、禁用</a>，也可以<a href="##%E6%9A%B4%E9%9C%B2%E7%AB%AF%E7%82%B9%EF%BC%88Exposing-Endpoints%EF%BC%89">通过HTTP或JMX的方式暴露</a>给外部。当端点同时开启且被暴露时，它才是可用的。内置的端点也只有在可用状态下才会被Spring Boot自动装配。大多数应用都选择HTTP的方式。端点的ID以及固定前缀<code>/actuator</code>组合成访问该端点的URL。例如对于<code>health</code>端点，其访问方式为：<code>/actuator/health</code> </p>
<p> <a href="https://github.com/spring-projects/spring-boot/tree/v2.4.6/spring-boot-project/spring-boot-actuator"><code>spring-boot-actuator</code></a>内置了一大堆开箱即用的端点，详情参考源文档。此外，当应用程序是一个Web应用（Spring MVC、Spring WebFlux或者Jersey），如下内置的额外端点：</p>
<table>
<thead>
<tr>
<th align="center">端点ID</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>heapdump</code></td>
<td align="center">返回一个<code>hprof</code>堆转储文件，需要HotSpot虚拟机支持</td>
</tr>
<tr>
<td align="center"><code>jolokia</code></td>
<td align="center">通过HTTP暴露JMX bean（需要Jolokia在classpath内，且不适用于WebFlux），需要增加<code>jolokia-core</code>依赖</td>
</tr>
<tr>
<td align="center"><code>logfile</code></td>
<td align="center">返回日志文件的内容（如果logging.file.name或logging.file.path属性被设置），并且支持使用HTTP <code>Range</code>头检索部分日志文件的内容</td>
</tr>
<tr>
<td align="center"><code>prometheus</code></td>
<td align="center">将metrics暴露成可以被Prometheus服务器抓取的格式，需要添加<code>micrometer-registry-prometheus</code>依赖</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>译者提示</strong></p>
<ul>
<li>对于任意端点来说，可以对其进行两种操作：1、开启或关闭端点；2、通过HTTP或者JMX暴露（exposed）它。当某个端点被开启且被暴露时该端点才处于可用状态。而系统内置端点只有在可用时才会被自动装配。</li>
<li>产品就绪特性属于Spring Boot的六大特性之一，详情可以参考<a href="https://spring.io/projects/spring-boot">官方文档Features</a>一节</li>
<li>自动装配属于Spring Boot的六大特性之一，简单来说，自动装配就是：如果检测到用户需要某个组件（例如发现引入了某个组件类库），并且用户还没有进行配置，那就启用内部自动装配逻辑，帮用户配置好。例如，如果用户引入了<code>spring-boot-starter-logging</code>，接下来不需要进行一大堆的日志配置，直接记录日志。这个术语会在本文档中多次提及。</li>
<li>端点（Endpoints）和指标（metrics）是本文最重要的两个概念，占据了本文的大部分篇幅。端点的概念不难理解，属于Spring Boot Actuator的核心功能，从系统内部代码层面讲，就是一个个内置的自动装配的以及用户自定义的端点 bean，从外部用户角度讲，就是一个个可以访问的数据集合窗口（可以通过jmx或http）。而指标有时候指的就是众多端点中的<code>metrics</code>端点，有时候指的是<code>metrics</code>端点下的被Spring Boot使用micrometer采集到的指标。理解了这些，实际上就理解整篇文章的精髓。</li>
</ul>
</blockquote>
<h2 id="开启端点（Enabling-Endpoints）"><a href="#开启端点（Enabling-Endpoints）" class="headerlink" title="开启端点（Enabling Endpoints）"></a>开启端点（Enabling Endpoints）</h2><p>默认情况下，除了<code>shutdown</code>端点，其他所有端点默认处于<strong>开启状态</strong>。如果要开关某个端点，可以配置：<code>management.endpoint.&lt;端点id&gt;.enabled</code>，例如开启<code>shutdown</code>端点的配置为：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">shutdown:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>如果希望所有端点默认都是关闭状态，可以将<code>management.endpoints.enabled-by-default</code>配置为<code>false</code>，然后将某端点的<code>enabled</code>属性配置为<code>true</code>来单独开启。以<code>info</code>端点举例（只开启<code>info</code>端点，其他端点都关闭）：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">enabled-by-default:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">info:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>提示</strong></p>
<p>当某个端点被关闭后，对应的端点bean会从Spring容器（application context）中移除。如果仅仅是不想让某个端点被暴露，可以使用<a href="#%E6%9A%B4%E9%9C%B2%E7%AB%AF%E7%82%B9%EF%BC%88Exposing-Endpoints%EF%BC%89">include和exclude</a>属性。</p>
</blockquote>
<h2 id="暴露端点（Exposing-Endpoints）"><a href="#暴露端点（Exposing-Endpoints）" class="headerlink" title="暴露端点（Exposing Endpoints）"></a>暴露端点（Exposing Endpoints）</h2><p>因为端点可能会包含敏感信息，因此在决定暴露端点前需要仔细考虑。下表展示了内置端点的默认暴露状态（简而言之：JMX下默认全开，HTTP下只有<code>health</code>开启）：</p>
<table>
<thead>
<tr>
<th align="left">ID</th>
<th align="left">JMX</th>
<th align="left">Web</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>auditevents</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>beans</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>caches</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>conditions</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>configprops</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>env</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>flyway</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>health</code></td>
<td align="left">Yes</td>
<td align="left">Yes</td>
</tr>
<tr>
<td align="left"><code>heapdump</code></td>
<td align="left">N&#x2F;A</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>httptrace</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>info</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>integrationgraph</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>jolokia</code></td>
<td align="left">N&#x2F;A</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>logfile</code></td>
<td align="left">N&#x2F;A</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>loggers</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>liquibase</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>metrics</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>mappings</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>prometheus</code></td>
<td align="left">N&#x2F;A</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>quartz</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>scheduledtasks</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>sessions</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>shutdown</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>startup</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>threaddump</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
</tbody></table>
<p>如果想调整某个端点的暴露状态，可以使用如下<code>include</code>和<code>exclude</code>属性：</p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>management.endpoints.jmx.exposure.exclude</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>management.endpoints.jmx.exposure.include</code></td>
<td align="center">*</td>
</tr>
<tr>
<td align="center"><code>management.endpoints.web.exposure.exclude</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>management.endpoints.web.exposure.include</code></td>
<td align="center"><code>health</code></td>
</tr>
</tbody></table>
<p><code>include</code>属性列出的是需要开启暴露的端点的id集合，而<code>exclude</code>属性列出的是关闭暴露的端点的id集合。<code>exclude</code>的优先级<strong>高于</strong><code>include</code>，且这两个属性都可以配置为一个以端点ID列表。</p>
<p>例如，如果只想通过JMX暴露<code>health</code>和<code>info</code>端点，而禁止暴露其他端点，可以使用如下配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">jmx:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;health,info&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>*</code>代表所有端点。例如，如果想通过HTTP的方式暴露除了<code>env</code>和<code>beans</code>之外的所有端点，可以使用如下配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">        <span class="attr">exclude:</span> <span class="string">&quot;env,beans&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>提示</strong></p>
<ul>
<li><code>*</code>在YAML中具有特殊含义，因此在<code>include</code>和<code>exclude</code>中使用时需要添加双引号</li>
<li>如果应用程序暴露在外网环境中，强烈建议<a href="#%E5%8A%A0%E5%9B%BAHTTP%E7%AB%AF%E7%82%B9%EF%BC%88Securing-HTTP-Endpoints%EF%BC%89">加固HTTP端点</a></li>
<li>如果想自定义端点的暴露策略，可以注册一个<code>EndpointFilter</code> bean</li>
</ul>
</blockquote>
<h2 id="加固HTTP端点（Securing-HTTP-Endpoints）"><a href="#加固HTTP端点（Securing-HTTP-Endpoints）" class="headerlink" title="加固HTTP端点（Securing HTTP Endpoints）"></a>加固HTTP端点（Securing HTTP Endpoints）</h2><p>信息敏感的URL需要进行安全加固，而对于HTTP方式的端点也应该得到相同待遇的处理。如果使用了<a href="https://spring.io/projects/spring-security">Spring Security</a>，端点默认会被<code>Spring Security</code>的内容协商策略（content-negotiation strategy）加固，例如只允许具有某种角色（role）的用户访问。Spring Boot提供了一些方便使用的<code>RequestMatcher</code>对象，可以配合<code>Spring Security</code>使用。</p>
<p>典型的<code>Spring Security</code>配置如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySecurityConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">securityFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http.requestMatcher(EndpointRequest.toAnyEndpoint())</span><br><span class="line">                .authorizeRequests((requests) -&gt; requests.anyRequest().hasRole(<span class="string">&quot;ENDPOINT_ADMIN&quot;</span>));</span><br><span class="line">        http.httpBasic();</span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子中，<code>EndpointRequest.toAnyEndpoint()</code>用来匹配任意端点，然后还会确保用户拥有<code>ENDPOINT_ADMIN</code>角色。<code>EndpointRequest</code>中还有其他类似的匹配函数。可以查看API文档（<a href="https://docs.spring.io/spring-boot/docs/2.5.0/actuator-api/htmlsingle">HTML</a>或<a href="https://docs.spring.io/spring-boot/docs/2.5.0/actuator-api/pdf/spring-boot-actuator-web-api.pdf">PDF</a>）获得更多详情。</p>
<p>如果应用程序部署在防火墙后面，可以允许所有端点被访问而无需进行鉴权。此时可以将<code>management.endpoints.web.exposure.include</code>配置为**<code>*</code>**，如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure>

<p>此外，如果使用了<code>Spring Security</code>，并且想允许未经过身份验证的访问，还需要一些自定义配置，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySecurityConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">securityFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http.requestMatcher(EndpointRequest.toAnyEndpoint())</span><br><span class="line">                .authorizeRequests((requests) -&gt; requests.anyRequest().permitAll());</span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>提示</strong></p>
<p>以上两个例子中的配置仅对端点请求生效。而对于<code>Spring Boot</code>来说，当存在用户自定义的<code>SecurityFilterChain</code> bean时，其安全配置就会自动失效。因此需要配置额外的<code>SecurityFilterChain</code>来适配应用程序的其他请求</p>
</blockquote>
<h2 id="配置端点（Configuring-Endpoints）"><a href="#配置端点（Configuring-Endpoints）" class="headerlink" title="配置端点（Configuring Endpoints）"></a>配置端点（Configuring Endpoints）</h2><p>对于端点中不包含参数的读操作（read operations）请求，端点会自动缓存响应数据（response），如果要修改某端点的缓存时间，可以配置<code>cache.time-to-live</code> 属性，如下配置就是将<code>beans</code>端点的缓存时间改成10秒：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">beans:</span></span><br><span class="line">      <span class="attr">cache:</span></span><br><span class="line">        <span class="attr">time-to-live:</span> <span class="string">&quot;10s&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>提示</strong></p>
<p><code>management.endpoint.&lt;name&gt;</code>前缀用于标识要配置的端点</p>
</blockquote>
<h2 id="Hypermedia-for-Actuator-Web-Endpoints"><a href="#Hypermedia-for-Actuator-Web-Endpoints" class="headerlink" title="Hypermedia for Actuator Web Endpoints"></a>Hypermedia for Actuator Web Endpoints</h2><h2 id="跨域资源共享支持（CORS-Support）"><a href="#跨域资源共享支持（CORS-Support）" class="headerlink" title="跨域资源共享支持（CORS Support）"></a>跨域资源共享支持（CORS Support）</h2><p><a href="https://en.wikipedia.org/wiki/Cross-origin_resource_sharing">跨域资源共享</a>（CORS）是一个<a href="https://www.w3.org/TR/cors/">W3C规范</a>，可以协助制定灵活的跨域访问授权策略。如果你在使用Spring MVC或者Spring WebFlux，Web端点可以支持支持中场景。</p>
<p>CORS默认是被关闭的，并且只有<code>management.endpoints.web.cors.allowed-origins</code>被配置后才会开启，下面配置允许来自于<code>example.com</code>的<code>GET</code>和<code>POST</code>请求：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">cors:</span></span><br><span class="line">        <span class="attr">allowed-origins:</span> <span class="string">&quot;https://example.com&quot;</span></span><br><span class="line">        <span class="attr">allowed-methods:</span> <span class="string">&quot;GET,POST&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>提示</strong></p>
<p>到 <a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/endpoint/web/CorsEndpointProperties.java">CorsEndpointProperties</a>查看完整的属性列表</p>
</blockquote>
<h2 id="实现自定义端点（Implementing-Custom-Endpoints）"><a href="#实现自定义端点（Implementing-Custom-Endpoints）" class="headerlink" title="实现自定义端点（Implementing Custom Endpoints）"></a>实现自定义端点（Implementing Custom Endpoints）</h2><p>如果一个<code>@Bean</code>被<code>@Endpoint</code>注解，那么任意被注解了<code>@ReadOperation</code>、<code>@WriteOperation</code>或者<code>@DeleteOperation</code>的方法都以JMX方式暴露，而对于Web应用程序，则会以HTTP的方式暴露。当使用Jersey、Spring MVC或者Spring WebFlux时，端点可以通过HTTP暴露。当Jersey和Spring MVC都可用时，Spring MVC优先被使用。</p>
<p>以下例子暴露一个读操作（read operation），该操作返回了一个自定义对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ReadOperation</span></span><br><span class="line"><span class="keyword">public</span> CustomData <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomData</span>(<span class="string">&quot;test&quot;</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用<code>@JmxEndpoint</code>或<code>@WebEndpoint</code>注解来开启特定方式的端点（JMX或者Web）。</p>
<p>可以使用<code>@EndpointWebExtension</code>或<code>@EndpointJmxExtension</code>，这两个注解可以对特定方式的端点进行增强（JMX或者Web）</p>
<blockquote>
<p><strong>笔者提示</strong></p>
<p>对于注解了<code>@Endpoint</code>的<code>@Bean</code>，由于既可以通过JMX方式暴露，又可以通过HTTP的方式暴露（后文称这种端点为<strong>原生端点</strong>）。为了兼容性的需要，不得不放弃某些技术特性。因此Spring设计了<code>@EndpointWebExtension</code>或<code>@EndpointJmxExtension</code>（从Spring Boot 2.2.0开始，还增加了<code>@EndpointCloudFoundryExtension</code>注解），这些注解的作用对原生端点进行技术特级别的扩展。例如对于以HTTP方式暴露的某个端点，可以为响应数据（Response）增加一个状态码（而JMX方式就不需要这个状态码），那么就可以使用<code>@EndpointWebExtension</code>对原生端点进行二次加工，示例可以参考源码中<a href="https://github.com/spring-projects/spring-boot/blob/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/env/EnvironmentEndpointWebExtension.java"><code>EnvironmentEndpointWebExtension</code></a>的实现</p>
</blockquote>
<p>最后，如果需要使用web框架相关的功能，可以实现<code>Servlet</code>或者使用Spring <code>@Controller</code>、<code>@RestController</code>端点，不过代价是通过JMX方式暴露就不可用，并且当使用其他web框架时也不可用。</p>
<h3 id="入参处理（Receiving-Input）"><a href="#入参处理（Receiving-Input）" class="headerlink" title="入参处理（Receiving Input）"></a>入参处理（Receiving Input）</h3><p>通过参数的方式，端点的操作（Operations）来接收输入。当通过web暴露时，这些参数来自于请求的查询参数或者请求body中的JSON对象。当通过JMX暴露时，这些参数从<a href="https://docs.oracle.com/javase/tutorial/jmx/mbeans/index.html">MBean</a>映射而来。默认情况下，参数是必须输入的。不过可以通过添加注解<code>@javax.annotation.Nullable</code>或<code>@org.springframework.lang.Nullable</code>使之成为可选参数。</p>
<p>对于web请求body中JSON对象，每个属性值都可以被映射为端点的一个参数，例如请求body中的json结构为：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;test&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;counter&quot;</span><span class="punctuation">:</span> <span class="number">42</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>那么可以开发这么一个包含<code>String name</code>和<code>int counter</code>参数的端点与之对应，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WriteOperation</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateData</span><span class="params">(String name, <span class="type">int</span> counter)</span> &#123;</span><br><span class="line">    <span class="comment">// injects &quot;test&quot; and 42</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>提示</strong></p>
<ul>
<li>由于原生端点的兼容性需要，因此端点的入参只能是基本类型，因此不支持将<code>name</code>和<code>counter</code>封装到<code>CustomData</code>。</li>
<li>如果想要将输入参数映射到函数的参数上，当编译Java代码时，需要使用<code>-parameters</code>参数，而对于Kotlin代码，则需要使用<code>-java-parameters</code>，如果在Gradle中使用了Spring Boot的插件或者在Maven中使用了<code>spring-boot-starter-parent</code>这个参数已经被自动开启。（关于<code>-parameters</code>的更多细节，可以参考<a href="https://stackoverflow.com/questions/31845676/how-to-compile-spring-boot-applications-with-java-8-parameter-flag">StackOverflow</a>的这个解答）</li>
</ul>
</blockquote>
<h4 id="输入类型转换"><a href="#输入类型转换" class="headerlink" title="输入类型转换"></a>输入类型转换</h4><p>在必要的情况下，传给端点的参数会被自动转换为端点的参数类型。在调用端点的操作函数（operation method）之前，通过JMX或HTTP请求的参数通过<code>ApplicationConversionService</code>对象和任意被<code>@EndpointConverter</code>注解标识的<code>Converter</code>或<code>GenericConverter</code>转换。</p>
<h3 id="自定义Web端点（Custom-Web-Endpoints）"><a href="#自定义Web端点（Custom-Web-Endpoints）" class="headerlink" title="自定义Web端点（Custom Web Endpoints）"></a>自定义Web端点（Custom Web Endpoints）</h3><p>被<code>@Endpoint</code>、<code>@WebEndpoint</code>或<code>@EndpointWebExtension</code>注解的端点会自动通过Jersey、Spring MVC或Spring WebFlux以HTTP的方式暴露。而如果Jersey和Spring MVC都可用，那么Spring MVC会被启用。</p>
<h4 id="Web端点请求谓词（Web-Endpoint-Request-Predicates）"><a href="#Web端点请求谓词（Web-Endpoint-Request-Predicates）" class="headerlink" title="Web端点请求谓词（Web Endpoint Request Predicates）"></a>Web端点请求谓词（Web Endpoint Request Predicates）</h4><p>对于每个HTTP端点的任意操作（operation），都会自动生成一个HTTP请求谓词</p>
<h4 id="路径（Path）"><a href="#路径（Path）" class="headerlink" title="路径（Path）"></a>路径（Path）</h4><p>请求谓词的路径取决于端点的ID和根路径（指的是以web方式暴露的根路径），默认的根路径是<code>/actuator</code>。例如，<code>sessions</code>端点的谓词路径就是<code>/actuator/sessions</code></p>
<p>可以通过在端点的函数入参上增加<code>@Selector</code>注解实现路径的自定义解析。这些解析后的请求参数会被以路径变量的方式加入到请求谓词中。当端点的函数被调用时，这些路径变量会被当做入参传入。如果想捕获完整路径上所有剩余元素（每个被“&#x2F;”分割的字符串都是一个元素），可以在最后一个函数入参上使用<code>@Selector(Match=ALL_REMAINING)</code>注解，这会把所有的元素转换为<code>String[]</code>数组。</p>
<h4 id="HTTP方法（HTTP-method）"><a href="#HTTP方法（HTTP-method）" class="headerlink" title="HTTP方法（HTTP method）"></a>HTTP方法（HTTP method）</h4><p>请求谓词中的HTTP方法取决于操作类型，如下表所示：</p>
<table>
<thead>
<tr>
<th align="center">操作类型</th>
<th align="center">HTTP方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>@ReadOperation</code></td>
<td align="center"><code>GET</code></td>
</tr>
<tr>
<td align="center"><code>@WriteOperation</code></td>
<td align="center"><code>POST</code></td>
</tr>
<tr>
<td align="center"><code>@DeleteOperation</code></td>
<td align="center"><code>DELETE</code></td>
</tr>
</tbody></table>
<h4 id="请求媒体类型（Consumes）"><a href="#请求媒体类型（Consumes）" class="headerlink" title="请求媒体类型（Consumes）"></a>请求媒体类型（Consumes）</h4><p>对于HTTP POST方式的<code>@WriteOperation</code>，其请求（Request）的媒体类型（Content-Type）为<code>application/vnd.spring-boot.actuator.v2+json, application/json</code>，而其他操作类型则为空。</p>
<h4 id="响应媒体类型（Produces）"><a href="#响应媒体类型（Produces）" class="headerlink" title="响应媒体类型（Produces）"></a>响应媒体类型（Produces）</h4><p>响应（Response）的媒体类型由<code>@DeleteOperation</code>、<code>@ReadOperation</code>和<code>@WriteOperation</code>注解内的<code>produces</code>属性决定。这个属性是可选的，如果没有配置，那么媒体类型会被自动设置。</p>
<p>如果操作函数的返回值是<code>void</code>或者<code>Void</code>，那么媒体类型为空。如果返回一个<code>org.springframework.core.io.Resource</code>，那么媒体类型类型为<code>application/octet-stream</code>（也即二进制流数据）。而其他的所有的操作，媒体类型都是<code>application/vnd.spring-boot.actuator.v2+json, application/json</code>。</p>
<h4 id="Web端点的响应状态码（Web-Endpoint-Response-Status）"><a href="#Web端点的响应状态码（Web-Endpoint-Response-Status）" class="headerlink" title="Web端点的响应状态码（Web Endpoint Response Status）"></a>Web端点的响应状态码（Web Endpoint Response Status）</h4><p>默认的响应状态码取决于操作类型（<code>@DeleteOperation</code>、<code>@ReadOperation</code>和<code>@WriteOperation</code>）和返回值（如果有返回值的话）。</p>
<ul>
<li><p>如果一个<code>@ReadOperation</code>返回了一个值，那么状态码是200（OK）。否则的话，状态码是404（Not Found）。</p>
</li>
<li><p>如果一个<code>@WriteOpertion</code>或<code>@DeleteOperation</code>返回了一个值，那么状态码是200（OK）。否则的话，状态码是204（No Cpmtemt）。</p>
</li>
<li><p>如果一个操作被调用了而没有传入必须的参数，或者说参数没有被正确转换，那么操作函数将不会被调用，返回一个400（Bad Request）状态码</p>
</li>
</ul>
<h4 id="Web端点范围请求（Web-Endpoint-Range-Requests）"><a href="#Web端点范围请求（Web-Endpoint-Range-Requests）" class="headerlink" title="Web端点范围请求（Web Endpoint Range Requests）"></a>Web端点范围请求（Web Endpoint Range Requests）</h4><p>可以使用HTTP范围请求来获取HTTP资源。当使用Spring MVC或Spring WebFlux时，如果某个操作返回了<code>org.springframework.core.io.Resource</code>，那么范围请求会被自动支持。</p>
<blockquote>
<p><strong>提示</strong></p>
<p>Jersey不支持范围请求</p>
</blockquote>
<h4 id="Web端点安全（Web-Endpoint-Security）"><a href="#Web端点安全（Web-Endpoint-Security）" class="headerlink" title="Web端点安全（Web Endpoint Security）"></a>Web端点安全（Web Endpoint Security）</h4><p>对于web方式的端点或者web相关的端点扩展（web-specific endpoint extension），它们都可以接收<code>java.security.Principal</code>或 <code>org.springframework.boot.actuate.endpoint.SecurityContext</code>作为操作函数的参数。前者通常配合<code>@Nullable</code>使用，为经过身份验证和未经过身份验证的用户提供不同的行为。而后者通常使用<code>isUserInRole(Sring)</code>进行权限检查</p>
<h3 id="Servlet端点（Servlet-Endpoints）"><a href="#Servlet端点（Servlet-Endpoints）" class="headerlink" title="Servlet端点（Servlet Endpoints）"></a>Servlet端点（Servlet Endpoints）</h3><p>当同时满足如下两个条件后，就可以实现一个Servlet端点：</p>
<ul>
<li>实现一个<code>Supplier&lt;EndpointServlet&gt;</code>类</li>
<li>同时该类上增加<code>@ServletEndpoint</code>注解</li>
</ul>
<p>Servlet端点可以和Servlet容器更深层地集成，但是牺牲了可移植性。这种方式的应用场景就是可以将已有的Servlet转化为端点。而对于新的端点，仍然尽量使用<code>@Endpoint</code>或<code>@WebEndpoint</code></p>
<h4 id="Controller端点（Controller-Endpoints）"><a href="#Controller端点（Controller-Endpoints）" class="headerlink" title="Controller端点（Controller Endpoints）"></a>Controller端点（Controller Endpoints）</h4><p><code>@ControllerEndpoint</code>和<code>@RestControllerEndpoint</code>端点只可以在Spring MVC和Spring WebFlux下使用。当使用Spring MVC或Spring WebFlux的标准注解，例如<code>@RequestMapping</code> 和<code>@GetMapping</code>时，端点的操作方法都可以被正常映射，并且以端点的ID作为请求路径（path）的前缀。Controller端点提供了和Srping web框架更深的集成度，然而牺牲了可移植性。因此，尽量优先使用<code>@Endpoint</code>或<code>@WebEndpoint</code>端点。</p>
<h2 id="健康信息（Health-Information）"><a href="#健康信息（Health-Information）" class="headerlink" title="健康信息（Health Information）"></a>健康信息（Health Information）</h2><p>可以通过健康信息检查应用程序的运行状态。健康信息通常被用来监控应用，并且在系统宕机时进行报警。<code>health</code>端点暴露的信息详情取决于<code>management.endpoint.health.show-details</code> 和<code>management.endpoint.health.show-components</code>属性的配置，可以配置的值如下所示：</p>
<table>
<thead>
<tr>
<th align="center">配置值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>never</code>（默认值）</td>
<td align="center">详情不可见</td>
</tr>
<tr>
<td align="center"><code>when-authorized</code></td>
<td align="center">详情仅对授权用户可见。授权用户可以通过<code>management.endpoint.health.roles</code>配置</td>
</tr>
<tr>
<td align="center"><code>always</code></td>
<td align="center">详情对所有用户可见</td>
</tr>
</tbody></table>
<p>当一个用户拥有一个或多个端点角色（endpoint’s roles）时，他被认为是授权的。如果某个端点没有配置角色（这是默认状态），那么所有通过身份认证的用户都任务是被授权的。可以通过<code>management.endpoint.health.roles</code>配置角色。</p>
<blockquote>
<p><strong>提示</strong></p>
<p>如果已经对应用程序进行安全控制（ secured your application），而想使用<code>always</code>配置，那么需要对安全配置进行设置，是的所有经过身份认证和未经过身份认证的用户都获得访问权限</p>
</blockquote>
<p>健康信息是 <a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/HealthContributorRegistry.java"><code>HealthContributorRegistry</code></a>中收集所有健康数据的集合。默认情况下，这些健康数据是Spring上下文（<code>ApplicationContext</code>）中一个个<a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/HealthContributor.java"><code>HealthContributor</code></a>实例，Spring Boot已经自动装配了很多<code>HealthContributors</code>，用户也可以自己实现。</p>
<p><code>HealthContributor</code>既可以是一个<code>HealthIndicator</code> 也可以是一个<code>CompositeHealthContributor</code>，前者提供了实际的健康数据，并包含一个<code>Status</code>，后者提供了和其他<code>HealthIndicator</code>组合的能力。最终，所有这些<code>HealthContributor</code>形成了一个树状结构，来展示整个系统的健康状态。</p>
<p>默认情况下，系统的最终健康状态由<code>Statusaggregator</code>计算获得。<code>Statusaggregator</code>的实现类<code>SimpleStatusAggregator</code>的实现算法：</p>
<ul>
<li>内部维护了一个健康状态的有序列表，排序为：<code>DOWN</code>、<code>OUT_OF_SERVICE</code>、<code>UP</code>、<code>UNKNOWN</code></li>
<li>对于外部传入的状态集合，首先过滤掉不识别的状态码（也即只保留这4个状态码）</li>
<li>算出每个状态在有序列表中的索引，并取出索引值最小的状态，作为最终状态（实际上就是跟进有序列表的顺序进行排序）</li>
<li>如果剩下的集合是空的，那么返还一个<code>UNKNOWN</code>状态（这种情形只发生所有传入的状态都不属于这4种状态的情况下）</li>
</ul>
<blockquote>
<p><strong>提示</strong></p>
<p><code>HealthContributorRegistry</code>可以在运行状态下动态注册和反注册</p>
</blockquote>
<h3 id="自动装配的HealthIndicators（Auto-configured-HealthIndicators）"><a href="#自动装配的HealthIndicators（Auto-configured-HealthIndicators）" class="headerlink" title="自动装配的HealthIndicators（Auto-configured HealthIndicators）"></a>自动装配的HealthIndicators（Auto-configured HealthIndicators）</h3><p>Spring Boot已经自动装配了很多<code>HealthIndicator</code>，可以通过<code>management.health.&lt;key&gt;.enabled</code>将其开启或关闭</p>
<blockquote>
<p><strong>提示</strong></p>
<ul>
<li>详细的<code>HealthIndicator</code>列表不再赘述，详情参考<a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.endpoints.health.auto-configured-health-indicators">源文档</a></li>
<li>可以通过设置<code>management.health.defaults.enabled</code>关闭所有的<code>HealthIndicator</code></li>
</ul>
</blockquote>
<p>以下<code>HealthIndicator</code>也是可用的，但是默认情况下没有被启用：</p>
<table>
<thead>
<tr>
<th align="center">Key</th>
<th align="center">名字</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>livenessstate</code></td>
<td align="center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/availability/LivenessStateHealthIndicator.java"><code>LivenessStateHealthIndicator</code></a></td>
<td align="center">暴露应用程序的<code>活性</code>状态</td>
</tr>
<tr>
<td align="center"><code>readinessstate</code></td>
<td align="center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/availability/ReadinessStateHealthIndicator.java"><code>ReadinessStateHealthIndicator</code></a></td>
<td align="center">暴露应用程序的<code>就绪</code>状态</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>笔者提示</strong></p>
<ul>
<li>关于<code>活性</code>状态，Spring Boot在<a href="https://github.com/spring-projects/spring-boot/blob/v2.5.0/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/availability/LivenessState.java">源码</a>中有详细的解释：当应用程序的内部状态是正确的（CORRECT），那么它被认为是存活的。而<code>失活</code>状态意味着应用程序内部状态已经出现严重异常（BROKEN）而且无法正常恢复，只能通过重启应用解决该异常。相应地，活性状态有两个状态，分别为：<code>CORRECT</code>和<code>BROKEN</code>。</li>
<li>关于<code>就绪</code>状态，Spring Boot在<a href="https://github.com/spring-projects/spring-boot/blob/v2.5.0/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/availability/ReadinessState.java">源码</a>中也有详细的解释：当应用程序处于存活（也即活性状态为CORRECT）状态且可以接受流量时，被认为是就绪的（ACCEPTING_TRAFFIC）。而当应用程序无法接受流量时意味着就绪失败（REFUSING_TRAFFIC），基础设施必须停止对其路由。相应地，就行状态也包含两种：<code>ACCEPTING_TRAFFIC</code>和<code>REFUSING_TRAFFIC</code>（也就是说就绪状态更倾向于一个web术语）</li>
</ul>
</blockquote>
<h3 id="自定义HealthIndicators（Writing-Custom-HealthIndicators）"><a href="#自定义HealthIndicators（Writing-Custom-HealthIndicators）" class="headerlink" title="自定义HealthIndicators（Writing Custom HealthIndicators）"></a>自定义HealthIndicators（Writing Custom HealthIndicators）</h3><p>可以通过注册 <a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/HealthIndicator.java"><code>HealthIndicator</code></a> 接口的Bean实现自定义的监控数据。该接口类需要实现<code>health()</code>方法并且返回一个<code>Health</code>类。该返回值必须包含一个状态，并且可选择性地包含详细信息以供显示。以下代码展示了一个<code>HealthIndicator</code>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyHealthIndicator</span> <span class="keyword">implements</span> <span class="title class_">HealthIndicator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Health <span class="title function_">health</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">errorCode</span> <span class="operator">=</span> check();</span><br><span class="line">        <span class="keyword">if</span> (errorCode != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Health.down().withDetail(<span class="string">&quot;Error Code&quot;</span>, errorCode).build();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Health.up().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">check</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// perform some specific health check</span></span><br><span class="line">        <span class="keyword">return</span> ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>提示</strong></p>
<p><code>HealthIndicator</code>接口类的名字去掉<code>HealthIndicator</code>后缀（如果存在的话）会作为Bean的名字，上述实例中，这个自定义<code>HealthIndicator</code>的名字是my。</p>
</blockquote>
<p>除了Srping Boot内置的<a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/Status.java"><code>Status</code></a>之外，返回的<code>Health</code>内也可以使用自定义的状态。在这种情况下，需要实现一个自定义的<a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/StatusAggregator.java"><code>StatusAggregator</code></a> ，或者对<code>management.endpoint.health.status.order</code>属性进行配置，来替代默认的状态配置。</p>
<p>例如，假如在某个<code>HealthIndicator</code>内返回了一个自定义状态：<code>FATAL</code>，为了配置优先级，需要增加如下配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">health:</span></span><br><span class="line">      <span class="attr">status:</span></span><br><span class="line">        <span class="attr">order:</span> <span class="string">&quot;fatal,down,out-of-service,unknown,up&quot;</span></span><br></pre></td></tr></table></figure>

<p>HTTP的响应状态码反映了系统的整体监控状态。默认情况下，<code>OUT_OF_SERVICE</code>和<code>DOWN</code>的状态码是503。所有没有配置映射的健康状态（包括<code>UP</code>），其状态码为200。如果对自定义健康状态的状态码进行了配置，那么<code>DOWN</code>和<code>OUT_OF_SERVICE</code>的默认状态码会被禁用。如果仍然想保留这些配置，需要和自定义的状态一起进行显式地定义。下面的例子中，将<code>FATAL</code>映射为503（service unavailable），并且保留了<code>DOWN</code>和<code>OUT_OF_SERVICE</code>的原有的配置</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">health:</span></span><br><span class="line">      <span class="attr">status:</span></span><br><span class="line">        <span class="attr">http-mapping:</span></span><br><span class="line">          <span class="attr">down:</span> <span class="number">503</span></span><br><span class="line">          <span class="attr">fatal:</span> <span class="number">503</span></span><br><span class="line">          <span class="attr">out-of-service:</span> <span class="number">503</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>提示</strong></p>
<p>如果想要更多控制权，可以实现一个自定义的<code>HttpCodeStatusMapper</code> Bean</p>
</blockquote>
<p>以下表格展示了内置状态的默认映射配置：</p>
<table>
<thead>
<tr>
<th align="center">状态</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>DOWN</code></td>
<td align="center"><code>SERVICE_UNAVAILABLE</code> (<code>503</code>)</td>
</tr>
<tr>
<td align="center"><code>OUT_OF_SERVICE</code></td>
<td align="center"><code>SERVICE_UNAVAILABLE</code> (<code>503</code>)</td>
</tr>
<tr>
<td align="center"><code>UP</code></td>
<td align="center">默认没有映射，所以状态码是<code>200</code></td>
</tr>
<tr>
<td align="center"><code>UNKNOWN</code></td>
<td align="center">默认没有映射，所以状态码是<code>200</code></td>
</tr>
</tbody></table>
<h3 id="响应式健康指示器（Reactive-Health-Indicators）"><a href="#响应式健康指示器（Reactive-Health-Indicators）" class="headerlink" title="响应式健康指示器（Reactive Health Indicators）"></a>响应式健康指示器（Reactive Health Indicators）</h3><p>对于响应式的应用，例如使用了Spring WebFlux，<code>ReactiveHealthContributor</code>提供了非阻塞的契约来获得应用的健康信息。和传统的<code>HealthContributor</code>很类似，其健康信息收集自<a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/ReactiveHealthContributorRegistry.java"><code>ReactiveHealthContributorRegistry</code></a>（默认情况下，所有的 <a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/HealthContributor.java"><code>HealthContributor</code></a>和<a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/ReactiveHealthContributor.java"><code>ReactiveHealthContributor</code></a> 实例都在<code>ApplicationContext</code>中）。在弹性调度器下（elastic scheduler），常规的<code>HealthContributors</code>并不会调用响应式的API。</p>
<blockquote>
<p><strong>提示</strong></p>
<p>在响应式应用中，<code>ReactiveHealthContributorRegistry</code>应该在运行时状态下注册或反注册健康指示器（health indicators），如果想注册常规的<code>HealthContributor</code>，需要使用<code>ReactiveHealthContributor#adapt</code>对其包装。</p>
</blockquote>
<p>如果想通过响应式API提供自定义健康指示器（health indicators），可以注册实现了<a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/ReactiveHealthIndicator.java"><code>ReactiveHealthIndicator</code></a> 接口的Bean到Spring容器中，以下代码展示了一个<code>ReactiveHealthIndicator</code>的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyReactiveHealthIndicator</span> <span class="keyword">implements</span> <span class="title class_">ReactiveHealthIndicator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Health&gt; <span class="title function_">health</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> doHealthCheck().onErrorResume((exception) -&gt;</span><br><span class="line">            Mono.just(<span class="keyword">new</span> <span class="title class_">Health</span>.Builder().down(exception).build()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Mono&lt;Health&gt; <span class="title function_">doHealthCheck</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// perform some specific health check</span></span><br><span class="line">        <span class="keyword">return</span> ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>提示</strong></p>
<p>如果想自动处理异常错误，可以继承<code>AbstractReactiveHealthIndicator</code></p>
</blockquote>
<h3 id="自动装配的ReactiveHealthIndicators（Auto-configured-ReactiveHealthIndicators）"><a href="#自动装配的ReactiveHealthIndicators（Auto-configured-ReactiveHealthIndicators）" class="headerlink" title="自动装配的ReactiveHealthIndicators（Auto-configured ReactiveHealthIndicators）"></a>自动装配的ReactiveHealthIndicators（Auto-configured ReactiveHealthIndicators）</h3><p>Spring提供了一些内置的响应式健康指示器（<code>ReactiveHealthIndicators</code>），当它们可以可用时（端点被开启且被正常暴露时即为可用），会被自动装配。详情<a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.endpoints.health.auto-configured-reactive-health-indicators">参考源文档第2.8.4节</a>的表格，此处不再赘述</p>
<blockquote>
<p><strong>提示</strong></p>
<p>在必要的情况下，响应式的指示器会替代非响应式的指示器。并且任何没有被处理过的<code>HealthIndicator</code>也会被自动包装为响应式</p>
</blockquote>
<h3 id="健康分组（Health-Groups）"><a href="#健康分组（Health-Groups）" class="headerlink" title="健康分组（Health Groups）"></a>健康分组（Health Groups）</h3><p>处于某些原因，将健康指示器进行分组是很有用的。</p>
<p>可以创建<code>management.endpoint.health.group.&lt;name&gt;</code>属性来创建一个健康分组。并且使用<code>include</code>和<code>exclude</code>属性来配置指示器ID。例如，假如想创建一个仅仅包含数据库指示器的分支，可以配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">health:</span></span><br><span class="line">      <span class="attr">group:</span></span><br><span class="line">        <span class="attr">custom:</span></span><br><span class="line">          <span class="attr">include:</span> <span class="string">&quot;db&quot;</span></span><br></pre></td></tr></table></figure>

<p>然后可以通过链接：<a href="http://localhost:8080/actuator/health/custom">localhost:8080&#x2F;actuator&#x2F;health&#x2F;custom</a>访问该分组</p>
<p>同理，如果想创建一个不包含数据库指示器的分组，可以配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">health:</span></span><br><span class="line">      <span class="attr">group:</span></span><br><span class="line">        <span class="attr">custom:</span></span><br><span class="line">          <span class="attr">exclude:</span> <span class="string">&quot;db&quot;</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，如同系统的健康信息一样，分组沿用了相同的<code>StatusAggregator</code>和<code>HttpCodeStatusMapper</code>设置。不过这些设置可以在每个分组上单独定义。如果有需要的话，还可以覆盖<code>show-details</code>和<code>roles</code>的配置，例如：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">health:</span></span><br><span class="line">      <span class="attr">group:</span></span><br><span class="line">        <span class="attr">custom:</span></span><br><span class="line">          <span class="attr">show-details:</span> <span class="string">&quot;when-authorized&quot;</span></span><br><span class="line">          <span class="attr">roles:</span> <span class="string">&quot;admin&quot;</span></span><br><span class="line">          <span class="attr">status:</span></span><br><span class="line">            <span class="attr">order:</span> <span class="string">&quot;fatal,up&quot;</span></span><br><span class="line">            <span class="attr">http-mapping:</span></span><br><span class="line">              <span class="attr">fatal:</span> <span class="number">500</span></span><br><span class="line">              <span class="attr">out-of-service:</span> <span class="number">500</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>提示</strong></p>
<p>如果想将自定义的<code>StatusAggregator</code>和<code>HttpCodeStatusMapper</code> Bean注册到某个分组上，可以使用注解<code>@Qualifier(&quot;groupname&quot;)</code>对其进行限定</p>
</blockquote>
<h3 id="数据源健康（DataSource-Health）"><a href="#数据源健康（DataSource-Health）" class="headerlink" title="数据源健康（DataSource Health）"></a>数据源健康（DataSource Health）</h3><p><code>DataSource</code>健康指示器用来展示标准数据源（standard data source）类型和路由数据源（routing data source）类型的Bean的健康信息。路由数据源的健康信息也包含了目标数据源（its target data sources）的健康信息。在监控信息端点的HTTP响应中，每一个路由数据源的目标数据源的名字，由路由键值（routing key）来决定。如果想把路由数据源排除，可以将<code>management.health.db.ignore-routing-data-sources</code>设置为true</p>
<h2 id="Kubernetes探针（Kubernetes-Probes）"><a href="#Kubernetes探针（Kubernetes-Probes）" class="headerlink" title="Kubernetes探针（Kubernetes Probes）"></a>Kubernetes探针（Kubernetes Probes）</h2><p>部署在Kubernetes上的应用程序可以通过<a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes">容器探针</a>反馈内部状态信息。kubelet可以根据<a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/">Kubernetes的配置</a>调用这些探针并反馈探针结果。</p>
<p>Spring Boot提供了开箱即用的<a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.spring-application.application-availability">应用程序可用性状态</a>管理。当应用程序被部署到Kubernetes环境下，Spring Boot Acuator会通过<code>ApplicationAvailability</code>接口收集“Liveness”和“Readiness”信息，并且在<a href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%9A%84ReactiveHealthIndicators%EF%BC%88Auto-configured-ReactiveHealthIndicators%EF%BC%89">健康指示器</a>：<code>LivenessStateHealthIndicator</code>和<code>ReadinessStateHealthIndicator</code>中使用这些信息。这些指示器的信息显示在全局端点（<code>&quot;/actuator/health&quot;</code>）中。也可用通过使用<a href="#%E5%81%A5%E5%BA%B7%E5%88%86%E7%BB%84%EF%BC%88Health-Groups%EF%BC%89">健康分组</a>：<code>&quot;/actuator/health/liveness&quot;</code> 和 <code>&quot;/actuator/health/readiness&quot;</code> 访问这些端点。</p>
<p>可以使用如下端点信息配置Kubernetes：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">livenessProbe:</span></span><br><span class="line">  <span class="attr">httpGet:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/actuator/health/liveness</span></span><br><span class="line">    <span class="attr">port:</span> <span class="string">&lt;actuator-port&gt;</span></span><br><span class="line">  <span class="attr">failureThreshold:</span> <span class="string">...</span></span><br><span class="line">  <span class="attr">periodSeconds:</span> <span class="string">...</span></span><br><span class="line"></span><br><span class="line"><span class="attr">readinessProbe:</span></span><br><span class="line">  <span class="attr">httpGet:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/actuator/health/readiness</span></span><br><span class="line">    <span class="attr">port:</span> <span class="string">&lt;actuator-port&gt;</span></span><br><span class="line">  <span class="attr">failureThreshold:</span> <span class="string">...</span></span><br><span class="line">  <span class="attr">periodSeconds:</span> <span class="string">...</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>提示</strong></p>
<p><code>&lt;actuator-port&gt;</code>应该被配置为一个可以被访问的端口号。可以将其配置为web服务器的端口，或者通过<code>management.endpoint.health.probes.enabled</code>配置，使用独立的端口</p>
</blockquote>
<p>这些健康分组只有在应用程序<a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/deployment.html#deployment.cloud.kubernetes">运行在Kubernetes环境下</a>时才会自动生效。当然，也可以通过配置<code>management.endpoint.health.probes.enabled</code>来开启这些功能。</p>
<blockquote>
<p><strong>提示</strong></p>
<p>如果应用程序的启动时间比liveness指示器所反映的时间要长，Kubernetes提供了一个<code>“startupProbe”</code>探针作为替代方案。不过<code>“startupProbe”</code>探针并不一定必须配置，因为在所有的启动任务完成之前<code>&quot;readinessProbe&quot;</code>探针都处于失败状态。可以查看<a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.endpoints.kubernetes-probes.lifecycle">探针在应用程序生命周期中的行为</a></p>
</blockquote>
<blockquote>
<p><strong>警告</strong></p>
<p>如果端点（Actuator endpoints）被配置在独立的Spring上下文（a separate management context）中，需要注意的是，这些端点使用的web配置信息（端口、连接池、框架的组件等）也是独立于应用程序的。在这种情况下，即使应用程序已经无法正常工作（例如无法接受新连接），探针可能也会返回正常状态。</p>
</blockquote>
<h3 id="使用Kubernetes探针检测外部状态（Checking-External-State-with-Kubernetes-Probes）"><a href="#使用Kubernetes探针检测外部状态（Checking-External-State-with-Kubernetes-Probes）" class="headerlink" title="使用Kubernetes探针检测外部状态（Checking External State with Kubernetes Probes）"></a>使用Kubernetes探针检测外部状态（Checking External State with Kubernetes Probes）</h3><p>Spring Boot Actuator将“活性”（liveness）和“就绪”（readiness）探针配置为健康分组。这意味着对于这些探针来说，所有的<a href="#%E5%81%A5%E5%BA%B7%E5%88%86%E7%BB%84%EF%BC%88Health-Groups%EF%BC%89">健康分组特性</a>都适用。例如，可以配置如下健康指示器：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">health:</span></span><br><span class="line">      <span class="attr">group:</span></span><br><span class="line">        <span class="attr">readiness:</span></span><br><span class="line">          <span class="attr">include:</span> <span class="string">&quot;readinessState,customCheck&quot;</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，Spring Boot没有将其他的健康指示器添加到这些健康分组中。</p>
<p>“活性”（liveness）探针的健康检测不应该依赖于外部系统（笔者注：例如mongoDB、Redis等），如果<a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.spring-application.application-availability.liveness">应用程序的活性状态</a>处于当宕机状态，Kubernetes会尝试重新启动应用程序来解决这个问题。也就是说如果外部系统出现异常（例如数据库、Web API或外部缓存），那么Kubernetes会重启所有的应用程序，这会导致级联故障（笔者注：雪崩效应）</p>
<p>而对于“就绪”探针来说，开发人员必须谨慎处理外部系统的检测结果。比如Srping Boot就没有包含任何额外的健康检查。如果<a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.spring-application.application-availability.readiness">应用程序的就绪状态</a>处于未就绪（unready）状态，Kubernetes就不会将流量路由到该应用。那么把这些状态加入到“就绪”探针的探测中是理应该的。某些外部系统可能不是应用程序的关键依赖（比如应用程序已经部署了熔断或者降级策略），在这种情况下，这些外部系统就绝不应该被包含到“就绪”探针中。不妙的是，外部系统都是作为通用模块被应用程序所依赖的，这就需要做一个抉择：将其加入到“就绪”探针，当外部系统发生故障时，让应用程序也停止服务（out of service）；或者将这些外部系统排除在外，在外部系统发生故障时，从更高层级上处理这些故障，比如使用断路器。（Unfortunately, an external system that is shared by all application instances is common, and you have to make a judgement call: include it in the readiness probe and expect that the application is taken out of service when the external service is down, or leave it out and deal with failures higher up the stack, e.g. using a circuit breaker in the caller.）</p>
<blockquote>
<p><strong>提示</strong></p>
<p>If all instances of an application are unready, a Kubernetes Service with <code>type=ClusterIP</code> or <code>NodePort</code> will not accept any incoming connections. There is no HTTP error response (503 etc.) since there is no connection. A Service with <code>type=LoadBalancer</code> might or might not accept connections, depending on the provider. A Service that has an explicit <a href="https://kubernetes.io/docs/concepts/services-networking/ingress/">Ingress</a> will also respond in a way that depends on the implementation - the ingress service itself will have to decide how to handle the “connection refused” from downstream. HTTP 503 is quite likely in the case of both load balancer and ingress.</p>
</blockquote>
<p>此外，如果应用程序使用了Kubernetes的<a href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/">自动伸缩（autoscaling）</a>机制，对于负载均衡后面的程序，探针的表现可能会不同，这要取决于自动伸缩的配置。</p>
<h3 id="应用程序生命周期和探针状态（Application-Lifecycle-and-Probe-States）"><a href="#应用程序生命周期和探针状态（Application-Lifecycle-and-Probe-States）" class="headerlink" title="应用程序生命周期和探针状态（Application Lifecycle and Probe States）"></a>应用程序生命周期和探针状态（Application Lifecycle and Probe States）</h3><p>Kubernetes探针所支持的重要一点就是保持了和应用程序生命周期的一致性。应用程序内存中的内部状态：<code>AvailabilityState</code>和探针实际上返回的状态可能会有巨大的差异：在生命周期的某些阶段，探针可能是不可用状态。</p>
<p>当应用启动和关闭时，Sprin Boot会<a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.spring-application.application-events-and-listeners">发布事件</a>，探针可以监听这些事件，并且暴露<code>AvailabilityState</code>信息。</p>
<p>下面表格展示了在不同阶段下，<code>AvailabilityState</code>和HTTP服务器的状态，当Spring Boot应用程序启动时：</p>
<table>
<thead>
<tr>
<th align="center">启动阶段</th>
<th align="center">活性状态</th>
<th align="center">就绪状态</th>
<th align="center">HTTP服务器</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Starting</td>
<td align="center"><code>BROKEN</code></td>
<td align="center"><code>REFUSING_TRAFFIC</code></td>
<td align="center">未启动</td>
<td align="center">Kubernetes检查“活性”探针，如果耗时过长，就重启应用程序。</td>
</tr>
<tr>
<td align="center">Started</td>
<td align="center"><code>CORRECT</code></td>
<td align="center"><code>REFUSING_TRAFFIC</code></td>
<td align="center">拒绝连接</td>
<td align="center">应用程序上下文已经刷新，应用程序执行启动任务并且还不能接收流量</td>
</tr>
<tr>
<td align="center">Ready</td>
<td align="center"><code>CORRECT</code></td>
<td align="center"><code>ACCEPTING_TRAFFIC</code></td>
<td align="center">接受连接</td>
<td align="center">启动任务已经执行完毕，应用程序可以接收流量</td>
</tr>
</tbody></table>
<p>当Spring Boot应用程序关闭时：</p>
<table>
<thead>
<tr>
<th align="center">关闭阶段</th>
<th align="center">活性状态</th>
<th align="center">就绪状态</th>
<th align="center">HTTP服务器</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Running</td>
<td align="center"><code>CORRECT</code></td>
<td align="center"><code>ACCEPTING_TRAFFIC</code></td>
<td align="center">接受连接</td>
<td align="center">（此时）已经接受关闭请求</td>
</tr>
<tr>
<td align="center">Graceful shutdown</td>
<td align="center"><code>CORRECT</code></td>
<td align="center"><code>REFUSING_TRAFFIC</code></td>
<td align="center">不接受新连接</td>
<td align="center">如果启用该特性，<a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.graceful-shutdown">将会根据请求优雅地关闭进程</a></td>
</tr>
<tr>
<td align="center">Shutdown complete</td>
<td align="center">N&#x2F;A</td>
<td align="center">N&#x2F;A</td>
<td align="center">服务器关闭</td>
<td align="center">应用程序上下文被关闭并且应用也被关闭</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>提示</strong></p>
<p>查看 <a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/deployment.html#deployment.cloud.kubernetes.container-lifecycle">Kubernetes容器生命周期</a>查看关于Kubernetes部署更多的细节</p>
</blockquote>
<h2 id="应用程序信息（Application-Information）"><a href="#应用程序信息（Application-Information）" class="headerlink" title="应用程序信息（Application Information）"></a>应用程序信息（Application Information）</h2><p>应用程序信息可以暴露<code>ApplicationContext</code>内所有的<a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/info/InfoContributor.java"><code>InfoContributor</code></a> Bean收集到的信息。Spring Boot内置了很多自动装配的<code>InfoContributor</code> Bean，并且用户也可以编写自定义的Bean</p>
<h3 id="自动装配InfoContributors（Auto-configured-InfoContributors）"><a href="#自动装配InfoContributors（Auto-configured-InfoContributors）" class="headerlink" title="自动装配InfoContributors（Auto-configured InfoContributors）"></a>自动装配InfoContributors（Auto-configured InfoContributors）</h3><p>在适当的情况下，如下<code>InfoContributor</code>类型的Bean会被自动装配：</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/info/EnvironmentInfoContributor.java"><code>EnvironmentInfoContributor</code></a></td>
<td align="center">暴露<code>Environment</code>内所有<code>info</code>开头的属性（笔者注：例如配置在application.yaml内的info.name: myApp ）</td>
</tr>
<tr>
<td align="center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/info/GitInfoContributor.java"><code>GitInfoContributor</code></a></td>
<td align="center">如果<code>git.properties</code>文件存，则暴露git相关信息</td>
</tr>
<tr>
<td align="center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/info/BuildInfoContributor.java"><code>BuildInfoContributor</code></a></td>
<td align="center">如果<code>META-INF/build-info.properties</code>文件存在，则暴露构建相关信息</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>提示</strong></p>
<p>可以通过配置<code>management.info.defaults.enabled</code>关闭上述任意端点</p>
</blockquote>
<h3 id="自定义应用程序信息（Custom-Application-Information）"><a href="#自定义应用程序信息（Custom-Application-Information）" class="headerlink" title="自定义应用程序信息（Custom Application Information）"></a>自定义应用程序信息（Custom Application Information）</h3><p>可以通过在Spring配置文件中设置<code>info.*</code>配置暴露自定义的数据。所有的<code>Environment</code>属性下<code>info</code>开头的键值都会被自动暴露。例如，可以在<code>application.properties</code>下增加如下配置：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">info.app.encoding</span>=<span class="string">UTF-8</span></span><br><span class="line"><span class="attr">info.app.java.source</span>=<span class="string">11</span></span><br><span class="line"><span class="attr">info.app.java.target</span>=<span class="string">11</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>提示</strong></p>
<p>除了上述硬编码，还可以<a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/howto.html#howto.properties-and-configuration.expand-properties">在构建期间生成属性值</a></p>
<p>以Maven为例，可以将上述配置重写为：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">info.app.encoding</span>=<span class="string">@project.build.sourceEncoding@</span></span><br><span class="line"><span class="attr">info.app.java.source</span>=<span class="string">@java.version@</span></span><br><span class="line"><span class="attr">info.app.java.target</span>=<span class="string">@java.version@</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Git提交信息（Git-Commit-Information）"><a href="#Git提交信息（Git-Commit-Information）" class="headerlink" title="Git提交信息（Git Commit Information）"></a>Git提交信息（Git Commit Information）</h2><p>另外一个有用的<code>info</code>端点是展示源码所在的git仓库的提交信息。当<code>GitProperties</code> Bean存在时，这些信息就可以在<code>info</code>端点下暴露出来。</p>
<blockquote>
<p><strong>提示</strong></p>
<p>如果classpath<strong>根路径</strong>下面存在一个<code>git.properties</code>文件，<code>GitProperties</code> Bean会被自动装配，可以通过“<a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/howto.html#howto.build.generate-git-info">生成git信息</a>”获得更多细节</p>
</blockquote>
<p>默认情况下，在属性存在的前提下，端点会暴露出<code>git.branch</code>、<code>git.commit.id</code>和<code>git.commit.time</code>。如果想关闭任意属性，需要在<code>git.properties</code>中排除掉。如果想展示完整的git信息（也就是说git.properties文件的所有内容），可以配置<code>management.info.git.mode</code>属性，如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">info:</span></span><br><span class="line">    <span class="attr">git:</span></span><br><span class="line">      <span class="attr">mode:</span> <span class="string">&quot;full&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果想从<code>info</code>端点关闭git提交信息，可以通过将<code>management.info.git.enabled</code>属性设置为false，如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">info:</span></span><br><span class="line">    <span class="attr">git:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="构建信息（Build-Information）"><a href="#构建信息（Build-Information）" class="headerlink" title="构建信息（Build Information）"></a>构建信息（Build Information）</h3><p>如果<code>BuildProperties</code> Bean存在，还可以暴露构建信息，并且当classpath下存在<code>META-INF/build-info.properties</code>文件时生效。</p>
<blockquote>
<p><strong>提示</strong></p>
<p>Maven和Gradle插件都可以生成<code>META-INF/build-info.properties</code>文件，可以通过“<a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/howto.html#howto.build.generate-info">Generate build information</a>”或多更多细节</p>
</blockquote>
<h3 id="自定义InfoContributors（Writing-Custom-InfoContributors）"><a href="#自定义InfoContributors（Writing-Custom-InfoContributors）" class="headerlink" title="自定义InfoContributors（Writing Custom InfoContributors）"></a>自定义<code>InfoContributors</code>（Writing Custom InfoContributors）</h3><p>可以通过注册继承了 <a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/info/InfoContributor.java"><code>InfoContributor</code></a>接口的Bean实现自定义的应用信息。如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInfoContributor</span> <span class="keyword">implements</span> <span class="title class_">InfoContributor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contribute</span><span class="params">(Info.Builder builder)</span> &#123;</span><br><span class="line">        builder.withDetail(<span class="string">&quot;example&quot;</span>, Collections.singletonMap(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果访问<code>info</code>端点，将会看到如下的额外信息：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;example&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;key&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;value&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="通过HTTP进行监控与管理（Monitoring-and-Management-over-HTTP）"><a href="#通过HTTP进行监控与管理（Monitoring-and-Management-over-HTTP）" class="headerlink" title="通过HTTP进行监控与管理（Monitoring and Management over HTTP）"></a>通过HTTP进行监控与管理（Monitoring and Management over HTTP）</h1><p>如果你正在开发一个Web应用程序，Srping Boot Actuator会自动装配所有已经开启（enabled）的端点，使通过HTTP暴露。默认规则是通过端点的<code>id</code>附加一个<code>/actuator</code>前缀作为URL路径。例如，<code>health</code>端点的路径为<code>/actuator/health</code>。</p>
<blockquote>
<p><strong>提示</strong></p>
<ul>
<li>Spring Boot Actuator被Spring MVC、Spring WebFlux和 Jersey原生支持。如果Jersey和Spring MVC都处于可用状态，那么将会使用Spring MVC。</li>
<li>为了获得如API文档 （<a href="https://docs.spring.io/spring-boot/docs/2.5.0/actuator-api/htmlsingle">HTML</a>或<a href="https://docs.spring.io/spring-boot/docs/2.5.0/actuator-api/pdf/spring-boot-actuator-web-api.pdf">PDF</a>）中所述的正确JSON响应，需要将Jackon加入到依赖中</li>
</ul>
</blockquote>
<h2 id="自定义端点路径（Customizing-the-Management-Endpoint-Paths）"><a href="#自定义端点路径（Customizing-the-Management-Endpoint-Paths）" class="headerlink" title="自定义端点路径（Customizing the Management Endpoint Paths）"></a>自定义端点路径（Customizing the Management Endpoint Paths）</h2><p>某些情况下，自定义端点路径的前缀是很有必要的。比如，应用程序可能已经使用了<code>/actuator</code>路径作为其他用途。可以设置<code>management.endpoints.web.base-path</code>属性来调整端点的前缀，如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">base-path:</span> <span class="string">&quot;/manage&quot;</span></span><br></pre></td></tr></table></figure>

<p>这会将端点的URL从<code>/actuator/&#123;id&#125;</code> 改为<code>/manage/&#123;id&#125;</code>（例如：<code>/manage/info</code>）</p>
<blockquote>
<p><strong>提示</strong></p>
<p>除非管理端口被配置为其他的的HTTP端口，否则<code>management.endpoints.web.base-path</code>的配置是相对于<code>server.servlet.context-path</code>（Servlet web应用）或<code>spring.webflux.base-path</code>（响应式web应用）的。如果<code>management.server.port</code>被配置了，那么<code>management.endpoints.web.base-path</code>是相对于<code>management.server.base-path</code>的路径。</p>
</blockquote>
<p>如果想将端点映射到其他路径，可以修改<code>management.endpoints.web.path-mapping</code>属性，以下示例将<code>/actuator/health</code>映射为<code>/healthcheck</code></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">base-path:</span> <span class="string">&quot;/&quot;</span></span><br><span class="line">      <span class="attr">path-mapping:</span></span><br><span class="line">        <span class="attr">health:</span> <span class="string">&quot;healthcheck&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="自定义端口（Customizing-the-Management-Server-Port）"><a href="#自定义端口（Customizing-the-Management-Server-Port）" class="headerlink" title="自定义端口（Customizing the Management Server Port）"></a>自定义端口（Customizing the Management Server Port）</h2><p>如果应用程序是基于云部署，那么使用默认的HTTP端口来暴露端点是一个明智的选择。不过，如果应用程序运行在自己内部的数据中心，可能会倾向于使用其他的HTTP端口。</p>
<p>可以通过设置<code>management.server.port</code>属性调整HTTP端口，如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8081</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>提示</strong></p>
<p>在Cloud Foundry上，默认情况下，应用程序只在端口8080上接收HTTP和TCP路由请求。如果想在Cloud Foundry上使用自定义的端口，你需要明确地设置应用程序的路由，将流量转发到自定义端口。</p>
</blockquote>
<h2 id="配置SSL（Configuring-Management-specific-SSL）"><a href="#配置SSL（Configuring-Management-specific-SSL）" class="headerlink" title="配置SSL（Configuring Management-specific SSL）"></a>配置SSL（Configuring Management-specific SSL）</h2><p>当使用了自定义端口之后，也可以通过<code>management.server.ssl.*</code>属性配置独立的SSL。例如，可以让端点管理通过HTTP访问，而应用程序通过HTTPS访问，如下配置所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8443</span></span><br><span class="line">  <span class="attr">ssl:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">key-store:</span> <span class="string">&quot;classpath:store.jks&quot;</span></span><br><span class="line">    <span class="attr">key-password:</span> <span class="string">secret</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">    <span class="attr">ssl:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>又或者，端点管理和应用程序都通过SSL访问，但是使用不同的证书和秘钥（keystore），如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8443</span></span><br><span class="line">  <span class="attr">ssl:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">key-store:</span> <span class="string">&quot;classpath:main.jks&quot;</span></span><br><span class="line">    <span class="attr">key-password:</span> <span class="string">&quot;secret&quot;</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">    <span class="attr">ssl:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">key-store:</span> <span class="string">&quot;classpath:management.jks&quot;</span></span><br><span class="line">      <span class="attr">key-password:</span> <span class="string">&quot;secret&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="自定义服务器地址"><a href="#自定义服务器地址" class="headerlink" title="自定义服务器地址"></a>自定义服务器地址</h2><p>通过设置<code>management.server.address</code>属性，可以自定义端点的访问地址。如果只想监听内部网络或运维内部网络（ops-facing network ），有或者只想监听来来自localhost的连接，这个设置就会很有用。</p>
<blockquote>
<p><strong>提示</strong></p>
<p>只有当端点端口与应用程序端口不同时，才可以配置监听不同的地址。</p>
</blockquote>
<p>如下配置不允许远程连接访问：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line">    <span class="attr">address:</span> <span class="string">&quot;127.0.0.1&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="禁用HTTP端点（Disabling-HTTP-Endpoints）"><a href="#禁用HTTP端点（Disabling-HTTP-Endpoints）" class="headerlink" title="禁用HTTP端点（Disabling HTTP Endpoints）"></a>禁用HTTP端点（Disabling HTTP Endpoints）</h2><p>如果不想通过HTTP暴露端点，可以将端口设置为-1，例如：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>也可以通过设置<code>management.endpoints.web.exposure.exclude</code>属性达到达到这个效果。如下配置所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">exclude:</span> <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="通过JMX进行监控和管理（Monitoring-and-Management-over-JMX）"><a href="#通过JMX进行监控和管理（Monitoring-and-Management-over-JMX）" class="headerlink" title="通过JMX进行监控和管理（Monitoring and Management over JMX）"></a>通过JMX进行监控和管理（Monitoring and Management over JMX）</h1><p>JAVA管理扩展（JMX）提供了管理和监控应用程序的标准机制。这个特性默认没有被启用，可以通过设置<code>spring.jmx.enabled</code>为<code>true</code>来开启。默认情况下，Spring Boot的JMX MBeans位于<code>org.springframework.boot</code>作用域下。要想完全控制JMX域下的端点，可以考虑实现<code>EndpointObjectNameFactory</code>接口。</p>
<h3 id="自定义MBean名字（Customizing-MBean-Names）"><a href="#自定义MBean名字（Customizing-MBean-Names）" class="headerlink" title="自定义MBean名字（Customizing MBean Names）"></a>自定义MBean名字（Customizing MBean Names）</h3><p>通常情况下，MBean的名字由端点的<code>id</code>生成。例如，<code>health</code>端点就被暴露为：<code>org.springframework.boot:type=Endpoint,name=Health</code>。</p>
<p>如果应用程序拥有的<code>ApplicationContext</code>不止一个的话，可能会发现名称冲突。若要解决该问题，可以设置属性<code>spring.jmx.unique-names</code>为<code>true</code>，这样的话，MBean的名字就是唯一的了。</p>
<p>可以自定义暴露端点的JMX作用域，如下例所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">jmx:</span></span><br><span class="line">    <span class="attr">unique-names:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">jmx:</span></span><br><span class="line">      <span class="attr">domain:</span> <span class="string">&quot;com.example.myapp&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="禁用JMX端点（Disabling-JMX-Endpoints）"><a href="#禁用JMX端点（Disabling-JMX-Endpoints）" class="headerlink" title="禁用JMX端点（Disabling JMX Endpoints）"></a>禁用JMX端点（Disabling JMX Endpoints）</h3><p>如果不想通过JMX暴露端点，可以设置<code>management.endpoints.jmx.exposure.exclude</code>属性为<code>*</code>，如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">jmx:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">exclude:</span> <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="通过HTTP访问基于Jolokia的JMX端点（Using-Jolokia-for-JMX-over-HTTP）"><a href="#通过HTTP访问基于Jolokia的JMX端点（Using-Jolokia-for-JMX-over-HTTP）" class="headerlink" title="通过HTTP访问基于Jolokia的JMX端点（Using Jolokia for JMX over HTTP）"></a>通过HTTP访问基于Jolokia的JMX端点（Using Jolokia for JMX over HTTP）</h3><p>Jolokia作为一个JMX-HTTP桥接器提供了访问JMX bean的替代方案。如果想要使用Jolokia，需要添加依赖：<code>org.jolokia:jolokia-core</code>。以Maven为例，配置如下所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jolokia<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jolokia-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以通过添加<code>jolokia</code>或<code>*</code>到<code>management.endpoints.web.exposure.include</code>属性中开启Jolokia端点。然后可以使用<code>/actuator/jolokia</code>该端点。</p>
<blockquote>
<p><strong>提示</strong></p>
<p>Jolokia端点将Jolokia的servlet暴露为actuator端点。这意味着它是特定于Spring MVC和Jersey等servlet环境的。并且该端点在WebFlux应用程序中不可用。</p>
</blockquote>
<h4 id="自定义Jolokia（Customizing-Jolokia）"><a href="#自定义Jolokia（Customizing-Jolokia）" class="headerlink" title="自定义Jolokia（Customizing Jolokia）"></a>自定义Jolokia（Customizing Jolokia）</h4><p>Jolokia包含许多设置，通常可以是通过设置servlet参数进行配置。而在Spring Boot下中，可以使用<code>application.properties</code>。所有的Jolokia参数都以<code>management.endpoint.jolokia.config</code>作为前缀，举例如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">jolokia:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h4 id="禁用Jolokia（Disabling-Jolokia）"><a href="#禁用Jolokia（Disabling-Jolokia）" class="headerlink" title="禁用Jolokia（Disabling Jolokia）"></a>禁用Jolokia（Disabling Jolokia）</h4><p>当使用了Jolokia而又不想让Spring Boot对其进行配置，可以将<code>management.endpoint.jolokia.enabled</code>设置为<code>false</code>，如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">jolokia:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h1 id="日志（Loggers）"><a href="#日志（Loggers）" class="headerlink" title="日志（Loggers）"></a>日志（Loggers）</h1><p>Spring Boot Actuator具备查看和设置正在运行中的应用程序的日志等级的能力。可以查看完整日志列表或者单独某个日志的配置，这些配置由两部分组成：显式配置的日志等级和日志框架给定的有效日志等级。这些日志等级可以是如下任意一个：</p>
<ul>
<li><code>TRACE</code></li>
<li><code>DEBUG</code></li>
<li><code>INFO</code></li>
<li><code>WARN</code></li>
<li><code>ERROR</code></li>
<li><code>FATAL</code></li>
<li><code>OFF</code></li>
<li><code>null</code></li>
</ul>
<p><code>null</code>代表没有显示地配置日志</p>
<h2 id="配置日志（Configure-a-Logger）"><a href="#配置日志（Configure-a-Logger）" class="headerlink" title="配置日志（Configure a Logger）"></a>配置日志（Configure a Logger）</h2><p>如果要配置一个日志，可以向资源URL <code>POST</code>一个特定的请求体，如下所示：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;configuredLevel&quot;</span><span class="punctuation">:</span> <span class="string">&quot;DEBUG&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>提示</strong></p>
<p>如果想重置之前设置的日志等级（并且使用默认配置），可以将<code>configuredLevel</code>设置为<code>null</code></p>
</blockquote>
<h1 id="指标（Metrics）"><a href="#指标（Metrics）" class="headerlink" title="指标（Metrics）"></a>指标（Metrics）</h1><p>Spring Boot Actuator提供了对 <a href="https://micrometer.io/">Micrometer</a>的依赖管理和自动装配。Spring内部提供了指标门面（an application metrics facade）模式，该模式提供了对于<a href="https://micrometer.io/docs">众多监控系统</a>的支持，包括：</p>
<ul>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.appoptics">AppOptics</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.atlas">Atlas</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.datadog">Datadog</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.dynatrace">Dynatrace</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.elastic">Elastic</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.ganglia">Ganglia</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.graphite">Graphite</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.humio">Humio</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.influx">Influx</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.jmx">JMX</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.kairos">KairosDB</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.newrelic">New Relic</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.prometheus">Prometheus</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.signalfx">SignalFx</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.simple">Simple (in-memory)</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.stackdriver">Stackdriver</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.statsd">StatsD</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.wavefront">Wavefront</a></li>
</ul>
<blockquote>
<p><strong>提示</strong></p>
<p>要了解更多关于Micrometer的功能，请参考它的<a href="https://micrometer.io/docs">参考文档</a>，特别是<a href="https://micrometer.io/docs/concepts">概念部分</a>。</p>
</blockquote>
<h2 id="入门（Getting-started）"><a href="#入门（Getting-started）" class="headerlink" title="入门（Getting started）"></a>入门（Getting started）</h2><p>Spring Boot自动装配了一个组合类型（composite）的指标注册表（<code>MeterRegistry</code>），对于在classpath下发现的任何指标注册表（<code>MeterRegistery</code>）的实现，Spring Boot会将其加入到这个组合类型的指标注册表中。实际上，在运行期（runtime）的classpath下增加<code>micrometer-registry-&#123;system&#125;</code>（笔者注：此处的system可以替换成上述列表中的监控系统）依赖后，Spring Boot就会自动配置对应类型的注册表（registery）。</p>
<p>大多数注册表都有相同的特性。例如，即使（Micrometer的）注册表的实现类在classpath内，也可以将其禁用。例如，要禁用Datadog：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">datadog:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>也可以禁用所有注册表，除非某注册表已经通过自己的配置单独启用，如下例所示:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">defaults:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>Spring Boot将自动装配的注册器添加到<code>Metrics</code>类（笔者注：全类限定名为：<code>io.micrometer.core.instrument.Metrics</code>）的全局静态组合注册表中，触发显示禁用：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">use-global-registry:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>可以注册任意数量的类型为<code>MeterRegistryCustomizer</code>的bean，这些bean可以实现对注册表的自定义化配置，例如当任意指标注册到指标注册表中时，每个为这些指标增加通用的Tag标记：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMeterRegistryConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MeterRegistryCustomizer&lt;MeterRegistry&gt; <span class="title function_">metricsCommonTags</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (registry) -&gt; registry.config().commonTags(<span class="string">&quot;region&quot;</span>, <span class="string">&quot;us-east-1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以通过更具体的泛型类型的支实现对特定注册表的自定义化配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMeterRegistryConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MeterRegistryCustomizer&lt;GraphiteMeterRegistry&gt; <span class="title function_">graphiteMetricsNamingConvention</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (registry) -&gt; registry.config().namingConvention(<span class="built_in">this</span>::name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">name</span><span class="params">(String name, Meter.Type type, String baseUnit)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring Boot还<a href="##%E6%94%AF%E6%8C%81%E7%9A%84%E6%8C%87%E6%A0%87%EF%BC%88Supported-Metrics-and-Meters%EF%BC%89">内置的很多指标和仪表</a>，可以通过配置文件或专用注解来控制这些指标。</p>
<h2 id="支持的监控系统（Supported-Monitoring-Systems）"><a href="#支持的监控系统（Supported-Monitoring-Systems）" class="headerlink" title="支持的监控系统（Supported Monitoring Systems）"></a>支持的监控系统（Supported Monitoring Systems）</h2><h3 id="AppOptics"><a href="#AppOptics" class="headerlink" title="AppOptics"></a>AppOptics</h3><p>默认情况下，AppOptics注册表负责将指标周期性地推送到 <a href="https://api.appoptics.com/v1/measurements"><code>api.appoptics.com/v1/measurements</code></a>。为了把指标推送到Saas <a href="https://micrometer.io/docs/registry/appOptics">AppOptics</a>平台，需要在配置里提供API令牌（API token）：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">appoptics:</span></span><br><span class="line">        <span class="attr">api-token:</span> <span class="string">&quot;YOUR_TOKEN&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Atlas"><a href="#Atlas" class="headerlink" title="Atlas"></a>Atlas</h3><p>默认情况下， <a href="https://micrometer.io/docs/registry/atlas">Atlas</a> 指标暴露给本机正在运行的Atlas服务器。 <a href="https://github.com/Netflix/atlas">Atlas服务器</a> 的地址可以使用如下配置进行修改：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">atlas:</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">&quot;https://atlas.example.com:7101/api/v1/publish&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="Datadog"><a href="#Datadog" class="headerlink" title="Datadog"></a>Datadog</h3><p>Datadog注册表负责周期性地将指标推送给<a href="https://www.datadoghq.com/">datadoghq</a>。为了把指标推送到 <a href="https://micrometer.io/docs/registry/datadog">Datadog</a>，需要在配置里提供API秘钥（API key）：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">datadog:</span></span><br><span class="line">        <span class="attr">api-key:</span> <span class="string">&quot;YOUR_KEY&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="Dynatrace"><a href="#Dynatrace" class="headerlink" title="Dynatrace"></a>Dynatrace</h3><p>Dynatrace注册表负责将指标周期性地推送给配置的URL。为了把指标推送到<a href="https://micrometer.io/docs/registry/dynatrace">Dynatrace</a>，需要提供API令牌（API token）、设备ID（device ID）以及URL：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">dynatrace:</span></span><br><span class="line">        <span class="attr">api-token:</span> <span class="string">&quot;YOUR_TOKEN&quot;</span></span><br><span class="line">        <span class="attr">device-id:</span> <span class="string">&quot;YOUR_DEVICE_ID&quot;</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">&quot;YOUR_URI&quot;</span></span><br></pre></td></tr></table></figure>

<p>也可以修改推送指标到Dynatrace的间隔时间：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">dynatrace:</span></span><br><span class="line">        <span class="attr">step:</span> <span class="string">&quot;30s&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="Elastic"><a href="#Elastic" class="headerlink" title="Elastic"></a>Elastic</h3><p>默认情况下，指标会被推送到本机运行的<a href="https://micrometer.io/docs/registry/elastic">Elastic</a>服务器上，而Elastic服务器的地址可以通过如下配置进行修改：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">elastic:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">&quot;https://elastic.example.com:8086&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="Ganglia"><a href="#Ganglia" class="headerlink" title="Ganglia"></a>Ganglia</h3><p>默认情况下，指标会被推送到本机运行的<a href="https://micrometer.io/docs/registry/ganglia">Ganglia</a>服务器上，<a href="http://ganglia.sourceforge.net/">Ganglia服务器</a>的地址和端口可以通过如下配置进行修改：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">ganglia:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">&quot;ganglia.example.com&quot;</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">9649</span></span><br></pre></td></tr></table></figure>

<h3 id="Graphite"><a href="#Graphite" class="headerlink" title="Graphite"></a>Graphite</h3><p>默认情况下，指标会被推送到本机运行的 <a href="https://micrometer.io/docs/registry/graphite">Graphite</a>服务器上， <a href="https://graphiteapp.org/">Graphite服务器</a>的地址和端口可以通过如下配置进行修改：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">     <span class="attr">export:</span></span><br><span class="line">       <span class="attr">graphite:</span></span><br><span class="line">         <span class="attr">host:</span> <span class="string">&quot;graphite.example.com&quot;</span></span><br><span class="line">         <span class="attr">port:</span> <span class="number">9004</span></span><br></pre></td></tr></table></figure>

<p>Micrometer提供了一个默认的<code>HierarchicalNameMapper</code>，用于管理如何在多维度的指标名称<a href="https://micrometer.io/docs/registry/graphite#_hierarchical_name_mapping">扁平化指标名称之间进行映射转换</a>。</p>
<blockquote>
<p><strong>提示</strong></p>
<p>如果想实现自定义的名称映射管理，需要自己实现<code>GraphiteMeterRegistry</code>并且提供自定义的<code>HierarchicalNameMapper</code>，<code>GraphiteConfig</code>和<code>Clock</code>不需要自定义，它们会被Spring自动装配，除非用户已经自己定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyGraphiteConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> GraphiteMeterRegistry <span class="title function_">graphiteMeterRegistry</span><span class="params">(GraphiteConfig config, Clock clock)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GraphiteMeterRegistry</span>(config, clock, <span class="built_in">this</span>::toHierarchicalName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">toHierarchicalName</span><span class="params">(Meter.Id id, NamingConvention convention)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Humio"><a href="#Humio" class="headerlink" title="Humio"></a>Humio</h3><p>默认情况下，指标被周期性地推送到 <a href="https://cloud.humio.com/">cloud.humio.com</a>，为了把指标推送到Saas <a href="https://micrometer.io/docs/registry/humio">Humio</a>平台，需要提供API令牌（API token）：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">humio:</span></span><br><span class="line">        <span class="attr">api-token:</span> <span class="string">&quot;YOUR_TOKEN&quot;</span></span><br></pre></td></tr></table></figure>

<p>也可以为每个要推送的指标配置一个或多个Tag标记，用来区分数据源：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">humio:</span></span><br><span class="line">        <span class="attr">tags:</span></span><br><span class="line">          <span class="attr">alpha:</span> <span class="string">&quot;a&quot;</span></span><br><span class="line">          <span class="attr">bravo:</span> <span class="string">&quot;b&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="Influx"><a href="#Influx" class="headerlink" title="Influx"></a>Influx</h3><p>默认情况下，指标被推送（exported）给运行于本机的v1版本的 <a href="https://micrometer.io/docs/registry/influx">Influx</a>，如果想把指标推送给InfluxDB v2，需要配置<code>org</code>、<code>bucket</code>和认证用的<code>token</code>。 <a href="https://www.influxdata.com/">Influx服务器</a>的地址可以通过如下配置进行修改：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">influx:</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">&quot;https://influx.example.com:8086&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="JMX"><a href="#JMX" class="headerlink" title="JMX"></a>JMX</h3><p>Micrometer提供了向<a href="https://micrometer.io/docs/registry/jmx">JMX</a>的层级映射，主要用来当做一种低成本且便携的本地查看指标的方式。默认情况下，指标被推送给JMX的<code>metrics</code>作用域（domain），而作用域也可以通过如下配置进行修改：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">management:</span><br><span class="line">  metrics:</span><br><span class="line">    export:</span><br><span class="line">      jmx:</span><br><span class="line">        domain: <span class="string">&quot;com.example.app.metrics&quot;</span></span><br></pre></td></tr></table></figure>

<p>Micrometer提供了一个默认的<code>HierarchicalNameMapper</code>，用于管理如何在多维度的指标名称<a href="https://micrometer.io/docs/registry/jmx#_hierarchical_name_mapping">扁平化指标名称之间进行映射转换</a>。</p>
<blockquote>
<p><strong>提示</strong></p>
<p>如果想实现自定义的名称映射管理，需要自己实现<code>JmxMeterRegistry</code>并且提供自定义的<code>HierarchicalNameMapper</code>，<code>JmxConfig </code>和<code>Clock</code>不需要自定义，它们都被Spring自动装配，除非用户已经自己定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyJmxConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> JmxMeterRegistry <span class="title function_">jmxMeterRegistry</span><span class="params">(JmxConfig config, Clock clock)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JmxMeterRegistry</span>(config, clock, <span class="built_in">this</span>::toHierarchicalName);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String <span class="title function_">toHierarchicalName</span><span class="params">(Meter.Id id, NamingConvention convention)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> ...</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="KairosDB"><a href="#KairosDB" class="headerlink" title="KairosDB"></a>KairosDB</h3><p>默认情况下，指标会被推送到本机运行的 <a href="https://micrometer.io/docs/registry/kairos">KairosDB</a> 服务器上， <a href="https://kairosdb.github.io/">KairosDB 服务器</a>的地址可以通过如下配置进行修改：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">kairos:</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">&quot;https://kairosdb.example.com:8080/api/v1/datapoints&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="New-Relic"><a href="#New-Relic" class="headerlink" title="New Relic"></a>New Relic</h3><p>New Relic注册表负责周期性地将指标推送给<a href="https://micrometer.io/docs/registry/new-relic">New Relic</a>。为了把指标推送到 <a href="https://newrelic.com/">New Relic</a>，需要在配置里提供API秘钥（API key）和账号id（account id）：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">newrelic:</span></span><br><span class="line">        <span class="attr">api-key:</span> <span class="string">&quot;YOUR_KEY&quot;</span></span><br><span class="line">        <span class="attr">account-id:</span> <span class="string">&quot;YOUR_ACCOUNT_ID&quot;</span></span><br></pre></td></tr></table></figure>

<p>也可以修改推送指标到New Relic的间隔时间：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">newrelic:</span></span><br><span class="line">        <span class="attr">step:</span> <span class="string">&quot;30s&quot;</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，指标以REST的形式推送。也可以使用Java Agent API，如果响应的类库在classpath路径内的情况下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">newrelic:</span></span><br><span class="line">        <span class="attr">client-provider-type:</span> <span class="string">&quot;insights-agent&quot;</span></span><br></pre></td></tr></table></figure>

<p>最后，也可以通过自定义实现<code>NewRelicClientProvider</code> bean获得完全的控制权。</p>
<h3 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h3><p><a href="https://micrometer.io/docs/registry/prometheus">Prometheus</a>获取指标的方式是向应用程序拉取或轮询的指标数据。Spring Boot提供了一个可用的端点<code>/actuator/prometheus</code>，并以适当的方式提供给<a href="https://prometheus.io/">Prometheus指标采集器</a>（Prometheus scrape）</p>
<blockquote>
<p><strong>提示</strong></p>
<p>端点默认是禁用的，并且还需要开放暴露，可用查看<a href="##%E6%9A%B4%E9%9C%B2%E7%AB%AF%E7%82%B9%EF%BC%88Exposing-Endpoints%EF%BC%89">暴露端点（Exposing Endpoints）</a>获取更详细信息</p>
</blockquote>
<p>以下是<code>prometheus.yml</code>配置文件中的<code>scrape_config</code>配置示例：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;spring&#x27;</span></span><br><span class="line">    <span class="attr">metrics_path:</span> <span class="string">&#x27;/actuator/prometheus&#x27;</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&#x27;HOST:PORT&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>对于某些无法被拉取的短暂任务或批量任务， Prometheus的<a href="https://github.com/prometheus/pushgateway">Pushgateway</a>组件提供了将指标推送给Prometheus的方式。如果要启用Pushgateway的支持，需要增加如下依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.prometheus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>simpleclient_pushgateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当Pushgateway 组件存在于classpath下，并且<code>management.metrics.export.prometheus.pushgateway.enabled</code>被设置为<code>true</code>时，Spring Boot会自动装配一个<code>PrometheusPushGatewayManager</code> bean。这个bean就复杂将指标推送到<code>Pushgateway</code>。</p>
<p>可以通过<code>management.metrics.export.prometheus.pushgateway.</code>属性对<code>PrometheusPushGatewayManager</code>进一步配置，当然，用户也可以自定义<code>PrometheusPushGatewayManager</code> bean。</p>
<h3 id="SignalFx"><a href="#SignalFx" class="headerlink" title="SignalFx"></a>SignalFx</h3><p>SignalFx注册表负责周期性地将指标推送给 <a href="https://micrometer.io/docs/registry/signalFx">SignalFx</a>。为了把指标推送到 <a href="https://www.signalfx.com/">SignalFx</a>，需要在配置里提供访问令牌（access token）：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">signalfx:</span></span><br><span class="line">        <span class="attr">access-token:</span> <span class="string">&quot;YOUR_ACCESS_TOKEN&quot;</span></span><br></pre></td></tr></table></figure>

<p>也可以修改推送指标到SignalFx的间隔时间：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">signalfx:</span></span><br><span class="line">        <span class="attr">step:</span> <span class="string">&quot;30s&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="Simple"><a href="#Simple" class="headerlink" title="Simple"></a>Simple</h3><p>Micrometer内置了一个简易的、在内存中的（in-memory）注册表。如果其他的注册表都没有被配置，它会将当做默认的指标监控系统。通过该系统，可以在<a href="##%E6%8C%87%E6%A0%87%E7%AB%AF%E7%82%B9%EF%BC%88Metrics-Endpoint%EF%BC%89">指标端点</a>中查看系统收集了哪些指标。</p>
<p>只要启用了其他任意监控系统，simple系统就会被自动禁用。当然也可以显式将其关闭：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="Stackdriver"><a href="#Stackdriver" class="headerlink" title="Stackdriver"></a>Stackdriver</h3><p>Stackdriver注册表负责周期性地将指标推送给<a href="https://cloud.google.com/stackdriver/">Stackdriver</a>。为了把指标推送到SaaS <a href="https://micrometer.io/docs/registry/stackdriver">Stackdriver</a>平台，需要在配置里提供谷歌云的project id：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">stackdriver:</span></span><br><span class="line">        <span class="attr">project-id:</span> <span class="string">&quot;my-project&quot;</span></span><br></pre></td></tr></table></figure>

<p>也可以修改推送指标到Stackdriver的间隔时间：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">stackdriver:</span></span><br><span class="line">        <span class="attr">step:</span> <span class="string">&quot;30s&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="StatsD"><a href="#StatsD" class="headerlink" title="StatsD"></a>StatsD</h3><p>StatsD注册表通过UDP将指标推送到StatsD代理。默认情况下，指标将被推送到本机运行的StatsD代理。StatsD代理的主机（host）、端口（port）和协议（协议）可以通过以下方式修改：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">statsd:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">&quot;statsd.example.com&quot;</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">9125</span></span><br><span class="line">        <span class="attr">protocol:</span> <span class="string">&quot;udp&quot;</span></span><br></pre></td></tr></table></figure>

<p>也可以修改StatsD所使用的line协议（line protocol）（默认为Datadog）：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">statsd:</span></span><br><span class="line">        <span class="attr">flavor:</span> <span class="string">&quot;etsy&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="Wavefront"><a href="#Wavefront" class="headerlink" title="Wavefront"></a>Wavefront</h3><p>Wavefront注册表负责周期性地将指标推送给<a href="https://micrometer.io/docs/registry/wavefront">Wavefront</a>。为了把指标推送到<a href="https://www.wavefront.com/">Wavefront</a>，需要在配置里提供API令牌（API token）：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">wavefront:</span></span><br><span class="line">        <span class="attr">api-token:</span> <span class="string">&quot;YOUR_API_TOKEN&quot;</span></span><br></pre></td></tr></table></figure>

<p>你可能会使用一个Wavefront边车代理（Wavefront sidecar）或设置一个内部代理，用于将指标数据转发到Wavefront API主机：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">wavefront:</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">&quot;proxy://localhost:2878&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>指标</strong></p>
<p>如果是将指标发布到Wavefront代理（如<a href="https://docs.wavefront.com/proxies_installing.html">文档所述</a>），主机的配置格式必须为：<code>proxy://HOST:PORT</code></p>
</blockquote>
<p>也可以修改推送指标到Wavefront的间隔时间：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">wavefront:</span></span><br><span class="line">        <span class="attr">step:</span> <span class="string">&quot;30s&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="支持的指标和仪表（Supported-Metrics-and-Meters）"><a href="#支持的指标和仪表（Supported-Metrics-and-Meters）" class="headerlink" title="支持的指标和仪表（Supported Metrics and Meters）"></a>支持的指标和仪表（Supported Metrics and Meters）</h2><p>对于（系统使用的）各种的技术组件，Spring Boot都提供了指标自动注册。大多数情况下，这些开箱即用的指标注册表会选择适当的指标，并将其发布到任意所支持的监控系统上。</p>
<h3 id="JVM指标（JVM-Metrics）"><a href="#JVM指标（JVM-Metrics）" class="headerlink" title="JVM指标（JVM Metrics）"></a>JVM指标（JVM Metrics）</h3><p>自动装配机制会使用Micrometer的核心代码开启JVM指标。JVM指标被发布在<code>jvm.</code>名称下。如下JVM指标都是支持的：</p>
<ul>
<li>各种内存和缓冲池详细信息</li>
<li>垃圾收集相关统计</li>
<li>线程利用率</li>
<li>被加载&#x2F;卸载的class数量</li>
</ul>
<h3 id="系统指标（System-Metrics）"><a href="#系统指标（System-Metrics）" class="headerlink" title="系统指标（System Metrics）"></a>系统指标（System Metrics）</h3><p>自动装配机制会使用Micrometer的核心代码开启系统指标。系统指标被发布在<code>system.</code>和<code>process.</code>名称下。如下系统指标都是支持的：</p>
<ul>
<li>CPU指标</li>
<li>文件指标（File descriptor metrics）</li>
<li>运行时间指标（包括系统的运行时间以及启动时的绝对时间）</li>
</ul>
<h3 id="日志指标（Logger-Metrics）"><a href="#日志指标（Logger-Metrics）" class="headerlink" title="日志指标（Logger Metrics）"></a>日志指标（Logger Metrics）</h3><p>自动装配机制支持Logback和Log4J2的日志事件。这些指标被发布在<code>log4j2.events.</code>或<code>logback.events.</code>下面。</p>
<h3 id="Spring-MVC指标（-Spring-MVC-Metrics）"><a href="#Spring-MVC指标（-Spring-MVC-Metrics）" class="headerlink" title="Spring MVC指标（ Spring MVC Metrics）"></a>Spring MVC指标（ Spring MVC Metrics）</h3><p>自动装配机制会开启对 Spring MVC控制器（Spring MVC controllers）和请求处理器（functional handlers）的所有请求的采集。默认情况下，指标的名称前缀为<code> http.server.requests</code>。可以通过设置 <code>management.metrics.web.server.request.metric-name </code>来自定义该前缀。</p>
<p><code>@Controller</code>类和<code>@RequestMapping</code>方法支持<code>@Timed</code>注解（详情参考：[@Timed注解支持（@Timed Annotation Support）](##@Timed注解支持（@Timed Annotation Support）)）。如果不想开启所有的Spring MVC请求，可以将<code>management.metrics.web.server.request.autotime.enabled</code>设置为<code>false</code>，而仅使用<code>@Timed</code>注解。</p>
<p>默认情况下，Spring MVC相关的指标会被增加如下tag标记：</p>
<table>
<thead>
<tr>
<th align="center">Tag</th>
<th align="center">详情</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>exception</code></td>
<td align="center">当处理请求出现异常时，被抛出的异常类的简短类名</td>
</tr>
<tr>
<td align="center"><code>method</code></td>
<td align="center">请求方法（例如：<code>GET</code>或<code>POST</code>）</td>
</tr>
<tr>
<td align="center"><code>outcome</code></td>
<td align="center">基于响应状态码的返回值描述，1xx：<code>INFORMATIONAL</code>；2xx：<code>SUCCESS</code>；3xx：<code>REDIRECTION</code>；4xx：<code>CLIENT_ERROR</code>；5xx：<code>SERVER_ERROR</code></td>
</tr>
<tr>
<td align="center"><code>status</code></td>
<td align="center">响应状态码（例如<code>200</code>或<code>500</code>）</td>
</tr>
<tr>
<td align="center"><code>url</code></td>
<td align="center">在变量替换之前使用请求的URI模板(例如，<code>/api/person/&#123;id&#125;</code>)</td>
</tr>
</tbody></table>
<p>如果想添加默认的tag标记，可以提供一个或多个实现了<code>WebMvcTagsContributor</code>的<code>@Bean</code>，如果想替换（上述）tag标记，提供一个实现了<code>WebMvcTagsProvider</code>的<code>@Bean</code></p>
<blockquote>
<p><strong>提示</strong></p>
<p>在某些情况下，控制器和请求处理器内处理的异常并不会以指标tag标记的方式（如上表）被记录。此时，应用程序可以通过<a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.developing-web-applications.spring-mvc.error-handling">将异常设置为请求的属性</a>来确保该异常处理不会被遗漏。</p>
</blockquote>
<h3 id="Spring-WebFlux指标（Spring-WebFlux-Metrics）"><a href="#Spring-WebFlux指标（Spring-WebFlux-Metrics）" class="headerlink" title="Spring WebFlux指标（Spring WebFlux Metrics）"></a>Spring WebFlux指标（Spring WebFlux Metrics）</h3><p>自动装配机制会开启对 Spring WebFlux控制器（Spring WebFlux controllers）和请求处理器（functional handlers）的所有请求的采集。默认情况下，指标的名称前缀为<code> http.server.requests</code>。可以通过设置 <code>management.metrics.web.server.request.metric-name </code>来自定义该前缀。</p>
<p><code>@Controller</code>类和<code>@RequestMapping</code>方法支持<code>@Timed</code>注解（详情参考：[@Timed注解支持（@Timed Annotation Support）](##@Timed注解支持（@Timed Annotation Support）)）。如果不想开启所有的Spring WebFlux请求，可以将<code>management.metrics.web.server.request.autotime.enabled</code>设置为<code>false</code>，而仅使用<code>@Timed</code>注解。</p>
<p>默认情况下，Spring WebFlux相关的指标会被增加如下tag标记：</p>
<table>
<thead>
<tr>
<th align="center">Tag</th>
<th align="center">详情</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>exception</code></td>
<td align="center">当处理请求出现异常时，被抛出的异常类的简短类名</td>
</tr>
<tr>
<td align="center"><code>method</code></td>
<td align="center">请求方法（例如：<code>GET</code>或<code>POST</code>）</td>
</tr>
<tr>
<td align="center"><code>outcome</code></td>
<td align="center">基于响应状态码的返回值描述，1xx：<code>INFORMATIONAL</code>；2xx：<code>SUCCESS</code>；3xx：<code>REDIRECTION</code>；4xx：<code>CLIENT_ERROR</code>；5xx：<code>SERVER_ERROR</code></td>
</tr>
<tr>
<td align="center"><code>status</code></td>
<td align="center">响应状态码（例如<code>200</code>或<code>500</code>）</td>
</tr>
<tr>
<td align="center"><code>url</code></td>
<td align="center">在变量替换之前使用请求的URI模板(例如，<code>/api/person/&#123;id&#125;</code>)</td>
</tr>
</tbody></table>
<p>如果想添加默认的tag标记，可以提供一个或多个实现了<code>WebFluxTagsContributor</code>的<code>@Bean</code>，如果想替换（上述）tag标记，提供一个实现了<code>WebFluxTagsProvider</code>的<code>@Bean</code></p>
<blockquote>
<p><strong>提示</strong></p>
<p>在某些情况下，控制器和请求处理器内处理的异常并不会以指标tag标记的方式（如上表）被记录。此时，应用程序可以通过<a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.developing-web-applications.spring-mvc.error-handling">将异常设置为请求的属性</a>来确保该异常处理不会被遗漏。</p>
</blockquote>
<h3 id="Jersey-Server指标（Jersey-Server-Metrics）"><a href="#Jersey-Server指标（Jersey-Server-Metrics）" class="headerlink" title="Jersey Server指标（Jersey Server Metrics）"></a>Jersey Server指标（Jersey Server Metrics）</h3><p>只要Micrometer的<code>micrometer-jersey2</code>模块在classpath下，自动装配机制会开启所有由Jersey JAX-RS实现的请求。默认情况下，指标的名称前缀为<code> http.server.requests</code>。可以通过设置 <code>management.metrics.web.server.request.metric-name </code>来自定义该前缀。</p>
<p>默认情况下，Jersey server相关的指标会被增加如下tag标记：</p>
<table>
<thead>
<tr>
<th align="center">Tag</th>
<th align="center">详情</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>exception</code></td>
<td align="center">当处理请求出现异常时，被抛出的异常类的简短类名</td>
</tr>
<tr>
<td align="center"><code>method</code></td>
<td align="center">请求方法（例如：<code>GET</code>或<code>POST</code>）</td>
</tr>
<tr>
<td align="center"><code>outcome</code></td>
<td align="center">基于响应状态码的描述，1xx：<code>INFORMATIONAL</code>；2xx：<code>SUCCESS</code>；3xx：<code>REDIRECTION</code>；4xx：<code>CLIENT_ERROR</code>；5xx：<code>SERVER_ERROR</code></td>
</tr>
<tr>
<td align="center"><code>status</code></td>
<td align="center">响应状态码（例如<code>200</code>或<code>500</code>）</td>
</tr>
<tr>
<td align="center"><code>url</code></td>
<td align="center">在变量替换之前使用请求的URI模板(例如，<code>/api/person/&#123;id&#125;</code>)</td>
</tr>
</tbody></table>
<p>如果想自定义这些tag标记，提供一个实现了<code>JerseyTagsProvider</code>接口的<code>@Bean</code>即可</p>
<h3 id="HTTP-Client指标（HTTP-Client-Metrics）"><a href="#HTTP-Client指标（HTTP-Client-Metrics）" class="headerlink" title="HTTP Client指标（HTTP Client Metrics）"></a>HTTP Client指标（HTTP Client Metrics）</h3><p>Spring Boot Actuator提供了对<code>RestTemplate</code>和<code>WebClient</code>的监测管理。不过使用需要通过注入自动装配的builder来创建实例：</p>
<ul>
<li>通过<code>RestTemplateBuilder</code>创建<code>RestTemplate</code></li>
<li>通过<code>WebClient.Builder</code>创建<code>WebClient</code></li>
</ul>
<p>也可以使用自定义的<code>MetricsRestTemplateCustomizer</code>和<code>MetricsWebClientCustomizer</code>实现同相同目的。</p>
<p>默认情况下，指标的名称前缀为<code> http.client.requests</code>，可以通过修改<code>management.metrics.web.client.request.metric-name</code>来自定义该前缀</p>
<p>默认情况下，相关指标会增加如下tag标记：</p>
<table>
<thead>
<tr>
<th align="center">Tag</th>
<th align="center">详情</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>clientName</code></td>
<td align="center">URI的主机地址</td>
</tr>
<tr>
<td align="center"><code>method</code></td>
<td align="center">请求方法（例如：<code>GET</code>或<code>POST</code>）</td>
</tr>
<tr>
<td align="center"><code>outcome</code></td>
<td align="center">基于响应状态码的返回值描述，1xx：<code>INFORMATIONAL</code>；2xx：<code>SUCCESS</code>；3xx：<code>REDIRECTION</code>；4xx：<code>CLIENT_ERROR</code>；5xx：<code>SERVER_ERROR</code></td>
</tr>
<tr>
<td align="center"><code>status</code></td>
<td align="center">正常情况下为HTTP响应状态码（例如<code>200</code>或<code>500</code>），出现I&#x2F;O异常时为<code>IO_ERROR</code>，其他情况为<code>CLIENT_ERROR</code></td>
</tr>
<tr>
<td align="center"><code>url</code></td>
<td align="center">在变量替换之前使用请求的URI模板(例如，<code>/api/person/&#123;id&#125;</code>)</td>
</tr>
</tbody></table>
<p>可以提供一个实现了<code>RestTemplateExchangeTagsProvider</code>或<code>WebClientExchangeTagsProvider</code>接口的<code>@Bean</code>，实现对tag标记的自定义。<code>RestTemplateExchangeTags</code> and <code>WebClientExchangeTags</code>内也包含方便使用的静态函数。</p>
<h3 id="Tomcat指标（-Tomcat-Metrics）"><a href="#Tomcat指标（-Tomcat-Metrics）" class="headerlink" title="Tomcat指标（ Tomcat Metrics）"></a>Tomcat指标（ Tomcat Metrics）</h3><p>当<code>MBeanRegistry</code>注册表被启用时，自动装配机制会开启对Tomcat的监测。默认情况下，<code>MBeanRegistry</code>是关闭的，可以通过将<code>server.tomcat.mbeanregistry.enabled</code>设置为<code>true</code>来开启。</p>
<p>Tomcat指标以<code>tomcat.</code>为前缀。</p>
<h3 id="缓存指标（Cache-Metrics）"><a href="#缓存指标（Cache-Metrics）" class="headerlink" title="缓存指标（Cache Metrics）"></a>缓存指标（Cache Metrics）</h3><p>当应用启动时，自动装配机制会开启所有已生效<code>Caches</code>的监测，并以<code>cache.</code>为前缀。这是基础监测指标的标准化配置（Cache instrumentation is standardized for a basic set of metrics.）。此外，某些缓存专属指标也是生效的。如下缓存库已经被支持：</p>
<ul>
<li>Caffeine</li>
<li>EhCache 2</li>
<li>Hazelcast</li>
<li>Any compliant JCache (JSR-107) implementation</li>
<li>Redis</li>
</ul>
<p>这些指标会被附加两个tag标记，它们分别是以缓存命名的tag，以及实现了<code>CacheManager</code>的bean的名字。</p>
<blockquote>
<p><strong>提示</strong></p>
<p>只有启动时被配置的缓存会被绑定到指标注册表中。对于那些没有在配置中定义的缓存，例如当启动后，实时地或编程方式创建的缓存，则需要显示地进行注册。<code>CacheMetricsRegistrar</code> bean提供了简单易用的注册机制。</p>
</blockquote>
<h3 id="数据源指标（DataSource-Metrics）"><a href="#数据源指标（DataSource-Metrics）" class="headerlink" title="数据源指标（DataSource Metrics）"></a>数据源指标（DataSource Metrics）</h3><p>自动装配会启用对所有可用<code>DataSource</code>对象的监测，这些指标以<code>jdbc.connections</code>为前缀。数据源测量结果以gauges的方式显示连接池内当前活动连接数、空闲连接数、最大连接数和最小连接数。</p>
<p>这些指标也会被附加tag标记，这些tag标记的名字就是<code>DataSource</code> bean的名字。</p>
<blockquote>
<p><strong>提示</strong></p>
<p>默认情况下，对于所有支持的数据源，Spring Boot都提供了元数据（metadata）。如果使用的数据源不支持这个开箱即用的特性，可以额外提供<code>DataSourcePoolMetadataProvider</code>，可以到<code>DataSourcePoolMetadataProvidersConfiguration</code>查看使用示例。</p>
</blockquote>
<h3 id="Hibernate指标（-Hibernate-Metrics）"><a href="#Hibernate指标（-Hibernate-Metrics）" class="headerlink" title="Hibernate指标（ Hibernate Metrics）"></a>Hibernate指标（ Hibernate Metrics）</h3><p>如果<code>org.hibernate:hibernate-micrometer</code>在classpath内，所有生效且开启统计<code>EntityManagerFactory</code>实例都会被监测，指标名为：<code>hibernate</code>。</p>
<p>这些指标也会被附加tag标记，tag标记的名字就是<code>EntityManagerFactory </code> bean的名字。</p>
<p>如果要开启统计功能，JPA属性<code>hibernate.generate_statistics</code>必须要被设置为<code>true</code>，可以通过如下示例将<code>EntityManagerFactory</code>开启：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">jpa:</span></span><br><span class="line">    <span class="attr">properties:</span></span><br><span class="line">      <span class="string">&quot;[hibernate.generate_statistics]&quot;</span><span class="string">:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="Spring-Data-Repository指标（Spring-Data-Repository-Metrics）"><a href="#Spring-Data-Repository指标（Spring-Data-Repository-Metrics）" class="headerlink" title="Spring Data Repository指标（Spring Data Repository Metrics）"></a>Spring Data Repository指标（Spring Data Repository Metrics）</h3><p>自动装配机制会开启Spring Data <code>Repository</code>的所有函数调用的监测。默认情况下，指标名为<code>spring.data.repository.invocations</code>，可以通过<code>management.metrics.data.repository.metric-name</code>对其修改。</p>
<p><code>Repository</code>类及其方法支持<code>@Timed</code>（查看<a href="##@Timed%E6%B3%A8%E8%A7%A3%E6%94%AF%E6%8C%81%EF%BC%88@Timed-Annotation-Support%EF%BC%89">@Timed注解支持</a>了解更多细节）注解。如果不想对所有的<code>Repository</code>调用都开启指标监控，可以将<code>management.metrics.data.repository.autotime.enabled</code>设置为false，并且单独使用<code>@Timed</code>。</p>
<p>默认情况下，<code>Repository</code>相关的指标会被附加如下tag标记：</p>
<table>
<thead>
<tr>
<th align="center">Tag</th>
<th align="center">详情</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>repository</code></td>
<td align="center"><code>Repository</code>的简单类名</td>
</tr>
<tr>
<td align="center"><code>method</code></td>
<td align="center">被调用的<code>Repository</code>方法名</td>
</tr>
<tr>
<td align="center"><code>state</code></td>
<td align="center">状态（<code>SUCCESS</code>, <code>ERROR</code>, <code>CANCELED</code> or <code>RUNNING</code>）</td>
</tr>
<tr>
<td align="center"><code>exception</code></td>
<td align="center">当调用出现异常时，异常类的简单类名</td>
</tr>
</tbody></table>
<p>如果想修改这些默认的tag标记，配置一个实现了<code>RepositoryTagsProvider</code>接口的<code>@Bean</code>。</p>
<h3 id="RabbitMQ指标（RabbitMQ-Metrics）"><a href="#RabbitMQ指标（RabbitMQ-Metrics）" class="headerlink" title="RabbitMQ指标（RabbitMQ Metrics）"></a>RabbitMQ指标（RabbitMQ Metrics）</h3><p>自动装配机制会开启所有可用的<code>RabbitMQ </code>连接的监控，指标名为<code>rabbitmq</code>。</p>
<h3 id="Spring-Integration指标（Spring-Integration-Metrics）"><a href="#Spring-Integration指标（Spring-Integration-Metrics）" class="headerlink" title="Spring Integration指标（Spring Integration Metrics）"></a>Spring Integration指标（Spring Integration Metrics）</h3><p>任何时候，当<code>MeterRegistry</code> bean可用时，Spring Integration会自动提供<a href="https://docs.spring.io/spring-integration/docs/5.5.0/reference/html/system-management.html#micrometer-integration">基于<code>Micrometer</code>的监测支持</a>。并且指标会被发布在<code>spring.integration.</code>下面。</p>
<h3 id="Kafka指标（Kafka-Metrics）"><a href="#Kafka指标（Kafka-Metrics）" class="headerlink" title="Kafka指标（Kafka Metrics）"></a>Kafka指标（Kafka Metrics）</h3><p>自动装配机制会分别为自动装配的消费者工厂（consumer factory）和生产者工厂（producer factory）注册一个 <code>MicrometerConsumerListener</code>和 <code>MicrometerProducerListener</code>。也会为<code>StreamsBuilderFactoryBean</code>注册一个<code>KafkaStreamsMicrometerListener</code>。更多详情，请参考Spring Kafka文档的 <a href="https://docs.spring.io/spring-kafka/docs/2.7.1/reference/html/#micrometer-native">Micrometer原生指标</a>。</p>
<h3 id="MongoDB指标（MongoDB-Metrics）"><a href="#MongoDB指标（MongoDB-Metrics）" class="headerlink" title="MongoDB指标（MongoDB Metrics）"></a>MongoDB指标（MongoDB Metrics）</h3><h4 id="命令指标（Command-Metrics）"><a href="#命令指标（Command-Metrics）" class="headerlink" title="命令指标（Command Metrics）"></a>命令指标（Command Metrics）</h4><p>自动装配机制会为自动装配的<code>MongoClient</code>注册一个<code>MongoMetricsCommandListener</code>。</p>
<p>对于mongoDB driver下的每一条指令，都会创建一个名为<code>mongodb.driver.commands</code>的计时器指标（timer metric）。每个指标默认会附加如下tag标记：</p>
<table>
<thead>
<tr>
<th align="center">Tag</th>
<th align="center">详情</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>command</code></td>
<td align="center">命令的名称</td>
</tr>
<tr>
<td align="center"><code>cluster.id</code></td>
<td align="center">执行命令的monoDB集群的id</td>
</tr>
<tr>
<td align="center"><code>server.address</code></td>
<td align="center">执行命令的mongoDB的的服务器地址</td>
</tr>
<tr>
<td align="center"><code>status</code></td>
<td align="center">命令返回结果（<code>SUCCESS</code>或<code>FAILED</code>中的一个）</td>
</tr>
</tbody></table>
<p>如果想替换默认的指标tag标记，可以定义一个<code>MongoCommandTagsProvider</code> bean，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCommandTagsProviderConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MongoCommandTagsProvider <span class="title function_">customCommandTagsProvider</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomCommandTagsProvider</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想禁用上述命令指标，可以按照如下指令进行设置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">mongo:</span></span><br><span class="line">      <span class="attr">command:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h4 id="连接池指标（Connection-Pool-Metrics）"><a href="#连接池指标（Connection-Pool-Metrics）" class="headerlink" title="连接池指标（Connection Pool Metrics）"></a>连接池指标（Connection Pool Metrics）</h4><p>自动装配机制会为自动装配的<code>MongoClient</code>注册一个<code>MongoMetricsConnectionPoolListener </code>。</p>
<p>连接池会创建如下gauge指标：</p>
<ul>
<li><code>mongodb.driver.pool.size</code>上报当前连接池内的连接数量，包括空闲和使用者的连接。</li>
<li><code>mongodb.driver.pool.checkedout</code>上报连接池内正在使用的连接数量</li>
<li><code>mongodb.driver.pool.waitqueuesize</code>上报连接池等待队列的大小</li>
</ul>
<p>默认情况下，每个指标都会被附加如下tag标记：</p>
<table>
<thead>
<tr>
<th align="center">Tag</th>
<th align="center">详情</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>cluster.id</code></td>
<td align="center">当前连接池对应的monoDB集群的id</td>
</tr>
<tr>
<td align="center"><code>server.address</code></td>
<td align="center">当前连接池对应的monoDB集群的服务器地址</td>
</tr>
</tbody></table>
<p>如果想替换默认的指标tag标记，可以定义一个<code>MongoConnectionPoolTagsProvider</code> bean，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConnectionPoolTagsProviderConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MongoConnectionPoolTagsProvider <span class="title function_">customConnectionPoolTagsProvider</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomConnectionPoolTagsProvider</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想禁用上述连接池指标，可以按照如下指令进行设置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">mongo:</span></span><br><span class="line">      <span class="attr">connectionpool:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="Timed注解支持（-Timed-Annotation-Support）"><a href="#Timed注解支持（-Timed-Annotation-Support）" class="headerlink" title="@Timed注解支持（@Timed Annotation Support）"></a>@Timed注解支持（@Timed Annotation Support）</h3><p><code>io.micrometer.core.annotation</code>包内的<code>@Timed</code>注解可以被上述列出的某些指标支持。一旦被支持，这个注解既可以用在类层级，也可以用在函数层级上。</p>
<p>例如，如下代码展示了这个注解如何监测<code>@RestController</code>类的所有请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Timed</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/api/addresses&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Address&gt; <span class="title function_">listAddress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/api/people&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Person&gt; <span class="title function_">listPeople</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果只想监测某一个请求，可以将注解从类层级移到方法层级上：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/api/addresses&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Address&gt; <span class="title function_">listAddress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/api/people&quot;)</span></span><br><span class="line">    <span class="meta">@Timed</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Person&gt; <span class="title function_">listPeople</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想修改方法层级的指标信息，可以对该注解组合使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Timed</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/api/addresses&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Address&gt; <span class="title function_">listAddress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/api/people&quot;)</span></span><br><span class="line">    <span class="meta">@Timed(extraTags = &#123; &quot;region&quot;, &quot;us-east-1&quot; &#125;)</span></span><br><span class="line">    <span class="meta">@Timed(value = &quot;all.people&quot;, longTask = true)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Person&gt; <span class="title function_">listPeople</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>提示</strong></p>
<p>带有<code>longTask = true</code>的<code>@Timed</code>注解为方法启用一个长时间任务计时器指标（long task timer）。该指标需要单独的名称，并且可以与短时间任务计时器指标进行叠加。（译者注：此处没有说明叠加内容，如何叠加，需要后续进一步研究）</p>
</blockquote>
<h2 id="注册自定义指标（Registering-Custom-Metrics）"><a href="#注册自定义指标（Registering-Custom-Metrics）" class="headerlink" title="注册自定义指标（Registering Custom Metrics）"></a>注册自定义指标（Registering Custom Metrics）</h2><p>如果想注册自定义指标，可以将<code>MeterRegistry</code>注入到自己的组件中，如下面例子所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Dictionary dictionary;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyBean</span><span class="params">(MeterRegistry registry)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dictionary = Dictionary.load();</span><br><span class="line">        registry.gauge(<span class="string">&quot;dictionary.size&quot;</span>, Tags.empty(), <span class="built_in">this</span>.dictionary.getWords().size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要注册的指标需要依赖其他bean，建议使用<code>MeterBinder</code>来注册，如下面的例子所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMeterBinderConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MeterBinder <span class="title function_">queueSize</span><span class="params">(Queue queue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (registry) -&gt; Gauge.builder(<span class="string">&quot;queueSize&quot;</span>, queue::size).register(registry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>MeterBinder</code>可以确保依赖的正确性，并且在指标被检索时，这个bean是可用的。如果经常重复性跨组件或应用监测一组指标，<code>MeterBinder</code>会非常有用。</p>
<blockquote>
<p><strong>提示</strong></p>
<p>默认情况下，所有的<code>MeterBinder</code> bean会自动绑定到由Spring管理的<code>MeterRegistery</code>中。</p>
</blockquote>
<h2 id="自定义特定指标（Customizing-Individual-Metrics）"><a href="#自定义特定指标（Customizing-Individual-Metrics）" class="headerlink" title="自定义特定指标（Customizing Individual Metrics）"></a>自定义特定指标（Customizing Individual Metrics）</h2><p>如果想对特定的<code>Meter</code>实例进行自定义，可用使用<code>io.micrometer.core.instrument.config.MeterFilte</code>接口。</p>
<p>例如，如果想对所有以<code>com.example</code>开头的指标进行自定义：将<code>mytag.region</code>改为<code>mytag.area</code>，可用按照如下示例操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMetricsFilterConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MeterFilter <span class="title function_">renameRegionTagMeterFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> MeterFilter.renameTag(<span class="string">&quot;com.example&quot;</span>, <span class="string">&quot;mytag.region&quot;</span>, <span class="string">&quot;mytag.area&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>提示</strong></p>
<p>默认情况下，所有<code>MeterFilter</code> bean会自动绑定到由Spring管理的<code>MeterRegistery</code>中。要确保将自定义指标注册到由Spring管理的<code>MeterRegistery</code>上，并且在<code>Metrics</code>中不能含有静态函数。而全局的注册表并没有被Spring管理！</p>
</blockquote>
<h4 id="自定义通用Tag标记（Common-Tags）"><a href="#自定义通用Tag标记（Common-Tags）" class="headerlink" title="自定义通用Tag标记（Common Tags）"></a>自定义通用Tag标记（Common Tags）</h4><p>通用Tag标记常用来对诸如主机名（host）、实例名（instance）、地区（region）、集群（stack）等操作环境进行更细粒度的划分。通用Tag标记会被附加到所有的指标上，可以按照如下示例进行配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">tags:</span></span><br><span class="line">      <span class="attr">region:</span> <span class="string">&quot;us-east-1&quot;</span></span><br><span class="line">      <span class="attr">stack:</span> <span class="string">&quot;prod&quot;</span></span><br></pre></td></tr></table></figure>

<p>以上示例中，会分别为每个指标增加两个tag标记：<code>region:us-east-1</code>和<code>stack:prod</code>。</p>
<blockquote>
<p><strong>提示</strong></p>
<p>如果使用Graphite，通用tag标记的顺序非常重要。因为这个方式并不能保证通用tag标记的的属性，Graphite用户请使用<code>MeterFilter</code>的方式。</p>
</blockquote>
<h4 id="精确指标配置（Per-meter-Properties）"><a href="#精确指标配置（Per-meter-Properties）" class="headerlink" title="精确指标配置（Per-meter Properties）"></a>精确指标配置（Per-meter Properties）</h4><p>除了<code>MeterFilter</code>之外，也可以通过配置对每一个指标进行调整。可以在配置中指定指标的名称，所有以该名称为前缀的指标都会被调整。下面示例中，所有以<code>example.remote</code>开头的指标都会被禁用：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">enable:</span></span><br><span class="line">      <span class="attr">example:</span></span><br><span class="line">        <span class="attr">remote:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>如下配置都可以应用到指标的调整：</p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">详情</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>management.metrics.enable</code></td>
<td align="center">是否禁止指标</td>
</tr>
<tr>
<td align="center"><code>management.metrics.distribution.percentiles-histogram</code></td>
<td align="center">是否使用于百分比直方图（Whether to publish a histogram suitable for computing aggregable (across dimension) percentile approximations.）</td>
</tr>
<tr>
<td align="center"><code>management.metrics.distribution.minimum-expected-value</code>, <code>management.metrics.distribution.maximum-expected-value</code></td>
<td align="center">通过设置监测有效范围可以减少直方图中桶的数量（Publish less histogram buckets by clamping the range of expected values.）</td>
</tr>
<tr>
<td align="center"><code>management.metrics.distribution.percentiles</code></td>
<td align="center">需要被统计的百分位数（Publish percentile values computed in your application）</td>
</tr>
<tr>
<td align="center"><code>management.metrics.distribution.slo</code></td>
<td align="center">额外自定义的应用级的直方图（Publish a cumulative histogram with buckets defined by your service-level objectives）</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>译者提示</strong></p>
<ul>
<li>关于上述配置可以参考IBM developerWorks的一篇文章<a href="(https://github.com/labulaka521/ibm_bak/blob/main/ibm_articles/%E4%BD%BF%E7%94%A8Micrometer%E8%AE%B0%E5%BD%95Java%E5%BA%94%E7%94%A8%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87.md)">《使用 Micrometer 记录 Java 应用性能指标》</a>（可惜网站已经关闭，该链接为github的备份）</li>
<li><code>management.metrics.enable</code>是一个map，key为指标ID前缀（最长的优先匹配），value为Boolean</li>
<li><code>management.metrics.distribution.percentiles</code> 代表要统计的百分位数，这是一个map，key为指标ID前缀（最长的优先匹配），value为double型且取值区间为[0,1]的数组，代表某指标要统计的百分位数。百分位数是统计学指标，详情可以参考<a href="https://zh.wikipedia.org/wiki/%E7%99%BE%E5%88%86%E4%BD%8D%E6%95%B0">wikipedia词条</a></li>
<li><code>management.metrics.distribution.slo</code>  针对的是整个应用，而无法针对某一个指标进行单独配置</li>
</ul>
</blockquote>
<p>更多关于<code>percentiles-histogram</code>和<code>percentiles</code>的详情，可以参考micrometer文档的 <a href="https://micrometer.io/docs/concepts#_histograms_and_percentiles">“直方图和百分位数”</a> 。</p>
<h2 id="指标端点（Metrics-Endpoint）"><a href="#指标端点（Metrics-Endpoint）" class="headerlink" title="指标端点（Metrics Endpoint）"></a>指标端点（Metrics Endpoint）</h2><p>Spring Boot提供了一个<code>metrics</code>端点，作为诊断性的目的，可以用来检查应用程序收集到的指标。这个端点默认没有被暴露出来，可以查看<a href="##%E6%9A%B4%E9%9C%B2%E7%AB%AF%E7%82%B9%EF%BC%88Exposing-Endpoints%EF%BC%89">暴露端点（Exposing Endpoints）</a>获得更多细节。</p>
<p><code>/actuator/metrics</code>列出了所有可用的端点的名称，可以通过指定某指标的名称进一步查看更详细信息，例如：<code>/actuator/metrics/jvm.memory.max</code>。</p>
<blockquote>
<p><strong>提示</strong></p>
<p>此处使用的指标名称应该和代码中的名字相匹配，而不是将指标名称进行映射转换后，特定监控系统的指标名称。例如，Prometheus使用的是蛇形命名法，<code>jvm.memory.max</code>会被映射转换成<code>jvm_memory_max</code>。此时，在<code>metrics</code>端点中，仍然应该使用<code>jvm.memory.max</code>。</p>
</blockquote>
<p>可以在查询语句上增加任意数量的查询参数：<code>tag=KEY:VALUE</code>，从而获得某一维度上的详细指标，例如：<code>/actuator/metrics/jvm.memory.max?tag=area:nonheap</code>。</p>
<blockquote>
<p><strong>提示</strong></p>
<p><code>measurements</code>字段是某个指标下所有tag的统计数据的总和，在上面的例子中，这个数据是堆内存中“Code Cache”、“Compressed Class Space”和“Metaspace”各自最大值的总和，如果只想查看“Metaspace”的的最大值，可用在查询语句上增加额外的tag标记：<code>tag=id:Metaspace</code>，例如：<code>/actuator/metrics/jvm.memory.max?tag=area:nonheap&amp;tag=id:Metaspace</code></p>
</blockquote>
<h1 id="审计（Auditing）"><a href="#审计（Auditing）" class="headerlink" title="审计（Auditing）"></a>审计（Auditing）</h1><p>一旦Spring Security被启用，Spring Boot Actuator就有了一个灵活的审计框架可以发布事件（默认情况下，包括“认证成功”（authentication success）、“失败”（failure）和“拒绝访问”（access denied）的异常）。该特性对于报告和实现基于身份验证失败的锁定策略非常有用。</p>
<p>可以通过定义一个<code>AuditEventRepository</code>类型的bean开启审计功能。为了方便用户，Spring Boot内置了一个<code>InMemoryAuditEventRepository</code>。不过它的能力有限，我们建议只在开发环境下使用。至于生产环境，需要创建自己的<code>AuditEventRepository</code>。</p>
<h2 id="自定义审计（Custom-Auditing）"><a href="#自定义审计（Custom-Auditing）" class="headerlink" title="自定义审计（Custom Auditing）"></a>自定义审计（Custom Auditing）</h2><p>如果想自定义安全事件，可以提供自定义的<code>AbstractAuthenticationAuditListener</code>和<code>AbstractAuthorizationAuditListener</code>的实现。</p>
<p>您还可以对自己的业务事件使用审计服务。要做到这一点，可以将<code>AuditEventRepository</code> bean注入到自己的组件中并直接使用它，或者使用<code>Spring ApplicationEventPublisher</code>（实现<code>ApplicationEventPublisherAware</code>接口）发布一个<code>AuditApplicationEvent</code>。</p>
<h1 id="HTTP追踪（HTTP-Tracing）"><a href="#HTTP追踪（HTTP-Tracing）" class="headerlink" title="HTTP追踪（HTTP Tracing）"></a>HTTP追踪（HTTP Tracing）</h1><p>可以在应用中提供一个<code>HttpTraceRepository</code>类型的bean开启HTTP追踪功能。为了方便用户，Spring Boot内置了一个<code>InMemoryHttpTraceRepository </code>用于存储最近100条请求和响应。相比于其他最终方案，默认提供的<code>InMemoryHttpTraceRepository</code>功能有限，我们建议仅在开发环境下使用。对于生产环境，请使用具备生产就绪特性的追踪、观测方案。例如ZipKin或Spring Cloud Sleuth。此外，也可以提供一个自定义的<code>HttpTraceRepository</code>满足业务需求。</p>
<p><code>httptrace</code>端点可以用来获取存储在<code>HttpTraceRepository</code>中的请求响应的信息。</p>
<h2 id="自定义HTTP追踪（Custom-HTTP-tracing）"><a href="#自定义HTTP追踪（Custom-HTTP-tracing）" class="headerlink" title="自定义HTTP追踪（Custom HTTP tracing）"></a>自定义HTTP追踪（Custom HTTP tracing）</h2><p>如果想自定义追踪数据，使用<code>management.trace.http.include</code>。对于更加深入的自定义，可以考虑注册自定义实现的<code>HttpExchangeTracer</code> bean。</p>
<h1 id="进程监控（Process-Monitoring）"><a href="#进程监控（Process-Monitoring）" class="headerlink" title="进程监控（Process Monitoring）"></a>进程监控（Process Monitoring）</h1><p>在Spring Boot中，有两个类可以用来创建文件，这在监控进程时非常有用：</p>
<ul>
<li><code>ApplicationPidFileWriter</code> 可以创建一个包含应用PID的文件（默认情况下，文件位于应用目录，文件名为：<code>application.pid</code>）</li>
<li><code>WebServerPortFileWriter</code>创建一个（或多个）包含当前web服务器的端口的文件</li>
</ul>
<p>这两个类默认是没有被激活，可以通过如下方式将其开启：</p>
<ul>
<li><a href="##%E6%89%A9%E5%B1%95%E9%85%8D%E7%BD%AE%EF%BC%88Extending-Configuration%EF%BC%89">扩展配置</a></li>
<li><a href="##%E7%BC%96%E7%A8%8B%E6%96%B9%E5%BC%8F%E6%94%AF%E6%8C%81%EF%BC%88Programmatically%EF%BC%89">编程方式</a></li>
</ul>
<h2 id="扩展配置（Extending-Configuration）"><a href="#扩展配置（Extending-Configuration）" class="headerlink" title="扩展配置（Extending Configuration）"></a>扩展配置（Extending Configuration）</h2><p>在<code>META-INF/spring.factories</code>中，你可以通过如下方式激活一个或多个监听，从而实现PID文件的写入：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">org.springframework.context.ApplicationListener</span>=<span class="string">\</span></span><br><span class="line"><span class="string">org.springframework.boot.context.ApplicationPidFileWriter,\</span></span><br><span class="line"><span class="string">org.springframework.boot.web.context.WebServerPortFileWriter</span></span><br></pre></td></tr></table></figure>

<h2 id="编程方式支持（Programmatically）"><a href="#编程方式支持（Programmatically）" class="headerlink" title="编程方式支持（Programmatically）"></a>编程方式支持（Programmatically）</h2><p>也可以通过调用<code>SpringApplication.addListeners(…)</code>来激活一个监听器，并传入一个<code>Writer</code>对象，这种方式允许你在<code>Writer</code>的构造函数中自定义文件名、文件路径。</p>
<h1 id="Cloud-Foundry-支持（Cloud-Foundry-Support）"><a href="#Cloud-Foundry-支持（Cloud-Foundry-Support）" class="headerlink" title="Cloud Foundry 支持（Cloud Foundry Support）"></a>Cloud Foundry 支持（Cloud Foundry Support）</h1><p>Spring Boot Actuator对Cloud Foundry提供了额外支持，当应用被部署到兼容的Cloud Foundry实例时，该特性会被激活。<code>/cloudfoundryapplication</code>提供了另外一种到所有端点<code>@Endpoint</code> bean安全路由。</p>
<blockquote>
<p><strong>提示</strong></p>
<p>对于常规用户来说，<code>/cloudfoundryapplication</code>路径不能被直接访问。如果想使用该端点，需要在请求中提供一个UAA令牌（UAA token）。</p>
</blockquote>
<h2 id="禁用Cloud-Foundry-Actuator支持（Disabling-Extended-Cloud-Foundry-Actuator-Support）"><a href="#禁用Cloud-Foundry-Actuator支持（Disabling-Extended-Cloud-Foundry-Actuator-Support）" class="headerlink" title="禁用Cloud Foundry Actuator支持（Disabling Extended Cloud Foundry Actuator Support）"></a>禁用Cloud Foundry Actuator支持（Disabling Extended Cloud Foundry Actuator Support）</h2><p>如果想完全禁用<code>/cloudfoundryapplication</code>端点，可以进行如下配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">cloudfoundry:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h2 id="Cloud-Foundry自签名证书（Cloud-Foundry-Self-signed-Certificates）"><a href="#Cloud-Foundry自签名证书（Cloud-Foundry-Self-signed-Certificates）" class="headerlink" title="Cloud Foundry自签名证书（Cloud Foundry Self-signed Certificates）"></a>Cloud Foundry自签名证书（Cloud Foundry Self-signed Certificates）</h2><p>默认情况下，<code>/cloudfoundry</code>端点的安全认证会对Cloud Foundry服务进行SSL调用。如果您的Cloud Foundry UAA或Cloud Controller服务使用自签名证书，您需要设置以下属性：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">cloudfoundry:</span></span><br><span class="line">    <span class="attr">skip-ssl-validation:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="自定义上下文路径（Custom-Context-Path）"><a href="#自定义上下文路径（Custom-Context-Path）" class="headerlink" title="自定义上下文路径（Custom Context Path）"></a>自定义上下文路径（Custom Context Path）</h2><p>如果服务器的上下文路径并非<code>/</code>，而是其他路径，那么根路径下的Cloud Foundry端点会不可用。例如，对于配置<code>server.servlet.context-path=/app</code>，Cloud Foundry端点路径为：<code>/app/cloudfoundryapplication/*</code>。</p>
<p>如果想实现这个需求：不管服务器的上下文路径如何配置， Cloud Foundry端点的路径都位于：<code>/cloudfoundryapplication/*</code>，需要在应用中进行配置，至于配置方式，根据所使用的web服务器的不同而不尽相同。以Tomcat为例，可以使用如下配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCloudFoundryConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TomcatServletWebServerFactory <span class="title function_">servletWebServerFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TomcatServletWebServerFactory</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">prepareContext</span><span class="params">(Host host, ServletContextInitializer[] initializers)</span> &#123;</span><br><span class="line">                <span class="built_in">super</span>.prepareContext(host, initializers);</span><br><span class="line">                <span class="type">StandardContext</span> <span class="variable">child</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardContext</span>();</span><br><span class="line">                child.addLifecycleListener(<span class="keyword">new</span> <span class="title class_">Tomcat</span>.FixContextListener());</span><br><span class="line">                child.setPath(<span class="string">&quot;/cloudfoundryapplication&quot;</span>);</span><br><span class="line">                <span class="type">ServletContainerInitializer</span> <span class="variable">initializer</span> <span class="operator">=</span> getServletContextInitializer(getContextPath());</span><br><span class="line">                child.addServletContainerInitializer(initializer, Collections.emptySet());</span><br><span class="line">                child.setCrossContext(<span class="literal">true</span>);</span><br><span class="line">                host.addChild(child);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServletContainerInitializer <span class="title function_">getServletContextInitializer</span><span class="params">(String contextPath)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (classes, context) -&gt; &#123;</span><br><span class="line">            <span class="type">Servlet</span> <span class="variable">servlet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericServlet</span>() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">                    <span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> req.getServletContext().getContext(contextPath);</span><br><span class="line">                    context.getRequestDispatcher(<span class="string">&quot;/cloudfoundryapplication&quot;</span>).forward(req, res);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;;</span><br><span class="line">            context.addServlet(<span class="string">&quot;cloudfoundry&quot;</span>, servlet).addMapping(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="接下来要读什么（What-to-Read-Next）"><a href="#接下来要读什么（What-to-Read-Next）" class="headerlink" title="接下来要读什么（What to Read Next）"></a>接下来要读什么（What to Read Next）</h1><p>你可能想读一些关于图形工具的文档，例如Graphite](<a href="https://graphiteapp.org/">https://graphiteapp.org/</a>)</p>
<p>或者，如果想继续深挖，可以阅读<a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/deployment.html#deployment">部署选项</a>相关知识，或者提前了解有关Spring Boot<a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/build-tool-plugins.html#build-tool-plugins">构建工具插件</a>的知识。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.gamedo.org/2021/04/22/%E5%85%B3%E4%BA%8Ehotspot%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%ADCardTable%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%80%E7%82%B9%E7%96%91%E6%83%91%E6%8E%A2%E7%A9%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="临江听雨">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="听雨">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 听雨">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/22/%E5%85%B3%E4%BA%8Ehotspot%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%ADCardTable%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%80%E7%82%B9%E7%96%91%E6%83%91%E6%8E%A2%E7%A9%B6/" class="post-title-link" itemprop="url">关于hotspot虚拟机中CardTable数组的一点疑惑探究</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-22 15:11:00" itemprop="dateCreated datePublished" datetime="2021-04-22T15:11:00+08:00">2021-04-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-12 14:47:53" itemprop="dateModified" datetime="2025-08-12T14:47:53+08:00">2025-08-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E6%B2%89%E6%B7%80/" itemprop="url" rel="index"><span itemprop="name">技术沉淀</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="问题的引出"><a href="#问题的引出" class="headerlink" title="问题的引出"></a>问题的引出</h2><p>今天上午收到之前项目同事发过来的微信留言：</p>
<blockquote>
<p>我看到现在他（指的是《深入理解Java虚拟机：JVM高级特性与最佳实践》作者）还没有解释card table为何一个元素占用1个byte，而不是我理解的1bit</p>
</blockquote>
<p>我们看看该问题的上下文是怎样的，在《深入理解Java虚拟机：JVM高级特性与最佳实践》第三版第3章第3.4.5节中，作者写到：</p>
<blockquote>
<p>卡表最简单的形式可以只是一个字节数组，而HotSpot虚拟机确实也是这样做的。以下这行代 码是HotSpot默认的卡表标记逻辑：</p>
<p>CARD_TABLE [this address &gt;&gt; 9] &#x3D; 0</p>
</blockquote>
<p>此处确实写的是字节数组，那么为什么不是布尔数组呢？经过一番短暂电话沟通和后，我们并没有得出一个明确结论。</p>
<h2 id="问题的排查"><a href="#问题的排查" class="headerlink" title="问题的排查"></a>问题的排查</h2><p>正好最近空闲时间比较多，先去深圳湾体育场打个疫苗，然后按照侯捷大神的名言：源码面前，了无秘密，我倒要看看源码里究竟是怎么实现的。在jdk8中card table的实现类为： <strong><a href="https://github.com/infobip/infobip-open-jdk-8/blob/master/hotspot/src/share/vm/memory/cardTableModRefBS.hpp">cardTableModRefBS</a></strong> ，通过一顿分享后，答案基本清晰，抽取出和本文相关的代码并进行相应的注释：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CardTableModRefBS</span>: <span class="keyword">public</span> ModRefBarrierSet &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Constants</span></span><br><span class="line">  <span class="keyword">enum</span> <span class="title class_">SomePublicConstants</span> &#123;</span><br><span class="line">    card_shift                  = <span class="number">9</span>,</span><br><span class="line">    card_size                   = <span class="number">1</span> &lt;&lt; card_shift,</span><br><span class="line">    card_size_in_words          = card_size / <span class="built_in">sizeof</span>(HeapWord)</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//卡页的状态等相关值，这里很有意思，之所以没用CardStatus，推测是因为这里面的定义不仅仅包含</span></span><br><span class="line">  <span class="comment">//卡页的状态，还有其他维度上的定义，比如标记某卡页为最后一个的：last_card</span></span><br><span class="line">  <span class="keyword">enum</span> <span class="title class_">CardValues</span> &#123;</span><br><span class="line">    <span class="comment">//某卡页是否干净</span></span><br><span class="line">    clean_card                  = <span class="number">-1</span>,</span><br><span class="line">    <span class="comment">// The mask contains zeros in places for all other values.</span></span><br><span class="line">    clean_card_mask             = clean_card - <span class="number">31</span>,</span><br><span class="line"></span><br><span class="line">    dirty_card                  =  <span class="number">0</span>,</span><br><span class="line">    precleaned_card             =  <span class="number">1</span>,</span><br><span class="line">    claimed_card                =  <span class="number">2</span>,</span><br><span class="line">    deferred_card               =  <span class="number">4</span>,</span><br><span class="line">    last_card                   =  <span class="number">8</span>,</span><br><span class="line">    CT_MR_BS_last_reserved      = <span class="number">16</span></span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//封装了上述枚举值</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">clean_card_val</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> clean_card; &#125;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">clean_card_mask_val</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> clean_card_mask; &#125;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">dirty_card_val</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> dirty_card; &#125;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">claimed_card_val</span><span class="params">()</span>    </span>&#123; <span class="keyword">return</span> claimed_card; &#125;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">precleaned_card_val</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> precleaned_card; &#125;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">deferred_card_val</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> deferred_card; &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//本卡表所管理的堆内存区域</span></span><br><span class="line">  <span class="type">const</span> MemRegion _whole_heap;       <span class="comment">// the region covered by the card table</span></span><br><span class="line">  <span class="comment">//卡表数组的长度（也即堆内存中内存块的个数，每一个内存块的大小为：2^card_shift = 2^9 = 256字节）</span></span><br><span class="line">  <span class="type">size_t</span>          _byte_map_size;    <span class="comment">// in bytes</span></span><br><span class="line">  <span class="comment">//卡表数组</span></span><br><span class="line">  jbyte*          _byte_map;         <span class="comment">// the card marking array</span></span><br><span class="line">  <span class="comment">//关键点1：</span></span><br><span class="line">  <span class="comment">//原注释翻译：卡表数组相对于堆内存起始位置基址的偏移，</span></span><br><span class="line">  <span class="comment">//如果堆的首地址为0x0，那么这将是_byte_map的第0个元素。而实际上，堆是从某个较高的地址开始的，</span></span><br><span class="line">  <span class="comment">//因此该指针实际上指向了_byte_map数组前面的某个位置</span></span><br><span class="line">  <span class="comment">//上面这么直接翻译实在难以理解，一语道破：hotspot在实现堆内存和卡表数组之间相互寻址时，和8086/8088中</span></span><br><span class="line">  <span class="comment">//的寄存器相对寻址方式极其相似！（甚至说原理上是完全一致的）该寻址的方式为：</span></span><br><span class="line">  <span class="comment">//有效地址 = 基址寄存器 + 偏移量，变换成公式为：EA = BX/BP + 8位或16位位移量</span></span><br><span class="line">  <span class="comment">//而此处的byte_map_base正是公式中的偏移量，更详细解释参考下面的初始化函数：initialize中的注释</span></span><br><span class="line">  <span class="comment">// Card marking array base (adjusted for heap low boundary)</span></span><br><span class="line">  <span class="comment">// This would be the 0th element of _byte_map, if the heap started at 0x0.</span></span><br><span class="line">  <span class="comment">// But since the heap starts at some higher address, this points to somewhere</span></span><br><span class="line">  <span class="comment">// before the beginning of the actual _byte_map.</span></span><br><span class="line">  jbyte* byte_map_base;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">CardTableModRefBS::initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//找到所管理的堆内存的起始和结束位置</span></span><br><span class="line">    HeapWord* low_bound  = _whole_heap.<span class="built_in">start</span>();</span><br><span class="line">    HeapWord* high_bound = _whole_heap.<span class="built_in">end</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为卡表数组申请堆内存</span></span><br><span class="line">    <span class="function">ReservedSpace <span class="title">heap_rs</span><span class="params">(_byte_map_size, rs_align, <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将base()返回的地址作为数组地址（数组的地址就是数组首元素的地址）（推测base()应该代表这块堆内存的首地址）</span></span><br><span class="line">    _byte_map = (jbyte*) heap_rs.<span class="built_in">base</span>();</span><br><span class="line">    <span class="comment">//关键点2：</span></span><br><span class="line">    <span class="comment">//下面这行代码中，uintptr_t(low_bound) &gt;&gt; card_shift的含义是：计算堆起始位置的基址（并且间隔为256个字节）</span></span><br><span class="line">    <span class="comment">//而整个表达式的含义是：计算卡表数组地址到堆起始位置基址的偏移</span></span><br><span class="line">    <span class="comment">//当我们把这个表达式切换一下：_byte_map = (uintptr_t(low_bound) &gt;&gt; card_shift) + byte_map_base;</span></span><br><span class="line">    <span class="comment">//那么表达的含义是：给定任意的堆内存地址p，它映射到卡表数组中的地址都可以用自己的基址加上byte_map_base算出来，</span></span><br><span class="line">    <span class="comment">//即：(uintptr_t(p) &gt;&gt; card_shift) + byte_map_base，也即：byte_map_base[(uintptr_t(p) &gt;&gt; card_shift)]</span></span><br><span class="line">    <span class="comment">//而这正是byte_for函数的实现</span></span><br><span class="line">    byte_map_base = _byte_map - (<span class="built_in">uintptr_t</span>(low_bound) &gt;&gt; card_shift);</span><br><span class="line">    <span class="comment">//断言：堆内存的起始位置和结束位置应该都在卡表数组内</span></span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">byte_for</span>(low_bound) == &amp;_byte_map[<span class="number">0</span>], <span class="string">&quot;Checking start of map&quot;</span>);</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">byte_for</span>(high_bound<span class="number">-1</span>) &lt;= &amp;_byte_map[_last_valid_index], <span class="string">&quot;Checking end of map&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//计算任意堆内存地址映射到卡表数组的地址</span></span><br><span class="line">  <span class="comment">// Mapping from address to card marking array entry</span></span><br><span class="line">  <span class="function">jbyte* <span class="title">byte_for</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* p)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(_whole_heap.<span class="built_in">contains</span>(p),</span><br><span class="line">           <span class="built_in">err_msg</span>(<span class="string">&quot;Attempt to access p = &quot;</span>PTR_FORMAT<span class="string">&quot; out of bounds of &quot;</span></span><br><span class="line">                   <span class="string">&quot; card marking array&#x27;s _whole_heap = [&quot;</span>PTR_FORMAT<span class="string">&quot;,&quot;</span>PTR_FORMAT<span class="string">&quot;)&quot;</span>,</span><br><span class="line">                   <span class="built_in">p2i</span>(p), <span class="built_in">p2i</span>(_whole_heap.<span class="built_in">start</span>()), <span class="built_in">p2i</span>(_whole_heap.<span class="built_in">end</span>())));</span><br><span class="line">    <span class="comment">//这个表达式实际上就是上面initialize中分析的结果</span></span><br><span class="line">    jbyte* result = &amp;byte_map_base[<span class="built_in">uintptr_t</span>(p) &gt;&gt; card_shift];</span><br><span class="line">    <span class="built_in">assert</span>(result &gt;= _byte_map &amp;&amp; result &lt; _byte_map + _byte_map_size,</span><br><span class="line">           <span class="string">&quot;out of bounds accessor for card marking array&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//计算任意堆内存地址到卡表数组的索引</span></span><br><span class="line">  <span class="comment">// Mapping from address to card marking array index.</span></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">index_for</span><span class="params">(<span class="type">void</span>* p)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(_whole_heap.<span class="built_in">contains</span>(p),</span><br><span class="line">           <span class="built_in">err_msg</span>(<span class="string">&quot;Attempt to access p = &quot;</span>PTR_FORMAT<span class="string">&quot; out of bounds of &quot;</span></span><br><span class="line">                   <span class="string">&quot; card marking array&#x27;s _whole_heap = [&quot;</span>PTR_FORMAT<span class="string">&quot;,&quot;</span>PTR_FORMAT<span class="string">&quot;)&quot;</span>,</span><br><span class="line">                   <span class="built_in">p2i</span>(p), <span class="built_in">p2i</span>(_whole_heap.<span class="built_in">start</span>()), <span class="built_in">p2i</span>(_whole_heap.<span class="built_in">end</span>())));</span><br><span class="line">    <span class="comment">//先计算该地址映射到卡表数组内的位置，然后再减去卡表数组的地址（也即数组首元素的地址），就是相对于数组地址的</span></span><br><span class="line">    <span class="comment">//偏移，也即数组索引</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">byte_for</span>(p) - _byte_map;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//某个卡页是否脏了</span></span><br><span class="line">  <span class="comment">// These are used by G1, when it uses the card table as a temporary data</span></span><br><span class="line">  <span class="comment">// structure for card claiming.</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">is_card_dirty</span><span class="params">(<span class="type">size_t</span> card_index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _byte_map[card_index] == <span class="built_in">dirty_card_val</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="问题的结论"><a href="#问题的结论" class="headerlink" title="问题的结论"></a>问题的结论</h2><p>通过源码分析可知，被管理的堆中每一个内存地址都可以被映射到卡表数组中，而实际上不需要精细到每一个内存都做映射，这将导致极大的内存浪费，因此hotspot将每256个字节划分为一块内存（为这块内存取个好听的名字：卡页），这一块内存都映射到数组的某个元素上，而实际上每一个卡页不仅仅只有脏（dirty_card）和干净（clean_card）两种状态，还包括其他状态，例如：precleaned_card、claimed_card、deferred_card等，至于这些状态的含义嘛，这又是另外一篇博客的事情了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.gamedo.org/2021/04/06/spring%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="临江听雨">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="听雨">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 听雨">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/06/spring%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">spring启动流程分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-06 17:50:00" itemprop="dateCreated datePublished" datetime="2021-04-06T17:50:00+08:00">2021-04-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-12 14:47:53" itemprop="dateModified" datetime="2025-08-12T14:47:53+08:00">2025-08-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E6%B2%89%E6%B7%80/" itemprop="url" rel="index"><span itemprop="name">技术沉淀</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>简述一下spring的启动流程，省得每次都要翻看源码，流程图如下所示：</p>
<p><img src="https://ftp.bmp.ovh/imgs/2021/04/345bfc3224ead227.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">SpringApplication-&gt;SpringApplication#SpringApplication: 1-构造函数</span><br><span class="line">SpringApplication#SpringApplication-&gt;SpringApplication#SpringApplication: 检测服务器类型</span><br><span class="line">SpringApplication#SpringApplication-&gt;SpringApplication#SpringApplication: 2-META-INF/spring.factories</span><br><span class="line">SpringApplication#SpringApplication-&gt;SpringApplication#SpringApplication: 3-实例化初始化器、监听器等</span><br><span class="line">SpringApplication#SpringApplication-&gt;SpringApplication:</span><br><span class="line">SpringApplication-&gt;SpringApplication#run:</span><br><span class="line">SpringApplication#run-&gt;DefaultBootstrapContext: new DefaultBootstrapContext()</span><br><span class="line">SpringApplication#run-&gt;SpringApplicationRunListener:starting</span><br><span class="line">SpringApplication#run-&gt;SpringApplication#run:prepareEnvironment</span><br><span class="line">SpringApplication#run-&gt;SpringApplicationRunListener:environmentPrepared</span><br><span class="line">SpringApplication#run-&gt;AbstractApplicationContext:createApplicationContext</span><br><span class="line">SpringApplication#run-&gt;SpringApplication#run:4-prepareContext</span><br><span class="line">SpringApplication#run-&gt;ApplicationContextInitializer:5-initialize(ConfigurableApplicationContext applicationContext)</span><br><span class="line">SpringApplication#run-&gt;SpringApplicationRunListener:contextPrepared</span><br><span class="line">SpringApplication#run-&gt;SpringApplication#run:load</span><br><span class="line">SpringApplication#run-&gt;SpringApplicationRunListener:contextLoaded</span><br><span class="line">SpringApplication#run-&gt;AbstractApplicationContext:refresh</span><br><span class="line">AbstractApplicationContext-&gt;AbstractApplicationContext: prepareBeanFactory</span><br><span class="line">AbstractApplicationContext-&gt;AbstractApplicationContext: 6-invokeBeanFactoryPostProcessors</span><br><span class="line">AbstractApplicationContext-&gt;AbstractApplicationContext: XXX一大堆东西，偷懒不写，改天补上</span><br><span class="line">SpringApplication#run-&gt;SpringApplicationRunListener:started</span><br><span class="line">SpringApplication#run-&gt;SpringApplication#run:7-callRunners</span><br></pre></td></tr></table></figure>

<p>对于上图的解释：</p>
<ul>
<li>1-SpringApplication(ResourceLoader, Class&lt;?&gt;[])</li>
<li>2-读取classpath下所有jar包内META-INF&#x2F;spring.factories文件</li>
<li>3-实例化：Bootstrapper、ApplicationContextInitializer、ApplicationListener</li>
<li>5-这一步的最佳实践是：调用入参applicationContext的addBeanFactoryPostProcessor函数，也即注册自定义的BeanFactoryPostProcessor</li>
<li>6-这一步中，会遍历AbstractApplicationContext内的列表：beanFactoryPostProcessors，并且当且仅当某一个BeanFactoryPostProcessor同时还是BeanDefinitionRegistryPostProcessor时，才会执行BeanDefinitionRegistryPostProcessor#postProcessBeanDefinitionRegistry，这两个接口的继承关系如图所示（beanFactoryPostProcessors列表的添加时机可以看上面第5步）：</li>
</ul>
<p><img src="https://ftp.bmp.ovh/imgs/2021/04/d222851e2b7a29ce.png"></p>
<ul>
<li>7-先调用所有的ApplicationRunner，再调用所有的CommandLineRunner</li>
</ul>
<p>至于spring bean生命周期，直接摘抄官网文档（来源：<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/BeanFactory.html">spring docs</a>）：</p>
<ol>
<li>BeanNameAware’s setBeanName</li>
<li>BeanClassLoaderAware’s setBeanClassLoader</li>
<li>BeanFactoryAware’s setBeanFactory</li>
<li>EnvironmentAware’s setEnvironment</li>
<li>EmbeddedValueResolverAware’s setEmbeddedValueResolver</li>
<li>ResourceLoaderAware’s setResourceLoader (only applicable when running in an application context)</li>
<li>ApplicationEventPublisherAware’s setApplicationEventPublisher (only applicable when running in an application context)</li>
<li>MessageSourceAware’s setMessageSource (only applicable when running in an application context)</li>
<li>ApplicationContextAware’s setApplicationContext (only applicable when running in an application context)</li>
<li>ServletContextAware’s setServletContext (only applicable when running in a web application context)</li>
<li>postProcessBeforeInitialization methods of BeanPostProcessors</li>
<li>InitializingBean’s afterPropertiesSet</li>
<li>a custom init-method definition</li>
<li>postProcessAfterInitialization methods of BeanPostProcessors</li>
</ol>
<p>当bean factory关闭时，如下生命周期函数将被调用：</p>
<ol>
<li>postProcessBeforeDestruction methods of DestructionAwareBeanPostProcessors</li>
<li>DisposableBean’s destroy</li>
<li>a custom destroy-method definition</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.gamedo.org/2021/04/01/%E5%83%8F%E7%B4%A0%E7%94%BB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="临江听雨">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="听雨">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 听雨">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/01/%E5%83%8F%E7%B4%A0%E7%94%BB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">像素画学习笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-01 20:00:00" itemprop="dateCreated datePublished" datetime="2021-04-01T20:00:00+08:00">2021-04-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-12 14:47:53" itemprop="dateModified" datetime="2025-08-12T14:47:53+08:00">2025-08-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%B8%B8%E6%88%8F%E4%BA%BA%E7%94%9F/" itemprop="url" rel="index"><span itemprop="name">游戏人生</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li><p>给出了画出干净的曲线轮廓的方法：不管是垂直方向还是水平方向上的像素，其过渡是渐进的，例如一个干净的倒角的曲线中（如<a href="https://www.deviantart.com/rhlpixels/art/Clean-Lines-Tutorial-759260186">本文</a>中第4个对话气泡中的曲线），垂直方向的像素个数分别是：4、3、2、1、2、3、4，另外一个曲线举例（如<a href="https://www.deviantart.com/rhlpixels/art/Clean-Lines-Tutorial-759260186">本文</a>中第5个对话气泡中的曲线）：5、4、4、3、2、2、1、1、1、1、1，也就是说前后两个像素不能出现大的跳跃（来源：<a href="https://www.deviantart.com/rhlpixels">RHLPixels的像素画教程</a>）。</p>
</li>
<li><p>对于IsoMetric风格正方体上方的菱形，顶部和底部的角使用3个像素，这样的情况下，两个角之间的棱线就可以画在中间像素上了，详情可以参考<a href="https://www.deviantart.com/rhlpixels/art/Isometric-Tutorial-535600679">本文</a>的第4段描述（来源：<a href="https://www.deviantart.com/rhlpixels/art/Isometric-Tutorial-535600679">RHLPixels的像素画教程</a></p>
</li>
<li><p>Isometric风格人物的其他的Isometric风格的原则一样（来源：<a href="https://www.deviantart.com/rhlpixels/art/Isometric-Peoples-822662906">RHLPixels的像素画教程</a>）：</p>
<ul>
<li>水平线和垂直线保持2:1像素的坡度</li>
<li>有3个面可以被看到，因此头顶、肩膀都要画出厚度</li>
</ul>
</li>
<li><p>颜色渐变技巧：一个分成5个色带，左右两侧为分别为纯色A和纯色B，中间色带为A和B混合后的纯色X，左侧第2个色带为A和X的抖动颜色，右侧第2个色带为B和X的抖动颜色（来源：<a href="https://www.deviantart.com/rhlpixels/art/Bridging-colors-together-822662695">RHLPixels的像素画教程</a>）</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.gamedo.org/2021/03/27/Pixels%20and%20voxels,%20the%20long%20answer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="临江听雨">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="听雨">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 听雨">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/27/Pixels%20and%20voxels,%20the%20long%20answer/" class="post-title-link" itemprop="url">像素和体素，Quora上的超长解答（翻译完毕）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-27 14:20:00" itemprop="dateCreated datePublished" datetime="2021-03-27T14:20:00+08:00">2021-03-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-12 14:47:53" itemprop="dateModified" datetime="2025-08-12T14:47:53+08:00">2025-08-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%B8%B8%E6%88%8F%E4%BA%BA%E7%94%9F/" itemprop="url" rel="index"><span itemprop="name">游戏人生</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>本文翻译自：<a href="https://medium.com/retronator-magazine/pixels-and-voxels-the-long-answer-5889ecc18190">Pixels and voxels, the long answer</a>（已获得作者翻译许可），原文作者：<a href="https://medium.com/@retronator">Matej ‘Retro’ Jan</a></p>
</blockquote>
<hr>
<p>今年早些时候，有人在<a href="https://www.quora.com/What-is-the-difference-between-pixel-and-voxel">Quora</a>上问：</p>
<blockquote>
<p><em>像素和体素有什么区别？</em></p>
</blockquote>
<p>这个问题很让人抓狂，相比于给出直接答案，最终我写了一篇关于这个主题的文章。</p>
<p>我能想到提问者为什么会问这个问题。因为我们经常会看到一些像素电影海报之类的东西，这会让人很困惑。这是一个像素画呢，还是一副体素画呢？这是画的一只鸟呢，还是一架飞机呢？所有的这些疑问都会吧我们搞得非常狼狈。</p>
<p><img src="https://miro.medium.com/max/1000/1*LNBHCTyTdmGiDc-bTGUwsA.jpeg"></p>
<center><font size=2>我仍然无法决定是处于对怀旧游戏的热爱，（导致）我应该去看这部电影还是绝对<b>不</b>看这部电影。</font></center>

<p>不用担心，你马上就会解脱了。当你读完这篇文章的时候，你就会知道关于像素、体素以及两者之间的一切。不过不用不着急，我们先吃块饼干。</p>
<p>(这是一篇很长的文章，但我保证：你的阅读体验就像是在翻阅《Retronator》杂志，因为图片要远远多于文字。)</p>
<hr>
<p>我们先铺垫一点背景知识，这样就能了解全貌。在计算机中表示图形主要有两种方法：矢量图和光栅图（译者注：也称作位图，以下统称为光栅图）。</p>
<p><img src="https://miro.medium.com/max/575/1*1AWhdKTlJVftXJUA3LCPUw.gif"></p>
<center><font size=2>矢量图的数学精度（左）和光栅图的离散性（右）。</font></center>

<p>矢量图通过数学方程式描述图像，通常用直线，曲线和形状等形式表示。相反，光栅图通过一组颜色描述图像，这些颜色被连续地放置在一个个网格中。</p>
<p>在计算机图形学中的第二个区别是2D和3D空间上的表现。如果包含矢量图与光栅图在内，一共可以得到四个象限：</p>
<p><img src="https://miro.medium.com/max/575/1*UCXcMq6rXDhmG1eI9dcYuQ.png"></p>
<center><font size=2>每个人都喜欢象限</font></center>

<h1 id="矢量图"><a href="#矢量图" class="headerlink" title="矢量图"></a>矢量图</h1><p>在2D矢量图中，直线或图形上的每个点都用一个包含两个分量（x和y）的矢量来描述。这就是为什么它是2D的（两个分量也即是二维）。</p>
<p><img src="https://miro.medium.com/max/700/1*2KZTAXHLcJeM5cCBWtkiTA.gif"></p>
<center><font size=2>这就是二维向量描述二维向量图形中所有点的方式。</font></center>

<p>下面是一个被称为低多边形二维矢量图像的例子。</p>
<p><img src="https://miro.medium.com/max/640/1*HpaeVwfgDiC9W33XNqJEtw.jpeg"></p>
<center><font size=2>Uluru the Mighty Dreamer, Anh Tran, 2015</font></center>

<p>它完全由2D多边形（在本例中为三角形）构成。术语“低多边形”是指用于制作图像的多边形数量相对较少。这使得三角形很容易被观察到。</p>
<p>现在我们添加一个维度。在3D矢量图中，原理是相同的，但是每个矢量使用三个分量（x, y和z）。</p>
<p>让我们看一下3D低多边形的作品。</p>
<p><img src="https://miro.medium.com/max/700/1*5fUTsAJEcnHlsaqYxCZBow.jpeg"></p>
<center><font size=2>Racetrack iOS Game Concept, Timothy J. Reynolds, 2013</font></center>

<p>上面的艾尔斯岩（Ayers Rock）的2D图像与此处的3D赛道之间的最大区别是：可以从我们需要的任何位置查看赛道。</p>
<p><img src="https://miro.medium.com/max/1240/1*h9mP97QFjtz0LcQSib1qgw.png"></p>
<center><font size=2>Racetrack iOS Game Concept, Timothy J. Reynolds, 2013</font></center>

<p>为了在屏幕（2D表面）上显示跑道，我们必须选择一个特定的视点并将3D几何体从该视点投影到2D。</p>
<p><img src="https://miro.medium.com/max/546/1*vfDeX9HH5TGwY2cgyBuuFA.png"></p>
<center><font size=2>从3D到2D的转换称为投影</font></center>

<p>这也是我们获取一张特定角度2D图像的方式。</p>
<p>但是，即使在2D中，我们也可以使用一个技巧来展示3D物体具有的体积特性——我们可以制作一个动画，围绕物体移动视点（或保持视点不变的同时旋转物体本身，如下所示）。</p>
<p><img src="https://miro.medium.com/max/500/1*XnHTPnDMHpgMcN36efrJIQ.gif"></p>
<center><font size=2>Wagon, Timothy J. Reynolds, 2013</font></center>

<p>耶，我们可以看到它确实是3D的，并不需要3D眼镜！</p>
<h1 id="光栅图"><a href="#光栅图" class="headerlink" title="光栅图"></a>光栅图</h1><p>刚刚只是一个热身。搞定矢量图后，我们看看光栅图如何处理2D和3D。</p>
<p>在2D光栅图中，图像被分成若干大小相等的行和列：</p>
<p><img src="https://miro.medium.com/max/700/1*k-UfoL3tcZCwGNSEmNUPOQ.png"></p>
<center><font size=2>Turbo Esprit Sprite, Matej ‘Retro’ Jan, 2014</font></center>

<p>每个单元格称为像素（来自于图像中的一个元素）。除了包含在网格（x，y）内的2D坐标外，每个像素的主要属性是位于该坐标上的颜色。</p>
<p>我们已经看到了低多边形矢量作品如何使用众多的多边形。如果我们在光栅图中做同样的操作（使用大量像素），我们将获得像素风格作品。</p>
<p><img src="https://miro.medium.com/max/700/1*MTwKdk_Abppft-SYKBCi3g.png"></p>
<center><font size=2>Turbo Esprit Sprite, Matej ‘Retro’ Jan, 2014</font></center>

<p>对于2D像素作品，即使它们试图表示三维对象(Lotus Esprit或X-wing)，它们也会直接绘制到2D像素网格上。你不能像上面的3D旅行车那样旋转这个图像。同样，文章开头的艾尔斯岩（Ayers Rock）图像也不能旋转。尽管它是由多边形构成的，但它们不是被放置在3D空间，而是直接放置在2D空间。</p>
<hr>
<p>到目前为止，我们已经介绍了2D和3D矢量图以及2D光栅图。最后一步是3D光栅图。</p>
<p><img src="https://miro.medium.com/max/575/1*W_DR0YFtog8zbqiGJy0VsQ.png"></p>
<center><font size=2>前方就是激动人心的时刻！</font></center>

<p>在3D光栅图中，整个体块被均匀地划分成行和列，覆盖所有三个不同的方向（上下、左右、内外）。这将三维空间划分为一个个小立方体，也称为体素（体块元素或体积像素）。每个体素由3D坐标和颜色定义。</p>
<p>就像像素作品（这是一种精心布局的像素艺术）一样，现在我们有了体素作品，每个立方体的设计都经过了仔细的考虑。</p>
<p><img src="https://miro.medium.com/max/700/1*dUgTNounfrnvMlbN0qDp7Q.jpeg"></p>
<center><font size=2>星际大战场景，@Sir_Carma，2015年</font></center>

<p>这很像乐高积木，你不觉得吗?</p>
<p>需要指出的是，因为是在3D空间中，体素也可以从任何角度被观察。下面是对体素塔图因（译者注：塔图因是《星球大战》中天行者家族的故乡行星）另外一个视角的观察：</p>
<p><img src="https://miro.medium.com/max/1920/1*p-eu_ozx6toxlNr7Bgj1RA.jpeg"></p>
<center><font size=2>星球大战场景（另一个视角），@Sir_Carma，2015</font></center>

<p>我们甚至可以做成动画！以下是 <a href="https://twitter.com/Sir_carma">Sir Carma</a>的一个体素动画角色：</p>
<p><img src="https://miro.medium.com/max/552/1*1_odYAqzEskdqVEIAJ5KAw.gif"></p>
<center><font size=2>骑士奔跑，Sir_Carma，2015年</font></center>

<p>与2D像素角色进行比较：</p>
<p><img src="https://miro.medium.com/max/600/1*aUXEUMD82iRPsoZFOP4F7Q.gif"></p>
<center><font size=2>Final Element中的精灵，Glauber Kotaki，2015年</font></center>

<p>你可以看到在体素作品中，动画是如何改变每个小立方体——体素的状态（颜色），而在像素作品中，颜色的变化是发生在小正方形也即像素上。</p>
<p>现在你知道像素和体素之间的区别了（其实还有更多……哈哈，抱歉）。</p>
<p>但是现在还不是停下来的时候。我之所以解释了矢量图&#x2F;光栅图，2D&#x2F;3D特性，是因为在现代显示器上，每种图形最终都最终显示为2D光栅图。</p>
<p><img src="https://miro.medium.com/max/575/1*nK5jyQku62k7clN79dAPZA.png"></p>
<p>我们在像素作品杂志中讨论这一点原因是，我们可以利用这些类型变换，使用非像素风格的资源创建现代风格的像素作品。</p>
<p>你可能会说：“我可以用体素或3D模型制作像素作品？当然可以！巧妙的着色和渲染技术使我们能够创建独特的视觉风格，从而将像素艺术作品带入未来。</p>
<h1 id="矢量图显示和投影"><a href="#矢量图显示和投影" class="headerlink" title="矢量图显示和投影"></a>矢量图显示和投影</h1><p>上面的图表并不完全正确。有一种方法可以直接显示2D矢量图作品，不过有一点需要注意。</p>
<p><img src="https://miro.medium.com/max/332/1*AjAzSEXeSHJYcXBwQW0iAA.png"></p>
<p>当你有一个2D矢量图像时，它只能直接显示在<a href="https://en.wikipedia.org/wiki/Vector_monitor">矢量显示器</a>上，如雅达利的街机游戏《Asteroids》所使用的显示器。</p>
<p><img src="https://miro.medium.com/max/2048/1*VUHZOtYo8MMc2iJ8kobd4A.png"></p>
<p>以下是它的实际效果（游戏邦注:这是一款在示波器上显示的类似于《asteroids》的游戏）：</p>
<p><img src="https://miro.medium.com/max/4366/1*fcnzkM8n40AOTNxI_iJUzA.jpeg"></p>
<center><font size=2>Space Rocks (game), Autopilot, via Wikimedia Commons [CC BY-SA 3.0]</font></center>

<p>我们也可以用这种方式显示3D矢量图像（通常称为3D模型）。</p>
<p>如前所述，3D模型首先需要投影到2D，从而生成可以在矢量显示器上显示的2D矢量图像。</p>
<p><img src="https://miro.medium.com/max/700/1*74Mg1rbGYUuZ7qaoOyZCFg.jpeg"></p>
<center><font size=2>VEC9, Andrew Reitano & Todd Bailey, 2013</font></center>

<p>我强烈建议看一看VEC9的预告片，也要看大量的80年代的恶搞电影：</p>
<iframe width="663" height="382" src="https://www.youtube.com/embed/rSPixmsLfn4" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<h1 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h1><p>如今，您很难在博物馆外找到矢量监视器。取而代之的是，我们使用由像素组成的显示器！</p>
<p><img src="https://miro.medium.com/max/700/1*wYoC9rszSi9e1h27YygTXQ.jpeg"></p>
<center><font size=2>RGB LCD, Luís Flávio Loureiro dos Santos, 图片来源：<a href=https://commons.wikimedia.org/wiki/File%3ALCD_RGB.jpg>Wikimedia Commons</a> [CC BY 3.0]</font></center>

<p>现代LCD显示器通过打开和关闭（或介于两者之间）红色，绿色和蓝色元素来创建不同的颜色。这和在CRT（阴极射线管）时代的原理很类似，只是他们使用了三种不同类型的荧光粉类型，当受到电子束撞击时发出的是红色，绿色或蓝色的光。</p>
<p><img src="https://miro.medium.com/max/700/1*UVsI_BkS2jdH4vKBEiKvoQ.png"></p>
<center><font size=2>CRT phosphor dots, 图片来源：<a href=https://en.wikipedia.org/wiki/File:CRT_phosphor_dots.png>Wikimedia Commons</a> [CC-SA]</font></center>

<p>那么，如果我们有一个矢量图像，并且只有一个光栅显示器来显示它，我们该怎么办呢？从2D矢量图像到2D光栅图，需要对图形进行渲染或光栅化。每个多边形（通常是三角形）被渲染成到一个像素网格中。</p>
<p><img src="https://miro.medium.com/max/626/1*9faDWqdHY4h_DJMMeZK08A.gif"></p>
<center><font size=2>使用采样进行光栅化, 幻灯片来源：<a href=http://acko.net/files/fullfrontal/fullfrontal/webglmath/online.html>Making WebGL Dance</a>, Steven Wittens, 2013</font></center>

<p>这种机制可以扩展到在光栅显示器上渲染3D模型。首先，将3D三角形投影到2D三角形中。然后二维矢量三角形被光栅化为像素。</p>
<p><img src="https://miro.medium.com/max/498/1*IQ9AeaxAzVnUBwobDt4b5A.gif"></p>
<center><font size=2>星际火狐，任天堂 1993</center>

<h1 id="三角测量"><a href="#三角测量" class="headerlink" title="三角测量"></a>三角测量</h1><p>那么体素要如何处理呢？如今最常见的方法是将每个体素表示为3D矢量立方体。我们通过创建一个沿体素立方体边缘放置三角形的3D模型来做到这一点。</p>
<p><img src="https://miro.medium.com/max/398/1*HBSWaBxOr1OYVtZ6cqDlUg.gif"></p>
<center><font size=2>世界上最激动人心的3D模型, Matej ‘Retro’ Jan, 2016</center>

<p>就像之前一样，3D三角形被投射到2D图像空间中，并最终光栅化并显示为2D光栅图。</p>
<p><img src="https://miro.medium.com/max/540/1*iQP61eAJmsmP6dqn9KVqjw.gif"></p>
<center><font size=2>旋转立方体（技术演示）, Matej ‘Retro’ Jan, 2016</center>

<p>这就是获得最常见体素艺术风格的方式，几乎只使用免费的建模工具<a href="https://ephtracy.github.io/">MagicaVoxel</a>就能搞定。</p>
<p><img src="https://miro.medium.com/max/3800/1*l2vKyiFzTYH7Be2rK4y9JA.jpeg"></p>
<center><font size=2>Rapunzel tower, Thibault Simar, 2016</center>

<p><img src="https://miro.medium.com/max/2048/1*UmWI3HGLNgcZhIceK5saMQ.jpeg"></p>
<center><font size=2>untitled, Argo San, 2016</center>

<p><img src="https://miro.medium.com/max/4096/1*yhawaNDi6Z6eYcCNgGYtVQ.jpeg"></p>
<center><font size=2>Pokemon Voxel, Playiku, 2016</center>

<p><img src="https://miro.medium.com/max/4096/1*q99B7giLhwCrZPNgV8VIJg.png"></p>
<center><font size=2>Cat vs Voxel, Stefan Smiljkovic, 2016</center>

<p><img src="https://miro.medium.com/max/3348/1*MrdheiQWQUl0bgj1fPahTA.jpeg"></p>
<center><font size=2>Trench Run, Gabriel de Laubier, 2015</center>

<p><img src="https://miro.medium.com/max/1602/1*v7yXtviazc967KPWlZtI2A.jpeg"></p>
<center><font size=2>Voxair balloon, Gabriel de Laubier, 2015</center>

<p><img src="https://miro.medium.com/max/2800/1*0Pno3b8BWza6pA0D-NT5hQ.jpeg"></p>
<center><font size=2>Sky Chase, Sir Carma, 2015</center>

<p><img src="https://miro.medium.com/max/2800/1*dAFkYZOEVJYCY0o9FcaTyA.jpeg"></p>
<center><font size=2>Talaak village, Sir Carma, 2016</center>

<p><img src="https://miro.medium.com/max/3840/1*8Lr2jT1XrHfzucZn1uu9uw.jpeg"></p>
<center><font size=2>Latica Cliffs, Sir Carma, 2015</center>

<h1 id="射线检测"><a href="#射线检测" class="headerlink" title="射线检测"></a>射线检测</h1><p>不过没有必要采用多维数据集方法。每个体素都可以看作是三维空间中的一个点，是那个位置上的一个体块。你可以通过在2D位置放置一个(或几个)像素直接在2D空间中绘制每个体素。或者反过来——你在屏幕上取一个像素，然后查看场景中的哪个体素出现在那个位置。</p>
<p>这种相反的方法叫做射线检测。你从视点投射一束光线到场景中，看看你击中了哪个体素。事实上，你投射了很多光线来扫过整个视野。</p>
<p><img src="https://miro.medium.com/max/1114/1*57B3UqvhpyIhNE-7vu514w.gif"></p>
<center><font size=2>Simple raycasting with fisheye correction, Kieff, 源自<a href=https://commons.wikimedia.org/wiki/File:Simple_raycasting_with_fisheye_correction.gif>Wikimedia Commons</a> [public domain]</center>

<p>该技术由《德军总部3D》首创，它的体素是所有的房间块，所以这只是另一种呈现体素即盒子的方法。这种方式效率很高，因为你只需要在屏幕上投射一条射线就可以得到一整列像素。这使得它本质上成为一个的2D过程，这也是为什么我们有时也称这种类型的3D图形为2.5D（第三个维度是假的，因为它只允许拉伸2D表面）。</p>
<p><img src="https://miro.medium.com/max/700/1*6mvzo-QSSaASiqJG2PnlGA.jpeg"></p>
<center><font size=2>德军总部 3D, id Software, 1992</center>

<p>我们通常不会认为《德军总部》是在绘制体素。我们必须让绘制单元足够小并且允许它们有不同的高度。这就是90年代开始使用的经典体素图形引擎的方式。</p>
<p><img src="https://miro.medium.com/max/700/1*qXpisZEG3e9skVbHiF_Iaw.png"></p>
<center><font size=2>Comanche: Maximum Overkill, NovaLogic, 1992</center>

<p>体素最初只用于地形中。这么做的目的是简化操作，这样可以把所有的体积相关的信息就是存储在二维图像（也称为高度图）的高度信息中。</p>
<p><img src="https://miro.medium.com/max/4032/1*JiwYmDCZsYLfaEogCsvmCA.png"></p>
<center><font size=2>通过高度图（左）来标定体素的高度是多少（黑色表示低，白色表示高）</center>

<p>将体素信息限制在高度地图上意味着你不能拥有悬垂的悬崖。不过也不得不说，地形上有非常多类似的细节，这是我们之前在游戏中都没有见过的。</p>
<p><img src="https://miro.medium.com/max/1600/1*uS3ct4ycv3g2XDqvHfeTzw.jpeg"></p>
<center><font size=2>Delta Force, NovaLogic, 1998</center>

<p><img src="https://miro.medium.com/max/1600/1*ZyoZEu51ahTP4O5ZtbKC4A.jpeg"></p>
<center><font size=2>Outcast, Appeal, 1999</center>

<h1 id="体素的终结"><a href="#体素的终结" class="headerlink" title="体素的终结"></a>体素的终结</h1><p>射线检测并不是90年代中游戏渲染体素信息的唯一方式。也出现了其他解决方案，每一种都有自己的优势，如可破坏的地形或支持车辆和角色渲染。这可是最前沿的技术！但是具有讽刺意味的是，正是这种创造性的多样性成为该技术被终结的另外一个原因。</p>
<p><img src="https://miro.medium.com/max/700/1*fnskLoLovaRppC8l6hbwnw.jpeg"></p>
<center><font size=2>Vangers, K-D Lab, 1998</center>

<p>时间来到2000年，图形加速卡开始普及。这些图形加速卡是用于投影和光栅化3D多边形的专用硬件（今天我们将这些芯片称为图形处理单元或GPU）。图形加速卡绘制三角形的速度非常快，但是它们能做的也仅限于此。包括射线检测在内的自定义体素渲染算法都超出了它们的能力范围。</p>
<p><img src="https://miro.medium.com/max/1280/1*IG2hgOMKvhxpn1hO5kabMw.jpeg"></p>
<center><font size=2>Hexplore, Doki Denki Studio, 1998</center>

<p>体素引擎仍然需要在CPU（中央处理单元）中实现，但是CPU也需要处理其他内容，如物理、游戏玩法和AI。在GPU上进行图形计算的目的是将渲染剥离到专用芯片上，使渲染更快，并释放CPU去做更复杂的模拟计算。而体素引擎无法跟上多边形图形的性能，最终体素的历史终于画上了句号……</p>
<p>直到大约十年后，一款游（译者注：《我的世界》）戏让体素的人气达到了一个全新的水平。这款游戏抛弃了旧的方法，为“体素即立方体”的方法铺设了道路。而到目前为止，这都可以用GPU进行有效地渲染，其余的都已经成为历史。</p>
<p><img src="https://miro.medium.com/max/3840/1*lWosn7HLMsInD98VaNgSeg.jpeg"></p>
<center><font size=2>我的世界, Mojang, 2009–present</center>

<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>让我们回顾一下我们学过的知识，并使用数学的方式回答最初的问题：什么是像素，什么是体素？</p>
<blockquote>
<p>像素是将二维空间划分为离散的、均匀（大小相等）的区域时的最小单位。</p>
</blockquote>
<p>每个像素都可以由两个分量的向量寻址，其中x和y都是整数。与矢量图的连续特性相比，像素空间是离散的，而矢量图的每个坐标都是一个实数（用浮点数表示）。</p>
<blockquote>
<p>同样，体素是将三维空间划分为离散的、均匀的区域时最小的体积单位。</p>
</blockquote>
<p>这就是答案。</p>
<p>这就完了？很显然，并没有。</p>
<p>有了这样的一般性的定义，像素和体素可以以许多不同的方式出现，我们可以创造性地将这些概念转化为不同的视觉外观。尤其是我们还可以组合了光栅图&#x2F;矢量图、2D&#x2F;3D形成四个象限。</p>
<h1 id="纯2D图形"><a href="#纯2D图形" class="headerlink" title="纯2D图形"></a>纯2D图形</h1><p><img src="https://miro.medium.com/max/1150/1*Knf2Vt9enb0OtHp6Z_hJfg.png"></p>
<p>在过去，如果你想在屏幕上绘制一个2D精灵，你必须直接将存储精灵颜色的内存复制到存储屏幕上显示的颜色的内存中（这种复制也被称为bit blit或bit BLT，缩写为位块传输）。今天几乎没有人像这样渲染二维图形。<a href="http://www.lexaloffle.com/pico-8.php">PICO-8</a>作为使用现代渲染技术的应用，表达了对过去的美好时光的敬意，在那时位块传输是唯一的途径。</p>
<p><img src="https://miro.medium.com/max/512/1*EgF2wgiDowiPwcNzTl-w-g.gif"></p>
<center><font size=2>PICO-8, Lexallofle Games (and respective authors of featured carts), 2014–present</center>

<h1 id="3D图形中的纹理"><a href="#3D图形中的纹理" class="headerlink" title="3D图形中的纹理"></a>3D图形中的纹理</h1><p><img src="https://miro.medium.com/max/575/1*MScrl43eGCknHPZovbfAhA.png"></p>
<p>如今，大多数图形引擎都是在最底层使用向量，因为GPU就是这样工作的。在这个系统中，使二维图像出现在屏幕上的主要方法是使用一种称为<em>纹理映射</em>（<em>texture mapping</em>）的技术在多边形上绘制它们。</p>
<p>纹理是放置（或映射）到三维多边形上的2D光栅图。</p>
<p><img src="https://miro.medium.com/max/700/1*PsxtK0zdFMWAfwWSz_s9Jg.png"></p>
<p>这就是绝大多数3D视频游戏（以及一般的3D图像）是如何以最简单的方式创建的。</p>
<p>例如，这是一个当我们有一个高多边形3D模型（译者注：也即是高精度模型）并向其添加高分辨率纹理时的外观：</p>
<p><img src="https://miro.medium.com/max/3840/1*tJmGbaOLdNKwUVduENyJwg.jpeg"></p>
<p><img src="https://miro.medium.com/max/3840/1*jnPwbv5ht_ZHfQ5C-rXZCw.jpeg"></p>
<center><font size=2>镜之边缘：催化剂 Keyart, Per Haagensen, 2016</center>

<p>因为我们使用平滑多边形着色和纹理映射，所以我们甚至不需要那么多三角形来创建好看的角色。以下是具有高分辨率纹理的低多边形3D模型：</p>
<p><img src="https://miro.medium.com/max/2400/1*kmgVMyBiihueW-k0HWbgiw.jpeg"></p>
<center><font size=2>Low Poly Peon, Mark Henriksen, 2015</center>

<p>当我们将高分辨率纹理换成低分辨率的版本时，我们会得到一种线条类似于像素风格的低多边形3D模型：</p>
<p><img src="https://miro.medium.com/max/3840/1*MPsZ2w3Ms4iSsxxXeFaTNA.jpeg"></p>
<center><font size=2>Drift Stage, 2014–present (work in progress)</center>

<p>最典型的例子当然是《我的世界》。虽然《我的世界》的中方块就是上文定义一节中的体素（它们是游戏中最小的，离散的体积单位），但它们有各种各样的类型，由带有像素风格纹理的低多边形模型表示。尽管它们是块状的，但其中许多都不是简单的立方体。</p>
<p><img src="https://miro.medium.com/max/5760/1*RolSrD_iybMwqqbAsvvxdw.png"></p>
<center><font size=2>我的世界, Mojang, 2009–present</center>

<p>目前已经涵盖了所有的3D模型案例（不需要讨论高多边形模型和低分辨率纹理的组合，但如果我搞错了，请纠正我）。</p>
<p><img src="https://miro.medium.com/max/1150/1*b6twwj1cNKuUL8sbcBtBGg.png"></p>
<center><font size=2>镜像边缘（左上），马克思·佩恩（左下）和我的世界（右下）</center>

<h1 id="2D图形中的纹理"><a href="#2D图形中的纹理" class="headerlink" title="2D图形中的纹理"></a>2D图形中的纹理</h1><p><img src="https://miro.medium.com/max/575/1*rBQJ-Z8P0MH8DIQAo0pl4Q.png"></p>
<p>轮到2D了，当我们将纹理映射应用于2D矩形时，我们得到了常规的现代2D游戏。在今天的硬件中，每个2D图像（通常被称为精灵）都被放置在由2个三角形组成的矩形上。这两个三角形（合起来也称为四边形）通过映射到它们上的精灵进行渲染，使图像出现在它们的位置上。</p>
<center class="half">
  <img src="https://miro.medium.com/max/630/1*KBunkhSbQiVLm2cSHRtVsg.png"/>
  <img src="https://miro.medium.com/max/630/1*nxQ_uup6FSK2S30Ek985Zw.gif"/>
</center>


<center><font size=2>角色的图像部分（左）被纹理映射到动画四边形（右） Badminton, Matej ‘Retro’ Jan, 2006</center>

<p>在高分辨率图像中，这事也是非常直接……</p>
<p><img src="https://miro.medium.com/max/2560/1*4RoGA-8NHHwc8cBzOTU-3A.jpeg"></p>
<center><font size=2>Braid, Number None, 2008</center>

<p><img src="https://miro.medium.com/max/3840/1*2NPYuRT1CXTbHe1reB1sPA.jpeg"></p>
<center><font size=2>Limbo, Playdead, 2010</center>

<p>但是对于低分辨率的像素风格纹理来说，情况就复杂了。这完全取决于我们渲染精灵的显示分辨率。</p>
<p><img src="https://miro.medium.com/max/1148/1*IINKznZauNM_dkyfWE_K2A.png"></p>
<center><font size=2>Braid (top-left), Path to the Sky (top-right), Kingdom (bottom-right)</center>

<p>我们已经看到我们可以将像素风格纹理应用到低多边形的3D模型上，但仍然以非常高的分辨率渲染它。想一下《我的世界》：它是低多边形模型，16×16像素的低分辨率纹理，可以放在以1920×1080的显示分辨率进行渲染的场景中。</p>
<p><img src="https://miro.medium.com/max/5760/1*7RVKqfVRvOBVoWd1Yu5aNw.png"></p>
<center><font size=2>我的世界, Mojang, 2009–present</center>

<p>同样的操作也适用于2D多边形。我们可以将像素风格图像放在2D四边形上，并将其渲染到高分辨率屏幕上，使得源图像中的每个像素覆盖显示器中的多个像素。</p>
<p><img src="https://miro.medium.com/max/2732/1*xliNhVpJFY4XWMihNyc-ZQ.png"></p>
<center><font size=2>Hotline Miami, Dennaton Games, 2012</center>

<p>我们称之为大像素（<em>big pixel</em>）美术风格。每个精灵像素的渲染比显示器中的像素更大，所以它在图像中呈现为一个更大的正方形。</p>
<p><img src="https://miro.medium.com/max/3068/1*LElUGGMInnIAl4QpKwuP1Q.png"></p>
<center><font size=2>源精灵中的每个像素被渲染到3x3显示像素上, Moonman, Ben Porter, 2011–present (work in progress)</center>

<p>当精灵旋转或倾斜时，大像素风格会比较明显：</p>
<p><img src="https://miro.medium.com/max/700/1*XuYZULoFqN4lBQMqUg-zGw.gif"></p>
<center><font size=2>Path to the Sky, Johannes ‘Dek’ Märtterer, 2011–present (work in progress)</center>

<p>观察上图的树叶，并且和下面以低分辨率渲染的旋转精灵进行比较：</p>
<p><img src="https://miro.medium.com/max/700/1*n9m8k60SVzIm1ucRDu_L9w.gif"></p>
<center><font size=2>Kingdom, Noio & Licorice, 2015</center>

<p>你看到水车的像素是如何水平&#x2F;垂直对齐的，而在《Path to the Sky》中，树叶、小鸟和桥的“大像素”是如何倾斜和转换的了吗？（译者注：注意观察倾斜时的树叶，会发现锯齿感明显要小）</p>
<p>《Kingdom》通过低分辨率渲染游戏，然后将渲染后的图像放大到显示分辨率来实现这一目标。而《Path to the Sky》、《Hotline Miami》和《Moonman》则将精灵直接渲染到高分辨率的屏幕上。</p>
<p><img src="https://miro.medium.com/max/499/1*Y4P1wZPxIWE3d9EDsNoNYA.gif"></p>
<h1 id="回到3D"><a href="#回到3D" class="headerlink" title="回到3D"></a>回到3D</h1><p>《Kingdom》是一个2D游戏，但是它的制作方法也可以被延伸到3D中。</p>
<p><img src="https://miro.medium.com/max/575/1*xd1rd2dpn487MYQZomVuNA.png"></p>
<p>我们也可以使用像素风格材质的3D模型，但是将其渲染到低分辨率上，类似这样：</p>
<p><img src="https://miro.medium.com/max/500/1*JJgV0c2bWspdepYvvrwkBA.gif"></p>
<center><font size=2>Pixel Art Academy tech demo, Matej ‘Retro’ Jan, 2016</center>

<p>你可以看到我们可以得到有正确3D阴影投影的着色。尽管看起来像是某种2D像素风格，但实际上却是使用了像素风格纹理且低分辨率渲染的3D场景：</p>
<p><img src="https://miro.medium.com/max/700/1*ZlytGus34LUTnkBd4HoCBw.png"></p>
<center><font size=2>Pixel Art Academy tech demo (scene view), Matej ‘Retro’ Jan, 2016</center>

<p>基于矢量的动画（使用绑定）也可以利用这一点。以下是它们在大像素风格下的样子：</p>
<p><img src="https://miro.medium.com/max/440/1*ctJVU49KRTQWnXSsqgSAtw.gif"></p>
<center><font size=2>Animation rig with reference, Matej ‘Retro’ Jan, 2016</center>

<p>但当它们以低分辨率渲染时，它们看起来更像像素风格，像素风格类似于上面的《Kingdom》。</p>
<p><img src="https://miro.medium.com/max/1240/1*wIvCh0p9JyBfkfXn11DMOA.gif"></p>
<center><font size=2>Pixel Art Academy animation test, Matej ‘Retro’ Jan, 2016</center>

<p>这可远远不是那种可爱的手绘的逐帧动画，但是仍然保持某种美术风格，让人想起90年代的动画。</p>
<p><img src="https://miro.medium.com/max/900/1*iEPNNPvKAkDc8QLK2C0T_g.gif"></p>
<center><font size=2>波斯王子, Jordan Mechner, 1989</center>

<h1 id="3D特效"><a href="#3D特效" class="headerlink" title="3D特效"></a>3D特效</h1><p>回到高分辨率的话题上，Odd Tales的《The Last Night》便是一款充分利用了3D元素的游戏。</p>
<p><img src="https://miro.medium.com/max/700/1*jgfDIpPSwxyJKOpqoDchLQ.png"></p>
<center><font size=2>The Last Night, Odd Tales, 2014–present (work in progress)</center>

<p>它们的美术资源本质上是2D的，但却被分层构建到一个3D世界中，并且使用了你所能想到的所有现代图形特效（如动态光照，全屏泛光，动态模糊，景深，电影运镜、反射等等）。</p>
<p><img src="https://miro.medium.com/max/700/1*IfFix_Cx770hSusMJvcPYA.gif"></p>
<center><font size=2>WIP scene from The Last Night, Tim Soret, 2016</center>

<p>通过这种方式，他们构建了一个非常3D的世界，你可以从不同的角度看这个世界。</p>
<p><img src="https://miro.medium.com/max/700/1*xZpXOiP7mOKop-Qu1Ph8Bw.gif"></p>
<center><font size=2>3D scene construction in The Last Night, Tim Soret, 2016</center>

<p>另一个动态3D光照的例子是氛围超赞，但命运多舛的《<a href="https://www.kickstarter.com/projects/829559023/confederate-express/description">Confederate Express</a>》：</p>
<center class="half">
  <img src="https://miro.medium.com/max/1000/1*N9-pfws3L3AWqN0Py_dibQ.png"/>
  <img src="https://miro.medium.com/max/1000/1*9uiGuP2wuA64b_RGl8NZQg.gif"/>
</center>

<center><font size=2>Confederate Express, Maksym Pashanin, 2013–2014 (unreleased)</center>

<p>虽然美术资源仍然是2D的，但《Confederate Express》也包含了来自多个方向的阴影贴图。这些都可以通过<a href="http://www.snakehillgames.com/spritelamp/">Sprite Lamp</a>等工具进行处理，并从光源的任何位置生成精灵的平滑光照。</p>
<h1 id="体素的像素风格"><a href="#体素的像素风格" class="headerlink" title="体素的像素风格"></a>体素的像素风格</h1><p>上述方法的问题在于，仅可以精确地对精灵进行着色，而它们所投射的阴影由于缺少必要的3D几何图形而不能正确生成。要想做到这一点，最终就必须有大量的信息。那我们就来谈谈体素吧！</p>
<p><img src="https://miro.medium.com/max/575/1*QTwffrMXk0_MAKlt7G12LQ.png"></p>
<p>这个方法的一个很好的例子就是最近发布的<a href="http://www.pathway-game.com/">《Pathway》</a>:</p>
<p><img src="https://miro.medium.com/max/560/1*PtzoAgsG75O_AMicv7yERQ.gif"></p>
<center><font size=2>Pathway, Robotality, 2016 (work in progress)</center>

<p>图像看起来像是在使用像素风格的2D资源，但这些资源实际上都是有3D体积的。不像90年代的体素引擎试图尽可能地让效果起来很现代和真实，开发者Robotality不需要做额外的工作，他只需要将体素匹配到显示像素的大小。这样子很巧妙地创造了一个看起来像像素风格的假象，但是在幕后，他们包含完整的3D信息来创建正确的动态光照。</p>
<p>使用体素来创造像素风格并不是一种很新的方法。这方面的先驱是使用了被叫做trixels（3D像素）的<a href="http://fezgame.com/">FEZ</a>。而trixels只是一组由16×16×16 triles（3d贴图）的组合。</p>
<center class="half">
  <img src="https://miro.medium.com/max/1616/1*LJngMrtqdPgqKSjLSfm8jw.png" width=400/>
  <img src="https://miro.medium.com/max/1874/1*5ABmldgNQewjVVUP9CzUyw.jpeg" width=400/>
</center>

<center><font size=2>Development screenshots from FEZ, Polytron, 2007</center>

<p>当FEZ场景在游戏中渲染时，通常会使用2D正交投影，这是它们实现传统像素风格的方式，但是也允许进行FEZ风格的旋转。</p>
<p><img src="https://miro.medium.com/max/1804/1*Vw9KC3gxePL_r6Ip18xP_g.png"></p>
<center><font size=2>FEZ GDC ’09 trailer, Polytron Corporation, 2009</center>

<p><img src="https://miro.medium.com/max/1600/1*knESI_LwZ5F7QlAKA73iLQ.gif"></p>
<center><font size=2>FEZ, Polytron Corporation, 2012</center>

<h1 id="纯粹体素"><a href="#纯粹体素" class="headerlink" title="纯粹体素"></a>纯粹体素</h1><p>最后，转了一圈后我们回到了体素，所以我们可以抛开像素风格不谈，只在3D空间中渲染纯粹的、离散的体素（使用没有任何纹理的立方体）。</p>
<p><img src="https://miro.medium.com/max/575/1*eB-D_ayNoSYmTmkc_sKSDQ.png"></p>
<p>Lexallofle的<a href="http://www.lexaloffle.com/voxatron.php">Voxatron</a>正是这个领域的主角。</p>
<p><img src="https://miro.medium.com/max/2560/1*3vKO2Vu5Gjl_fR9Kx_rq6A.png"></p>
<center><font size=2>Voxatron, Lexallofle Games, 2010–present (work in progress)</center>

<p>您是否注意到Lexallofle的虚拟控制台中的主题？（译者注：这句不知道怎么翻译，原文为：Do you notice a theme in Lexallofle’s virtual consoles?）Pico-8具有纯2D的图形引擎，而对于3D体素，Voxatron也是如此。他们真是完美的伴侣。</p>
<center class="half">
  <img src="https://miro.medium.com/max/480/1*k3IpuMqtdpAiWsnDRcLWUA.gif" width=300/>
  <img src="https://miro.medium.com/max/480/1*ICd3fEo38Kcfvuec9Fnv5g.gif" width=300/>
  <img src="https://miro.medium.com/max/480/1*UVLGeiZRbShCsoApGmPTLg.gif" width=300/>
</center>

<center><font size=2>Voxatron, Lexallofle Games, 2010–present (work in progress)</center>

<p>Voxatron是为数不多的（如果不是唯一的话）在3D离散空间内使用纯粹体素的示例之一。但是它有一个类似于2D下的大像素风格的兄弟，在许多游戏中都占有一席之地，尤其是在移动领域。</p>
<p><img src="https://miro.medium.com/max/2272/1*RqJKuyUx0X6WqC2-3WhCsw.jpeg"></p>
<center><font size=2>Crossy Road, Hipster Whale, 2014</center>

<center class="half">
  <img src="https://miro.medium.com/max/1600/1*eolJWK2BmhCKzs4-5OkueA.jpeg" width=300/>
  <img src="https://miro.medium.com/max/1600/1*tmqeBESuSLsNv2ZvdfPQiw.jpeg" width=300/>
  <img src="https://miro.medium.com/max/1600/1*JmNXiBLIdcu5r5PNTAKusg.jpeg" width=300/>
</center>

<center><font size=2><a href=http://shootyskies.com>Shooty Skies</a>, Mighty Games, 2016</center>

<p><img src="https://miro.medium.com/max/3840/1*ICzVMPvYSd08p7Pmjq3A_A.jpeg"></p>
<center><font size=2><a href=https://www.bandainamcoent.eu/pac-man-256>PAC-MAN 256</a>, Hipster Whale, 2015</center>

<p>绕了一圈后让我们再次回到<a href="https://twitter.com/Sir_carma">Sir Carma</a>。在成为最知名的体素艺术家之一之后，他现在正在使用Unity将纯粹体素的美学推向更高的高度，并提供大量的视觉效果，就像是《Odd Tales》（译者注：参考上文）在像素风格中所做的那样。</p>
<p><img src="https://miro.medium.com/max/2164/1*e8vPqBqWmI_Nqz0EJpXEnw.jpeg"></p>
<center><font size=2>The Way Back, Sir Carma, 2016 (work in progress)</center>

<p><img src="https://miro.medium.com/max/1500/1*AIQ3ChT-s3D5GUkoMBOHog.gif"></p>
<center><font size=2>The Way Back, Sir Carma, 2016 (work in progress)</center>

<p>体素风格的《塞尔达》&#x2F;《Atic Atac》？（译者注：原文为：Voxel Zelda&#x2F;Atic Atac anyone?）</p>
<p><img src="https://miro.medium.com/max/4096/1*hDy95QLrE_HEX1GszB7ukw.jpeg"></p>
<center><font size=2>The Way Back, Sir Carma, 2016 (work in progress)</center>

<p>到目前为止，我们涵盖了我能想到的所有2D &#x2F; 3D &#x2F;光栅图&#x2F;矢量图&#x2F;低分辨率&#x2F;高分辨率的组合。我能确定我会遗漏某些细节，也确定在将来会出现更多有趣的方法，但是就目前而言，这已经足够了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">临江听雨</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
