<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"blog.gamedo.org","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.24.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="背景乔梁大神曾经在他的《持续交付2.0》一书的第5.1.1节：《持续交付架构要求》中明确指出：为了提升交付速度，获得持续交付能力，系统架构在设计时应该考虑如下因素。 （1）为测试而设计（design for test）。如果我们每次写好代码以后，需要花费很大的精力，做很多的准备工作才能对它进行测试的话，那么从写好代码到完成质量验证就需要很长周期，当然无法快速发布。 （2）为部署而设计（design">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring Boot Actuator官方参考文档（2.5.0）翻译（完结）">
<meta property="og:url" content="https://blog.gamedo.org/2021/05/20/Spring%20Boot%20Actuator%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/index.html">
<meta property="og:site_name" content="听雨">
<meta property="og:description" content="背景乔梁大神曾经在他的《持续交付2.0》一书的第5.1.1节：《持续交付架构要求》中明确指出：为了提升交付速度，获得持续交付能力，系统架构在设计时应该考虑如下因素。 （1）为测试而设计（design for test）。如果我们每次写好代码以后，需要花费很大的精力，做很多的准备工作才能对它进行测试的话，那么从写好代码到完成质量验证就需要很长周期，当然无法快速发布。 （2）为部署而设计（design">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-05-20T12:00:00.000Z">
<meta property="article:modified_time" content="2025-08-12T06:47:53.979Z">
<meta property="article:author" content="临江听雨">
<meta property="article:tag" content="源码阅读">
<meta property="article:tag" content="spring">
<meta property="article:tag" content="spring boot">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://blog.gamedo.org/2021/05/20/Spring%20Boot%20Actuator%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://blog.gamedo.org/2021/05/20/Spring%20Boot%20Actuator%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/","path":"2021/05/20/Spring Boot Actuator参考文档翻译/","title":"Spring Boot Actuator官方参考文档（2.5.0）翻译（完结）"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Spring Boot Actuator官方参考文档（2.5.0）翻译（完结） | 听雨</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.9.0/mermaid.min.js","integrity":"sha256-Cz7UN0EXNjgV2u/a38wg/3BNfdRRO1XtgDq93L2GqJg="}}</script>
  <script src="/js/third-party/tags/mermaid.js" defer></script>





  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">听雨</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%83%8C%E6%99%AF"><span class="nav-number">1.</span> <span class="nav-text">背景</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%AF%E7%94%A8%E4%BA%A7%E5%93%81%E5%B0%B1%E7%BB%AA%E7%89%B9%E6%80%A7%EF%BC%88Enabling-Production-ready-Features%EF%BC%89"><span class="nav-number">2.</span> <span class="nav-text">启用产品就绪特性（Enabling Production-ready Features）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AB%AF%E7%82%B9%EF%BC%88Endpoints%EF%BC%89"><span class="nav-number">3.</span> <span class="nav-text">端点（Endpoints）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%80%E5%90%AF%E7%AB%AF%E7%82%B9%EF%BC%88Enabling-Endpoints%EF%BC%89"><span class="nav-number">3.1.</span> <span class="nav-text">开启端点（Enabling Endpoints）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9A%B4%E9%9C%B2%E7%AB%AF%E7%82%B9%EF%BC%88Exposing-Endpoints%EF%BC%89"><span class="nav-number">3.2.</span> <span class="nav-text">暴露端点（Exposing Endpoints）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A0%E5%9B%BAHTTP%E7%AB%AF%E7%82%B9%EF%BC%88Securing-HTTP-Endpoints%EF%BC%89"><span class="nav-number">3.3.</span> <span class="nav-text">加固HTTP端点（Securing HTTP Endpoints）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E7%AB%AF%E7%82%B9%EF%BC%88Configuring-Endpoints%EF%BC%89"><span class="nav-number">3.4.</span> <span class="nav-text">配置端点（Configuring Endpoints）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hypermedia-for-Actuator-Web-Endpoints"><span class="nav-number">3.5.</span> <span class="nav-text">Hypermedia for Actuator Web Endpoints</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%E6%94%AF%E6%8C%81%EF%BC%88CORS-Support%EF%BC%89"><span class="nav-number">3.6.</span> <span class="nav-text">跨域资源共享支持（CORS Support）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AB%AF%E7%82%B9%EF%BC%88Implementing-Custom-Endpoints%EF%BC%89"><span class="nav-number">3.7.</span> <span class="nav-text">实现自定义端点（Implementing Custom Endpoints）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A5%E5%8F%82%E5%A4%84%E7%90%86%EF%BC%88Receiving-Input%EF%BC%89"><span class="nav-number">3.7.1.</span> <span class="nav-text">入参处理（Receiving Input）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">3.7.1.1.</span> <span class="nav-text">输入类型转换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89Web%E7%AB%AF%E7%82%B9%EF%BC%88Custom-Web-Endpoints%EF%BC%89"><span class="nav-number">3.7.2.</span> <span class="nav-text">自定义Web端点（Custom Web Endpoints）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Web%E7%AB%AF%E7%82%B9%E8%AF%B7%E6%B1%82%E8%B0%93%E8%AF%8D%EF%BC%88Web-Endpoint-Request-Predicates%EF%BC%89"><span class="nav-number">3.7.2.1.</span> <span class="nav-text">Web端点请求谓词（Web Endpoint Request Predicates）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%AF%E5%BE%84%EF%BC%88Path%EF%BC%89"><span class="nav-number">3.7.2.2.</span> <span class="nav-text">路径（Path）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP%E6%96%B9%E6%B3%95%EF%BC%88HTTP-method%EF%BC%89"><span class="nav-number">3.7.2.3.</span> <span class="nav-text">HTTP方法（HTTP method）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8B%EF%BC%88Consumes%EF%BC%89"><span class="nav-number">3.7.2.4.</span> <span class="nav-text">请求媒体类型（Consumes）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%8D%E5%BA%94%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8B%EF%BC%88Produces%EF%BC%89"><span class="nav-number">3.7.2.5.</span> <span class="nav-text">响应媒体类型（Produces）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Web%E7%AB%AF%E7%82%B9%E7%9A%84%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81%EF%BC%88Web-Endpoint-Response-Status%EF%BC%89"><span class="nav-number">3.7.2.6.</span> <span class="nav-text">Web端点的响应状态码（Web Endpoint Response Status）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Web%E7%AB%AF%E7%82%B9%E8%8C%83%E5%9B%B4%E8%AF%B7%E6%B1%82%EF%BC%88Web-Endpoint-Range-Requests%EF%BC%89"><span class="nav-number">3.7.2.7.</span> <span class="nav-text">Web端点范围请求（Web Endpoint Range Requests）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Web%E7%AB%AF%E7%82%B9%E5%AE%89%E5%85%A8%EF%BC%88Web-Endpoint-Security%EF%BC%89"><span class="nav-number">3.7.2.8.</span> <span class="nav-text">Web端点安全（Web Endpoint Security）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Servlet%E7%AB%AF%E7%82%B9%EF%BC%88Servlet-Endpoints%EF%BC%89"><span class="nav-number">3.7.3.</span> <span class="nav-text">Servlet端点（Servlet Endpoints）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Controller%E7%AB%AF%E7%82%B9%EF%BC%88Controller-Endpoints%EF%BC%89"><span class="nav-number">3.7.3.1.</span> <span class="nav-text">Controller端点（Controller Endpoints）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%81%A5%E5%BA%B7%E4%BF%A1%E6%81%AF%EF%BC%88Health-Information%EF%BC%89"><span class="nav-number">3.8.</span> <span class="nav-text">健康信息（Health Information）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%9A%84HealthIndicators%EF%BC%88Auto-configured-HealthIndicators%EF%BC%89"><span class="nav-number">3.8.1.</span> <span class="nav-text">自动装配的HealthIndicators（Auto-configured HealthIndicators）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89HealthIndicators%EF%BC%88Writing-Custom-HealthIndicators%EF%BC%89"><span class="nav-number">3.8.2.</span> <span class="nav-text">自定义HealthIndicators（Writing Custom HealthIndicators）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%8D%E5%BA%94%E5%BC%8F%E5%81%A5%E5%BA%B7%E6%8C%87%E7%A4%BA%E5%99%A8%EF%BC%88Reactive-Health-Indicators%EF%BC%89"><span class="nav-number">3.8.3.</span> <span class="nav-text">响应式健康指示器（Reactive Health Indicators）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%9A%84ReactiveHealthIndicators%EF%BC%88Auto-configured-ReactiveHealthIndicators%EF%BC%89"><span class="nav-number">3.8.4.</span> <span class="nav-text">自动装配的ReactiveHealthIndicators（Auto-configured ReactiveHealthIndicators）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%81%A5%E5%BA%B7%E5%88%86%E7%BB%84%EF%BC%88Health-Groups%EF%BC%89"><span class="nav-number">3.8.5.</span> <span class="nav-text">健康分组（Health Groups）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%BA%90%E5%81%A5%E5%BA%B7%EF%BC%88DataSource-Health%EF%BC%89"><span class="nav-number">3.8.6.</span> <span class="nav-text">数据源健康（DataSource Health）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kubernetes%E6%8E%A2%E9%92%88%EF%BC%88Kubernetes-Probes%EF%BC%89"><span class="nav-number">3.9.</span> <span class="nav-text">Kubernetes探针（Kubernetes Probes）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Kubernetes%E6%8E%A2%E9%92%88%E6%A3%80%E6%B5%8B%E5%A4%96%E9%83%A8%E7%8A%B6%E6%80%81%EF%BC%88Checking-External-State-with-Kubernetes-Probes%EF%BC%89"><span class="nav-number">3.9.1.</span> <span class="nav-text">使用Kubernetes探针检测外部状态（Checking External State with Kubernetes Probes）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8E%A2%E9%92%88%E7%8A%B6%E6%80%81%EF%BC%88Application-Lifecycle-and-Probe-States%EF%BC%89"><span class="nav-number">3.9.2.</span> <span class="nav-text">应用程序生命周期和探针状态（Application Lifecycle and Probe States）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%BF%A1%E6%81%AF%EF%BC%88Application-Information%EF%BC%89"><span class="nav-number">3.10.</span> <span class="nav-text">应用程序信息（Application Information）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8DInfoContributors%EF%BC%88Auto-configured-InfoContributors%EF%BC%89"><span class="nav-number">3.10.1.</span> <span class="nav-text">自动装配InfoContributors（Auto-configured InfoContributors）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%BF%A1%E6%81%AF%EF%BC%88Custom-Application-Information%EF%BC%89"><span class="nav-number">3.10.2.</span> <span class="nav-text">自定义应用程序信息（Custom Application Information）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Git%E6%8F%90%E4%BA%A4%E4%BF%A1%E6%81%AF%EF%BC%88Git-Commit-Information%EF%BC%89"><span class="nav-number">3.11.</span> <span class="nav-text">Git提交信息（Git Commit Information）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E4%BF%A1%E6%81%AF%EF%BC%88Build-Information%EF%BC%89"><span class="nav-number">3.11.1.</span> <span class="nav-text">构建信息（Build Information）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89InfoContributors%EF%BC%88Writing-Custom-InfoContributors%EF%BC%89"><span class="nav-number">3.11.2.</span> <span class="nav-text">自定义InfoContributors（Writing Custom InfoContributors）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%80%9A%E8%BF%87HTTP%E8%BF%9B%E8%A1%8C%E7%9B%91%E6%8E%A7%E4%B8%8E%E7%AE%A1%E7%90%86%EF%BC%88Monitoring-and-Management-over-HTTP%EF%BC%89"><span class="nav-number">4.</span> <span class="nav-text">通过HTTP进行监控与管理（Monitoring and Management over HTTP）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AB%AF%E7%82%B9%E8%B7%AF%E5%BE%84%EF%BC%88Customizing-the-Management-Endpoint-Paths%EF%BC%89"><span class="nav-number">4.1.</span> <span class="nav-text">自定义端点路径（Customizing the Management Endpoint Paths）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AB%AF%E5%8F%A3%EF%BC%88Customizing-the-Management-Server-Port%EF%BC%89"><span class="nav-number">4.2.</span> <span class="nav-text">自定义端口（Customizing the Management Server Port）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%85%8D%E7%BD%AESSL%EF%BC%88Configuring-Management-specific-SSL%EF%BC%89"><span class="nav-number">4.3.</span> <span class="nav-text">配置SSL（Configuring Management-specific SSL）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9C%B0%E5%9D%80"><span class="nav-number">4.4.</span> <span class="nav-text">自定义服务器地址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A6%81%E7%94%A8HTTP%E7%AB%AF%E7%82%B9%EF%BC%88Disabling-HTTP-Endpoints%EF%BC%89"><span class="nav-number">4.5.</span> <span class="nav-text">禁用HTTP端点（Disabling HTTP Endpoints）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%80%9A%E8%BF%87JMX%E8%BF%9B%E8%A1%8C%E7%9B%91%E6%8E%A7%E5%92%8C%E7%AE%A1%E7%90%86%EF%BC%88Monitoring-and-Management-over-JMX%EF%BC%89"><span class="nav-number">5.</span> <span class="nav-text">通过JMX进行监控和管理（Monitoring and Management over JMX）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89MBean%E5%90%8D%E5%AD%97%EF%BC%88Customizing-MBean-Names%EF%BC%89"><span class="nav-number">5.0.1.</span> <span class="nav-text">自定义MBean名字（Customizing MBean Names）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A6%81%E7%94%A8JMX%E7%AB%AF%E7%82%B9%EF%BC%88Disabling-JMX-Endpoints%EF%BC%89"><span class="nav-number">5.0.2.</span> <span class="nav-text">禁用JMX端点（Disabling JMX Endpoints）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87HTTP%E8%AE%BF%E9%97%AE%E5%9F%BA%E4%BA%8EJolokia%E7%9A%84JMX%E7%AB%AF%E7%82%B9%EF%BC%88Using-Jolokia-for-JMX-over-HTTP%EF%BC%89"><span class="nav-number">5.0.3.</span> <span class="nav-text">通过HTTP访问基于Jolokia的JMX端点（Using Jolokia for JMX over HTTP）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89Jolokia%EF%BC%88Customizing-Jolokia%EF%BC%89"><span class="nav-number">5.0.3.1.</span> <span class="nav-text">自定义Jolokia（Customizing Jolokia）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A6%81%E7%94%A8Jolokia%EF%BC%88Disabling-Jolokia%EF%BC%89"><span class="nav-number">5.0.3.2.</span> <span class="nav-text">禁用Jolokia（Disabling Jolokia）</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%EF%BC%88Loggers%EF%BC%89"><span class="nav-number">6.</span> <span class="nav-text">日志（Loggers）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E6%97%A5%E5%BF%97%EF%BC%88Configure-a-Logger%EF%BC%89"><span class="nav-number">6.1.</span> <span class="nav-text">配置日志（Configure a Logger）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8C%87%E6%A0%87%EF%BC%88Metrics%EF%BC%89"><span class="nav-number">7.</span> <span class="nav-text">指标（Metrics）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A5%E9%97%A8%EF%BC%88Getting-started%EF%BC%89"><span class="nav-number">7.1.</span> <span class="nav-text">入门（Getting started）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%94%AF%E6%8C%81%E7%9A%84%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%EF%BC%88Supported-Monitoring-Systems%EF%BC%89"><span class="nav-number">7.2.</span> <span class="nav-text">支持的监控系统（Supported Monitoring Systems）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AppOptics"><span class="nav-number">7.2.1.</span> <span class="nav-text">AppOptics</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Atlas"><span class="nav-number">7.2.2.</span> <span class="nav-text">Atlas</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Datadog"><span class="nav-number">7.2.3.</span> <span class="nav-text">Datadog</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dynatrace"><span class="nav-number">7.2.4.</span> <span class="nav-text">Dynatrace</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Elastic"><span class="nav-number">7.2.5.</span> <span class="nav-text">Elastic</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Ganglia"><span class="nav-number">7.2.6.</span> <span class="nav-text">Ganglia</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Graphite"><span class="nav-number">7.2.7.</span> <span class="nav-text">Graphite</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Humio"><span class="nav-number">7.2.8.</span> <span class="nav-text">Humio</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Influx"><span class="nav-number">7.2.9.</span> <span class="nav-text">Influx</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JMX"><span class="nav-number">7.2.10.</span> <span class="nav-text">JMX</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KairosDB"><span class="nav-number">7.2.11.</span> <span class="nav-text">KairosDB</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#New-Relic"><span class="nav-number">7.2.12.</span> <span class="nav-text">New Relic</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Prometheus"><span class="nav-number">7.2.13.</span> <span class="nav-text">Prometheus</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SignalFx"><span class="nav-number">7.2.14.</span> <span class="nav-text">SignalFx</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Simple"><span class="nav-number">7.2.15.</span> <span class="nav-text">Simple</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Stackdriver"><span class="nav-number">7.2.16.</span> <span class="nav-text">Stackdriver</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StatsD"><span class="nav-number">7.2.17.</span> <span class="nav-text">StatsD</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Wavefront"><span class="nav-number">7.2.18.</span> <span class="nav-text">Wavefront</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%94%AF%E6%8C%81%E7%9A%84%E6%8C%87%E6%A0%87%E5%92%8C%E4%BB%AA%E8%A1%A8%EF%BC%88Supported-Metrics-and-Meters%EF%BC%89"><span class="nav-number">7.3.</span> <span class="nav-text">支持的指标和仪表（Supported Metrics and Meters）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM%E6%8C%87%E6%A0%87%EF%BC%88JVM-Metrics%EF%BC%89"><span class="nav-number">7.3.1.</span> <span class="nav-text">JVM指标（JVM Metrics）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E6%8C%87%E6%A0%87%EF%BC%88System-Metrics%EF%BC%89"><span class="nav-number">7.3.2.</span> <span class="nav-text">系统指标（System Metrics）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E6%8C%87%E6%A0%87%EF%BC%88Logger-Metrics%EF%BC%89"><span class="nav-number">7.3.3.</span> <span class="nav-text">日志指标（Logger Metrics）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-MVC%E6%8C%87%E6%A0%87%EF%BC%88-Spring-MVC-Metrics%EF%BC%89"><span class="nav-number">7.3.4.</span> <span class="nav-text">Spring MVC指标（ Spring MVC Metrics）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-WebFlux%E6%8C%87%E6%A0%87%EF%BC%88Spring-WebFlux-Metrics%EF%BC%89"><span class="nav-number">7.3.5.</span> <span class="nav-text">Spring WebFlux指标（Spring WebFlux Metrics）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Jersey-Server%E6%8C%87%E6%A0%87%EF%BC%88Jersey-Server-Metrics%EF%BC%89"><span class="nav-number">7.3.6.</span> <span class="nav-text">Jersey Server指标（Jersey Server Metrics）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-Client%E6%8C%87%E6%A0%87%EF%BC%88HTTP-Client-Metrics%EF%BC%89"><span class="nav-number">7.3.7.</span> <span class="nav-text">HTTP Client指标（HTTP Client Metrics）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tomcat%E6%8C%87%E6%A0%87%EF%BC%88-Tomcat-Metrics%EF%BC%89"><span class="nav-number">7.3.8.</span> <span class="nav-text">Tomcat指标（ Tomcat Metrics）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E6%8C%87%E6%A0%87%EF%BC%88Cache-Metrics%EF%BC%89"><span class="nav-number">7.3.9.</span> <span class="nav-text">缓存指标（Cache Metrics）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%BA%90%E6%8C%87%E6%A0%87%EF%BC%88DataSource-Metrics%EF%BC%89"><span class="nav-number">7.3.10.</span> <span class="nav-text">数据源指标（DataSource Metrics）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hibernate%E6%8C%87%E6%A0%87%EF%BC%88-Hibernate-Metrics%EF%BC%89"><span class="nav-number">7.3.11.</span> <span class="nav-text">Hibernate指标（ Hibernate Metrics）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-Data-Repository%E6%8C%87%E6%A0%87%EF%BC%88Spring-Data-Repository-Metrics%EF%BC%89"><span class="nav-number">7.3.12.</span> <span class="nav-text">Spring Data Repository指标（Spring Data Repository Metrics）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RabbitMQ%E6%8C%87%E6%A0%87%EF%BC%88RabbitMQ-Metrics%EF%BC%89"><span class="nav-number">7.3.13.</span> <span class="nav-text">RabbitMQ指标（RabbitMQ Metrics）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-Integration%E6%8C%87%E6%A0%87%EF%BC%88Spring-Integration-Metrics%EF%BC%89"><span class="nav-number">7.3.14.</span> <span class="nav-text">Spring Integration指标（Spring Integration Metrics）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Kafka%E6%8C%87%E6%A0%87%EF%BC%88Kafka-Metrics%EF%BC%89"><span class="nav-number">7.3.15.</span> <span class="nav-text">Kafka指标（Kafka Metrics）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MongoDB%E6%8C%87%E6%A0%87%EF%BC%88MongoDB-Metrics%EF%BC%89"><span class="nav-number">7.3.16.</span> <span class="nav-text">MongoDB指标（MongoDB Metrics）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E6%8C%87%E6%A0%87%EF%BC%88Command-Metrics%EF%BC%89"><span class="nav-number">7.3.16.1.</span> <span class="nav-text">命令指标（Command Metrics）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E6%B1%A0%E6%8C%87%E6%A0%87%EF%BC%88Connection-Pool-Metrics%EF%BC%89"><span class="nav-number">7.3.16.2.</span> <span class="nav-text">连接池指标（Connection Pool Metrics）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Timed%E6%B3%A8%E8%A7%A3%E6%94%AF%E6%8C%81%EF%BC%88-Timed-Annotation-Support%EF%BC%89"><span class="nav-number">7.3.17.</span> <span class="nav-text">@Timed注解支持（@Timed Annotation Support）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E6%A0%87%EF%BC%88Registering-Custom-Metrics%EF%BC%89"><span class="nav-number">7.4.</span> <span class="nav-text">注册自定义指标（Registering Custom Metrics）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%89%B9%E5%AE%9A%E6%8C%87%E6%A0%87%EF%BC%88Customizing-Individual-Metrics%EF%BC%89"><span class="nav-number">7.5.</span> <span class="nav-text">自定义特定指标（Customizing Individual Metrics）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%80%9A%E7%94%A8Tag%E6%A0%87%E8%AE%B0%EF%BC%88Common-Tags%EF%BC%89"><span class="nav-number">7.5.0.1.</span> <span class="nav-text">自定义通用Tag标记（Common Tags）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B2%BE%E7%A1%AE%E6%8C%87%E6%A0%87%E9%85%8D%E7%BD%AE%EF%BC%88Per-meter-Properties%EF%BC%89"><span class="nav-number">7.5.0.2.</span> <span class="nav-text">精确指标配置（Per-meter Properties）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E6%A0%87%E7%AB%AF%E7%82%B9%EF%BC%88Metrics-Endpoint%EF%BC%89"><span class="nav-number">7.6.</span> <span class="nav-text">指标端点（Metrics Endpoint）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%A1%E8%AE%A1%EF%BC%88Auditing%EF%BC%89"><span class="nav-number">8.</span> <span class="nav-text">审计（Auditing）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%A1%E8%AE%A1%EF%BC%88Custom-Auditing%EF%BC%89"><span class="nav-number">8.1.</span> <span class="nav-text">自定义审计（Custom Auditing）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HTTP%E8%BF%BD%E8%B8%AA%EF%BC%88HTTP-Tracing%EF%BC%89"><span class="nav-number">9.</span> <span class="nav-text">HTTP追踪（HTTP Tracing）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89HTTP%E8%BF%BD%E8%B8%AA%EF%BC%88Custom-HTTP-tracing%EF%BC%89"><span class="nav-number">9.1.</span> <span class="nav-text">自定义HTTP追踪（Custom HTTP tracing）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9B%91%E6%8E%A7%EF%BC%88Process-Monitoring%EF%BC%89"><span class="nav-number">10.</span> <span class="nav-text">进程监控（Process Monitoring）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E9%85%8D%E7%BD%AE%EF%BC%88Extending-Configuration%EF%BC%89"><span class="nav-number">10.1.</span> <span class="nav-text">扩展配置（Extending Configuration）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E7%A8%8B%E6%96%B9%E5%BC%8F%E6%94%AF%E6%8C%81%EF%BC%88Programmatically%EF%BC%89"><span class="nav-number">10.2.</span> <span class="nav-text">编程方式支持（Programmatically）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Cloud-Foundry-%E6%94%AF%E6%8C%81%EF%BC%88Cloud-Foundry-Support%EF%BC%89"><span class="nav-number">11.</span> <span class="nav-text">Cloud Foundry 支持（Cloud Foundry Support）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A6%81%E7%94%A8Cloud-Foundry-Actuator%E6%94%AF%E6%8C%81%EF%BC%88Disabling-Extended-Cloud-Foundry-Actuator-Support%EF%BC%89"><span class="nav-number">11.1.</span> <span class="nav-text">禁用Cloud Foundry Actuator支持（Disabling Extended Cloud Foundry Actuator Support）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cloud-Foundry%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6%EF%BC%88Cloud-Foundry-Self-signed-Certificates%EF%BC%89"><span class="nav-number">11.2.</span> <span class="nav-text">Cloud Foundry自签名证书（Cloud Foundry Self-signed Certificates）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%8A%E4%B8%8B%E6%96%87%E8%B7%AF%E5%BE%84%EF%BC%88Custom-Context-Path%EF%BC%89"><span class="nav-number">11.3.</span> <span class="nav-text">自定义上下文路径（Custom Context Path）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%A5%E4%B8%8B%E6%9D%A5%E8%A6%81%E8%AF%BB%E4%BB%80%E4%B9%88%EF%BC%88What-to-Read-Next%EF%BC%89"><span class="nav-number">12.</span> <span class="nav-text">接下来要读什么（What to Read Next）</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">临江听雨</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/pcloves" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;pcloves" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.gamedo.org/2021/05/20/Spring%20Boot%20Actuator%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="临江听雨">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="听雨">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Spring Boot Actuator官方参考文档（2.5.0）翻译（完结） | 听雨">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Spring Boot Actuator官方参考文档（2.5.0）翻译（完结）
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-05-20 20:00:00" itemprop="dateCreated datePublished" datetime="2021-05-20T20:00:00+08:00">2021-05-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-12 14:47:53" itemprop="dateModified" datetime="2025-08-12T14:47:53+08:00">2025-08-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E6%B2%89%E6%B7%80/" itemprop="url" rel="index"><span itemprop="name">技术沉淀</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p><strong>乔梁</strong>大神曾经在他的<a href="https://book.douban.com/subject/30419555/">《持续交付2.0》</a>一书的第5.1.1节：《持续交付架构要求》中明确指出：为了提升交付速度，获得持续交付能力，系统架构在设计时应该考虑如下因素。</p>
<p>（1）<strong>为测试而设计（design for test）</strong>。如果我们每次写好代码以后，需要花费很大的精力，做很多的准备工作才能对它进行测试的话，那么从写好代码到完成质量验证就需要很长周期，当然无法快速发布。</p>
<p>（2）<strong>为部署而设计（design for development）</strong>。如果我们开发完新功能，当部署发布是，需要花费很长时间准备，甚至需要停机才能部署，当然就无法快速发布。</p>
<p>（3）<strong>为监控而设计（design for monitor）</strong>。如果我们的功能上线以后，无法对齐进行监控，除了问题只能通过用户反馈才发现。那么，持续交付的收益就会大幅降低了。</p>
<p>（4）<strong>为扩展而设计（design for scale）</strong>。这里的扩展性指两个方面，意识支持团队成员规模的扩展，而是支持系统自身的扩展。</p>
<p>（5）<strong>为失效而设计（design for failure）</strong>。俗话说：“常在河边走，哪能不湿鞋。”快速地部署发布总会遇到问题。因此，在开发软件功能之前，就应该考虑的一个问题是：一旦部署或发布失败，如何优雅且快速地处理。</p>
<p>在这5个设计原则中，为<strong>为监控而设计（design for monitor）</strong>属于游戏（服务器）开发中最容易被轻视甚至是忽视的原则之一，而在<a href="https://github.com/pcloves/gamedo.core">gamedo.core</a>的开发设计过程中，译者本人也一直在思考如何实现系统监控的最佳实践，直到最近算是确定了技术栈，那就是站在巨人的肩上，使用<a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator">Spring Boot Actuator</a>和<a href="https://micrometer.io/docs">MicroMeter</a>。</p>
<p>正是由于<a href="https://github.com/pcloves/gamedo.core">gamedo.core</a>最终要选用Spring Boot Actuator作为系统监控的关键技术，因此需要其进行相对深入的研究，这也是本笔记的产生的原因。而本文的所有内容都源于阅读<a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator">参考文档</a>（Spring Boot版本：2.5.0）以及阅读源码时的随读、随想和随写，为了便于以后查找，章节也完全和参考文档保持一致，并且由于某些章节比较简单，所以就被忽略掉，这可能导致本文的章节不是连续的。</p>
<h1 id="启用产品就绪特性（Enabling-Production-ready-Features）"><a href="#启用产品就绪特性（Enabling-Production-ready-Features）" class="headerlink" title="启用产品就绪特性（Enabling Production-ready Features）"></a>启用产品就绪特性（Enabling Production-ready Features）</h1><p>Spring Boot的所有产品就绪特性是都是由 <a href="https://github.com/spring-projects/spring-boot/tree/v2.4.6/spring-boot-project/spring-boot-actuator"><code>spring-boot-actuator</code></a>模块提供的，开启该特性的最佳方式就是引入专有的<code>Starter</code>，也即：<code>spring-boot-starter-actuator</code></p>
<blockquote>
<center><b>执行器的定义</b></center>

<p><a href="https://www.termonline.cn/search?k=actuator">执行器</a>（actuator）是一个制造业术语，是指用于移动或控制某些物体的机械设备。可以通过执行器的微小变化带来巨大的变化。</p>
</blockquote>
<p>对于使用Maven构建的项目，可以添加如下<code>Starter</code>依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>对于使用Gradle的项目，使用如下配置：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-actuator&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="端点（Endpoints）"><a href="#端点（Endpoints）" class="headerlink" title="端点（Endpoints）"></a>端点（Endpoints）</h1><p>通过端点可以监控应用程序，和应用程序交互。Spring Boot内置了一堆端点，用户也可以自行添加。比如<code>health</code>端点，它可以提供应用的基本健康信息。</p>
<p>每一个端点都可以被<a href="##%E5%BC%80%E5%90%AF%E7%AB%AF%E7%82%B9%EF%BC%88Enabling-Endpoints%EF%BC%89">开启、禁用</a>，也可以<a href="##%E6%9A%B4%E9%9C%B2%E7%AB%AF%E7%82%B9%EF%BC%88Exposing-Endpoints%EF%BC%89">通过HTTP或JMX的方式暴露</a>给外部。当端点同时开启且被暴露时，它才是可用的。内置的端点也只有在可用状态下才会被Spring Boot自动装配。大多数应用都选择HTTP的方式。端点的ID以及固定前缀<code>/actuator</code>组合成访问该端点的URL。例如对于<code>health</code>端点，其访问方式为：<code>/actuator/health</code> </p>
<p> <a href="https://github.com/spring-projects/spring-boot/tree/v2.4.6/spring-boot-project/spring-boot-actuator"><code>spring-boot-actuator</code></a>内置了一大堆开箱即用的端点，详情参考源文档。此外，当应用程序是一个Web应用（Spring MVC、Spring WebFlux或者Jersey），如下内置的额外端点：</p>
<table>
<thead>
<tr>
<th align="center">端点ID</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>heapdump</code></td>
<td align="center">返回一个<code>hprof</code>堆转储文件，需要HotSpot虚拟机支持</td>
</tr>
<tr>
<td align="center"><code>jolokia</code></td>
<td align="center">通过HTTP暴露JMX bean（需要Jolokia在classpath内，且不适用于WebFlux），需要增加<code>jolokia-core</code>依赖</td>
</tr>
<tr>
<td align="center"><code>logfile</code></td>
<td align="center">返回日志文件的内容（如果logging.file.name或logging.file.path属性被设置），并且支持使用HTTP <code>Range</code>头检索部分日志文件的内容</td>
</tr>
<tr>
<td align="center"><code>prometheus</code></td>
<td align="center">将metrics暴露成可以被Prometheus服务器抓取的格式，需要添加<code>micrometer-registry-prometheus</code>依赖</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>译者提示</strong></p>
<ul>
<li>对于任意端点来说，可以对其进行两种操作：1、开启或关闭端点；2、通过HTTP或者JMX暴露（exposed）它。当某个端点被开启且被暴露时该端点才处于可用状态。而系统内置端点只有在可用时才会被自动装配。</li>
<li>产品就绪特性属于Spring Boot的六大特性之一，详情可以参考<a href="https://spring.io/projects/spring-boot">官方文档Features</a>一节</li>
<li>自动装配属于Spring Boot的六大特性之一，简单来说，自动装配就是：如果检测到用户需要某个组件（例如发现引入了某个组件类库），并且用户还没有进行配置，那就启用内部自动装配逻辑，帮用户配置好。例如，如果用户引入了<code>spring-boot-starter-logging</code>，接下来不需要进行一大堆的日志配置，直接记录日志。这个术语会在本文档中多次提及。</li>
<li>端点（Endpoints）和指标（metrics）是本文最重要的两个概念，占据了本文的大部分篇幅。端点的概念不难理解，属于Spring Boot Actuator的核心功能，从系统内部代码层面讲，就是一个个内置的自动装配的以及用户自定义的端点 bean，从外部用户角度讲，就是一个个可以访问的数据集合窗口（可以通过jmx或http）。而指标有时候指的就是众多端点中的<code>metrics</code>端点，有时候指的是<code>metrics</code>端点下的被Spring Boot使用micrometer采集到的指标。理解了这些，实际上就理解整篇文章的精髓。</li>
</ul>
</blockquote>
<h2 id="开启端点（Enabling-Endpoints）"><a href="#开启端点（Enabling-Endpoints）" class="headerlink" title="开启端点（Enabling Endpoints）"></a>开启端点（Enabling Endpoints）</h2><p>默认情况下，除了<code>shutdown</code>端点，其他所有端点默认处于<strong>开启状态</strong>。如果要开关某个端点，可以配置：<code>management.endpoint.&lt;端点id&gt;.enabled</code>，例如开启<code>shutdown</code>端点的配置为：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">shutdown:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>如果希望所有端点默认都是关闭状态，可以将<code>management.endpoints.enabled-by-default</code>配置为<code>false</code>，然后将某端点的<code>enabled</code>属性配置为<code>true</code>来单独开启。以<code>info</code>端点举例（只开启<code>info</code>端点，其他端点都关闭）：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">enabled-by-default:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">info:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>提示</strong></p>
<p>当某个端点被关闭后，对应的端点bean会从Spring容器（application context）中移除。如果仅仅是不想让某个端点被暴露，可以使用<a href="#%E6%9A%B4%E9%9C%B2%E7%AB%AF%E7%82%B9%EF%BC%88Exposing-Endpoints%EF%BC%89">include和exclude</a>属性。</p>
</blockquote>
<h2 id="暴露端点（Exposing-Endpoints）"><a href="#暴露端点（Exposing-Endpoints）" class="headerlink" title="暴露端点（Exposing Endpoints）"></a>暴露端点（Exposing Endpoints）</h2><p>因为端点可能会包含敏感信息，因此在决定暴露端点前需要仔细考虑。下表展示了内置端点的默认暴露状态（简而言之：JMX下默认全开，HTTP下只有<code>health</code>开启）：</p>
<table>
<thead>
<tr>
<th align="left">ID</th>
<th align="left">JMX</th>
<th align="left">Web</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>auditevents</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>beans</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>caches</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>conditions</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>configprops</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>env</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>flyway</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>health</code></td>
<td align="left">Yes</td>
<td align="left">Yes</td>
</tr>
<tr>
<td align="left"><code>heapdump</code></td>
<td align="left">N&#x2F;A</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>httptrace</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>info</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>integrationgraph</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>jolokia</code></td>
<td align="left">N&#x2F;A</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>logfile</code></td>
<td align="left">N&#x2F;A</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>loggers</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>liquibase</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>metrics</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>mappings</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>prometheus</code></td>
<td align="left">N&#x2F;A</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>quartz</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>scheduledtasks</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>sessions</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>shutdown</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>startup</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>threaddump</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
</tbody></table>
<p>如果想调整某个端点的暴露状态，可以使用如下<code>include</code>和<code>exclude</code>属性：</p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>management.endpoints.jmx.exposure.exclude</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>management.endpoints.jmx.exposure.include</code></td>
<td align="center">*</td>
</tr>
<tr>
<td align="center"><code>management.endpoints.web.exposure.exclude</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>management.endpoints.web.exposure.include</code></td>
<td align="center"><code>health</code></td>
</tr>
</tbody></table>
<p><code>include</code>属性列出的是需要开启暴露的端点的id集合，而<code>exclude</code>属性列出的是关闭暴露的端点的id集合。<code>exclude</code>的优先级<strong>高于</strong><code>include</code>，且这两个属性都可以配置为一个以端点ID列表。</p>
<p>例如，如果只想通过JMX暴露<code>health</code>和<code>info</code>端点，而禁止暴露其他端点，可以使用如下配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">jmx:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;health,info&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>*</code>代表所有端点。例如，如果想通过HTTP的方式暴露除了<code>env</code>和<code>beans</code>之外的所有端点，可以使用如下配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">        <span class="attr">exclude:</span> <span class="string">&quot;env,beans&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>提示</strong></p>
<ul>
<li><code>*</code>在YAML中具有特殊含义，因此在<code>include</code>和<code>exclude</code>中使用时需要添加双引号</li>
<li>如果应用程序暴露在外网环境中，强烈建议<a href="#%E5%8A%A0%E5%9B%BAHTTP%E7%AB%AF%E7%82%B9%EF%BC%88Securing-HTTP-Endpoints%EF%BC%89">加固HTTP端点</a></li>
<li>如果想自定义端点的暴露策略，可以注册一个<code>EndpointFilter</code> bean</li>
</ul>
</blockquote>
<h2 id="加固HTTP端点（Securing-HTTP-Endpoints）"><a href="#加固HTTP端点（Securing-HTTP-Endpoints）" class="headerlink" title="加固HTTP端点（Securing HTTP Endpoints）"></a>加固HTTP端点（Securing HTTP Endpoints）</h2><p>信息敏感的URL需要进行安全加固，而对于HTTP方式的端点也应该得到相同待遇的处理。如果使用了<a href="https://spring.io/projects/spring-security">Spring Security</a>，端点默认会被<code>Spring Security</code>的内容协商策略（content-negotiation strategy）加固，例如只允许具有某种角色（role）的用户访问。Spring Boot提供了一些方便使用的<code>RequestMatcher</code>对象，可以配合<code>Spring Security</code>使用。</p>
<p>典型的<code>Spring Security</code>配置如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySecurityConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">securityFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http.requestMatcher(EndpointRequest.toAnyEndpoint())</span><br><span class="line">                .authorizeRequests((requests) -&gt; requests.anyRequest().hasRole(<span class="string">&quot;ENDPOINT_ADMIN&quot;</span>));</span><br><span class="line">        http.httpBasic();</span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子中，<code>EndpointRequest.toAnyEndpoint()</code>用来匹配任意端点，然后还会确保用户拥有<code>ENDPOINT_ADMIN</code>角色。<code>EndpointRequest</code>中还有其他类似的匹配函数。可以查看API文档（<a href="https://docs.spring.io/spring-boot/docs/2.5.0/actuator-api/htmlsingle">HTML</a>或<a href="https://docs.spring.io/spring-boot/docs/2.5.0/actuator-api/pdf/spring-boot-actuator-web-api.pdf">PDF</a>）获得更多详情。</p>
<p>如果应用程序部署在防火墙后面，可以允许所有端点被访问而无需进行鉴权。此时可以将<code>management.endpoints.web.exposure.include</code>配置为**<code>*</code>**，如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure>

<p>此外，如果使用了<code>Spring Security</code>，并且想允许未经过身份验证的访问，还需要一些自定义配置，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySecurityConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">securityFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http.requestMatcher(EndpointRequest.toAnyEndpoint())</span><br><span class="line">                .authorizeRequests((requests) -&gt; requests.anyRequest().permitAll());</span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>提示</strong></p>
<p>以上两个例子中的配置仅对端点请求生效。而对于<code>Spring Boot</code>来说，当存在用户自定义的<code>SecurityFilterChain</code> bean时，其安全配置就会自动失效。因此需要配置额外的<code>SecurityFilterChain</code>来适配应用程序的其他请求</p>
</blockquote>
<h2 id="配置端点（Configuring-Endpoints）"><a href="#配置端点（Configuring-Endpoints）" class="headerlink" title="配置端点（Configuring Endpoints）"></a>配置端点（Configuring Endpoints）</h2><p>对于端点中不包含参数的读操作（read operations）请求，端点会自动缓存响应数据（response），如果要修改某端点的缓存时间，可以配置<code>cache.time-to-live</code> 属性，如下配置就是将<code>beans</code>端点的缓存时间改成10秒：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">beans:</span></span><br><span class="line">      <span class="attr">cache:</span></span><br><span class="line">        <span class="attr">time-to-live:</span> <span class="string">&quot;10s&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>提示</strong></p>
<p><code>management.endpoint.&lt;name&gt;</code>前缀用于标识要配置的端点</p>
</blockquote>
<h2 id="Hypermedia-for-Actuator-Web-Endpoints"><a href="#Hypermedia-for-Actuator-Web-Endpoints" class="headerlink" title="Hypermedia for Actuator Web Endpoints"></a>Hypermedia for Actuator Web Endpoints</h2><h2 id="跨域资源共享支持（CORS-Support）"><a href="#跨域资源共享支持（CORS-Support）" class="headerlink" title="跨域资源共享支持（CORS Support）"></a>跨域资源共享支持（CORS Support）</h2><p><a href="https://en.wikipedia.org/wiki/Cross-origin_resource_sharing">跨域资源共享</a>（CORS）是一个<a href="https://www.w3.org/TR/cors/">W3C规范</a>，可以协助制定灵活的跨域访问授权策略。如果你在使用Spring MVC或者Spring WebFlux，Web端点可以支持支持中场景。</p>
<p>CORS默认是被关闭的，并且只有<code>management.endpoints.web.cors.allowed-origins</code>被配置后才会开启，下面配置允许来自于<code>example.com</code>的<code>GET</code>和<code>POST</code>请求：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">cors:</span></span><br><span class="line">        <span class="attr">allowed-origins:</span> <span class="string">&quot;https://example.com&quot;</span></span><br><span class="line">        <span class="attr">allowed-methods:</span> <span class="string">&quot;GET,POST&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>提示</strong></p>
<p>到 <a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/endpoint/web/CorsEndpointProperties.java">CorsEndpointProperties</a>查看完整的属性列表</p>
</blockquote>
<h2 id="实现自定义端点（Implementing-Custom-Endpoints）"><a href="#实现自定义端点（Implementing-Custom-Endpoints）" class="headerlink" title="实现自定义端点（Implementing Custom Endpoints）"></a>实现自定义端点（Implementing Custom Endpoints）</h2><p>如果一个<code>@Bean</code>被<code>@Endpoint</code>注解，那么任意被注解了<code>@ReadOperation</code>、<code>@WriteOperation</code>或者<code>@DeleteOperation</code>的方法都以JMX方式暴露，而对于Web应用程序，则会以HTTP的方式暴露。当使用Jersey、Spring MVC或者Spring WebFlux时，端点可以通过HTTP暴露。当Jersey和Spring MVC都可用时，Spring MVC优先被使用。</p>
<p>以下例子暴露一个读操作（read operation），该操作返回了一个自定义对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ReadOperation</span></span><br><span class="line"><span class="keyword">public</span> CustomData <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomData</span>(<span class="string">&quot;test&quot;</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用<code>@JmxEndpoint</code>或<code>@WebEndpoint</code>注解来开启特定方式的端点（JMX或者Web）。</p>
<p>可以使用<code>@EndpointWebExtension</code>或<code>@EndpointJmxExtension</code>，这两个注解可以对特定方式的端点进行增强（JMX或者Web）</p>
<blockquote>
<p><strong>笔者提示</strong></p>
<p>对于注解了<code>@Endpoint</code>的<code>@Bean</code>，由于既可以通过JMX方式暴露，又可以通过HTTP的方式暴露（后文称这种端点为<strong>原生端点</strong>）。为了兼容性的需要，不得不放弃某些技术特性。因此Spring设计了<code>@EndpointWebExtension</code>或<code>@EndpointJmxExtension</code>（从Spring Boot 2.2.0开始，还增加了<code>@EndpointCloudFoundryExtension</code>注解），这些注解的作用对原生端点进行技术特级别的扩展。例如对于以HTTP方式暴露的某个端点，可以为响应数据（Response）增加一个状态码（而JMX方式就不需要这个状态码），那么就可以使用<code>@EndpointWebExtension</code>对原生端点进行二次加工，示例可以参考源码中<a href="https://github.com/spring-projects/spring-boot/blob/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/env/EnvironmentEndpointWebExtension.java"><code>EnvironmentEndpointWebExtension</code></a>的实现</p>
</blockquote>
<p>最后，如果需要使用web框架相关的功能，可以实现<code>Servlet</code>或者使用Spring <code>@Controller</code>、<code>@RestController</code>端点，不过代价是通过JMX方式暴露就不可用，并且当使用其他web框架时也不可用。</p>
<h3 id="入参处理（Receiving-Input）"><a href="#入参处理（Receiving-Input）" class="headerlink" title="入参处理（Receiving Input）"></a>入参处理（Receiving Input）</h3><p>通过参数的方式，端点的操作（Operations）来接收输入。当通过web暴露时，这些参数来自于请求的查询参数或者请求body中的JSON对象。当通过JMX暴露时，这些参数从<a href="https://docs.oracle.com/javase/tutorial/jmx/mbeans/index.html">MBean</a>映射而来。默认情况下，参数是必须输入的。不过可以通过添加注解<code>@javax.annotation.Nullable</code>或<code>@org.springframework.lang.Nullable</code>使之成为可选参数。</p>
<p>对于web请求body中JSON对象，每个属性值都可以被映射为端点的一个参数，例如请求body中的json结构为：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;test&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;counter&quot;</span><span class="punctuation">:</span> <span class="number">42</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>那么可以开发这么一个包含<code>String name</code>和<code>int counter</code>参数的端点与之对应，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WriteOperation</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateData</span><span class="params">(String name, <span class="type">int</span> counter)</span> &#123;</span><br><span class="line">    <span class="comment">// injects &quot;test&quot; and 42</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>提示</strong></p>
<ul>
<li>由于原生端点的兼容性需要，因此端点的入参只能是基本类型，因此不支持将<code>name</code>和<code>counter</code>封装到<code>CustomData</code>。</li>
<li>如果想要将输入参数映射到函数的参数上，当编译Java代码时，需要使用<code>-parameters</code>参数，而对于Kotlin代码，则需要使用<code>-java-parameters</code>，如果在Gradle中使用了Spring Boot的插件或者在Maven中使用了<code>spring-boot-starter-parent</code>这个参数已经被自动开启。（关于<code>-parameters</code>的更多细节，可以参考<a href="https://stackoverflow.com/questions/31845676/how-to-compile-spring-boot-applications-with-java-8-parameter-flag">StackOverflow</a>的这个解答）</li>
</ul>
</blockquote>
<h4 id="输入类型转换"><a href="#输入类型转换" class="headerlink" title="输入类型转换"></a>输入类型转换</h4><p>在必要的情况下，传给端点的参数会被自动转换为端点的参数类型。在调用端点的操作函数（operation method）之前，通过JMX或HTTP请求的参数通过<code>ApplicationConversionService</code>对象和任意被<code>@EndpointConverter</code>注解标识的<code>Converter</code>或<code>GenericConverter</code>转换。</p>
<h3 id="自定义Web端点（Custom-Web-Endpoints）"><a href="#自定义Web端点（Custom-Web-Endpoints）" class="headerlink" title="自定义Web端点（Custom Web Endpoints）"></a>自定义Web端点（Custom Web Endpoints）</h3><p>被<code>@Endpoint</code>、<code>@WebEndpoint</code>或<code>@EndpointWebExtension</code>注解的端点会自动通过Jersey、Spring MVC或Spring WebFlux以HTTP的方式暴露。而如果Jersey和Spring MVC都可用，那么Spring MVC会被启用。</p>
<h4 id="Web端点请求谓词（Web-Endpoint-Request-Predicates）"><a href="#Web端点请求谓词（Web-Endpoint-Request-Predicates）" class="headerlink" title="Web端点请求谓词（Web Endpoint Request Predicates）"></a>Web端点请求谓词（Web Endpoint Request Predicates）</h4><p>对于每个HTTP端点的任意操作（operation），都会自动生成一个HTTP请求谓词</p>
<h4 id="路径（Path）"><a href="#路径（Path）" class="headerlink" title="路径（Path）"></a>路径（Path）</h4><p>请求谓词的路径取决于端点的ID和根路径（指的是以web方式暴露的根路径），默认的根路径是<code>/actuator</code>。例如，<code>sessions</code>端点的谓词路径就是<code>/actuator/sessions</code></p>
<p>可以通过在端点的函数入参上增加<code>@Selector</code>注解实现路径的自定义解析。这些解析后的请求参数会被以路径变量的方式加入到请求谓词中。当端点的函数被调用时，这些路径变量会被当做入参传入。如果想捕获完整路径上所有剩余元素（每个被“&#x2F;”分割的字符串都是一个元素），可以在最后一个函数入参上使用<code>@Selector(Match=ALL_REMAINING)</code>注解，这会把所有的元素转换为<code>String[]</code>数组。</p>
<h4 id="HTTP方法（HTTP-method）"><a href="#HTTP方法（HTTP-method）" class="headerlink" title="HTTP方法（HTTP method）"></a>HTTP方法（HTTP method）</h4><p>请求谓词中的HTTP方法取决于操作类型，如下表所示：</p>
<table>
<thead>
<tr>
<th align="center">操作类型</th>
<th align="center">HTTP方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>@ReadOperation</code></td>
<td align="center"><code>GET</code></td>
</tr>
<tr>
<td align="center"><code>@WriteOperation</code></td>
<td align="center"><code>POST</code></td>
</tr>
<tr>
<td align="center"><code>@DeleteOperation</code></td>
<td align="center"><code>DELETE</code></td>
</tr>
</tbody></table>
<h4 id="请求媒体类型（Consumes）"><a href="#请求媒体类型（Consumes）" class="headerlink" title="请求媒体类型（Consumes）"></a>请求媒体类型（Consumes）</h4><p>对于HTTP POST方式的<code>@WriteOperation</code>，其请求（Request）的媒体类型（Content-Type）为<code>application/vnd.spring-boot.actuator.v2+json, application/json</code>，而其他操作类型则为空。</p>
<h4 id="响应媒体类型（Produces）"><a href="#响应媒体类型（Produces）" class="headerlink" title="响应媒体类型（Produces）"></a>响应媒体类型（Produces）</h4><p>响应（Response）的媒体类型由<code>@DeleteOperation</code>、<code>@ReadOperation</code>和<code>@WriteOperation</code>注解内的<code>produces</code>属性决定。这个属性是可选的，如果没有配置，那么媒体类型会被自动设置。</p>
<p>如果操作函数的返回值是<code>void</code>或者<code>Void</code>，那么媒体类型为空。如果返回一个<code>org.springframework.core.io.Resource</code>，那么媒体类型类型为<code>application/octet-stream</code>（也即二进制流数据）。而其他的所有的操作，媒体类型都是<code>application/vnd.spring-boot.actuator.v2+json, application/json</code>。</p>
<h4 id="Web端点的响应状态码（Web-Endpoint-Response-Status）"><a href="#Web端点的响应状态码（Web-Endpoint-Response-Status）" class="headerlink" title="Web端点的响应状态码（Web Endpoint Response Status）"></a>Web端点的响应状态码（Web Endpoint Response Status）</h4><p>默认的响应状态码取决于操作类型（<code>@DeleteOperation</code>、<code>@ReadOperation</code>和<code>@WriteOperation</code>）和返回值（如果有返回值的话）。</p>
<ul>
<li><p>如果一个<code>@ReadOperation</code>返回了一个值，那么状态码是200（OK）。否则的话，状态码是404（Not Found）。</p>
</li>
<li><p>如果一个<code>@WriteOpertion</code>或<code>@DeleteOperation</code>返回了一个值，那么状态码是200（OK）。否则的话，状态码是204（No Cpmtemt）。</p>
</li>
<li><p>如果一个操作被调用了而没有传入必须的参数，或者说参数没有被正确转换，那么操作函数将不会被调用，返回一个400（Bad Request）状态码</p>
</li>
</ul>
<h4 id="Web端点范围请求（Web-Endpoint-Range-Requests）"><a href="#Web端点范围请求（Web-Endpoint-Range-Requests）" class="headerlink" title="Web端点范围请求（Web Endpoint Range Requests）"></a>Web端点范围请求（Web Endpoint Range Requests）</h4><p>可以使用HTTP范围请求来获取HTTP资源。当使用Spring MVC或Spring WebFlux时，如果某个操作返回了<code>org.springframework.core.io.Resource</code>，那么范围请求会被自动支持。</p>
<blockquote>
<p><strong>提示</strong></p>
<p>Jersey不支持范围请求</p>
</blockquote>
<h4 id="Web端点安全（Web-Endpoint-Security）"><a href="#Web端点安全（Web-Endpoint-Security）" class="headerlink" title="Web端点安全（Web Endpoint Security）"></a>Web端点安全（Web Endpoint Security）</h4><p>对于web方式的端点或者web相关的端点扩展（web-specific endpoint extension），它们都可以接收<code>java.security.Principal</code>或 <code>org.springframework.boot.actuate.endpoint.SecurityContext</code>作为操作函数的参数。前者通常配合<code>@Nullable</code>使用，为经过身份验证和未经过身份验证的用户提供不同的行为。而后者通常使用<code>isUserInRole(Sring)</code>进行权限检查</p>
<h3 id="Servlet端点（Servlet-Endpoints）"><a href="#Servlet端点（Servlet-Endpoints）" class="headerlink" title="Servlet端点（Servlet Endpoints）"></a>Servlet端点（Servlet Endpoints）</h3><p>当同时满足如下两个条件后，就可以实现一个Servlet端点：</p>
<ul>
<li>实现一个<code>Supplier&lt;EndpointServlet&gt;</code>类</li>
<li>同时该类上增加<code>@ServletEndpoint</code>注解</li>
</ul>
<p>Servlet端点可以和Servlet容器更深层地集成，但是牺牲了可移植性。这种方式的应用场景就是可以将已有的Servlet转化为端点。而对于新的端点，仍然尽量使用<code>@Endpoint</code>或<code>@WebEndpoint</code></p>
<h4 id="Controller端点（Controller-Endpoints）"><a href="#Controller端点（Controller-Endpoints）" class="headerlink" title="Controller端点（Controller Endpoints）"></a>Controller端点（Controller Endpoints）</h4><p><code>@ControllerEndpoint</code>和<code>@RestControllerEndpoint</code>端点只可以在Spring MVC和Spring WebFlux下使用。当使用Spring MVC或Spring WebFlux的标准注解，例如<code>@RequestMapping</code> 和<code>@GetMapping</code>时，端点的操作方法都可以被正常映射，并且以端点的ID作为请求路径（path）的前缀。Controller端点提供了和Srping web框架更深的集成度，然而牺牲了可移植性。因此，尽量优先使用<code>@Endpoint</code>或<code>@WebEndpoint</code>端点。</p>
<h2 id="健康信息（Health-Information）"><a href="#健康信息（Health-Information）" class="headerlink" title="健康信息（Health Information）"></a>健康信息（Health Information）</h2><p>可以通过健康信息检查应用程序的运行状态。健康信息通常被用来监控应用，并且在系统宕机时进行报警。<code>health</code>端点暴露的信息详情取决于<code>management.endpoint.health.show-details</code> 和<code>management.endpoint.health.show-components</code>属性的配置，可以配置的值如下所示：</p>
<table>
<thead>
<tr>
<th align="center">配置值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>never</code>（默认值）</td>
<td align="center">详情不可见</td>
</tr>
<tr>
<td align="center"><code>when-authorized</code></td>
<td align="center">详情仅对授权用户可见。授权用户可以通过<code>management.endpoint.health.roles</code>配置</td>
</tr>
<tr>
<td align="center"><code>always</code></td>
<td align="center">详情对所有用户可见</td>
</tr>
</tbody></table>
<p>当一个用户拥有一个或多个端点角色（endpoint’s roles）时，他被认为是授权的。如果某个端点没有配置角色（这是默认状态），那么所有通过身份认证的用户都任务是被授权的。可以通过<code>management.endpoint.health.roles</code>配置角色。</p>
<blockquote>
<p><strong>提示</strong></p>
<p>如果已经对应用程序进行安全控制（ secured your application），而想使用<code>always</code>配置，那么需要对安全配置进行设置，是的所有经过身份认证和未经过身份认证的用户都获得访问权限</p>
</blockquote>
<p>健康信息是 <a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/HealthContributorRegistry.java"><code>HealthContributorRegistry</code></a>中收集所有健康数据的集合。默认情况下，这些健康数据是Spring上下文（<code>ApplicationContext</code>）中一个个<a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/HealthContributor.java"><code>HealthContributor</code></a>实例，Spring Boot已经自动装配了很多<code>HealthContributors</code>，用户也可以自己实现。</p>
<p><code>HealthContributor</code>既可以是一个<code>HealthIndicator</code> 也可以是一个<code>CompositeHealthContributor</code>，前者提供了实际的健康数据，并包含一个<code>Status</code>，后者提供了和其他<code>HealthIndicator</code>组合的能力。最终，所有这些<code>HealthContributor</code>形成了一个树状结构，来展示整个系统的健康状态。</p>
<p>默认情况下，系统的最终健康状态由<code>Statusaggregator</code>计算获得。<code>Statusaggregator</code>的实现类<code>SimpleStatusAggregator</code>的实现算法：</p>
<ul>
<li>内部维护了一个健康状态的有序列表，排序为：<code>DOWN</code>、<code>OUT_OF_SERVICE</code>、<code>UP</code>、<code>UNKNOWN</code></li>
<li>对于外部传入的状态集合，首先过滤掉不识别的状态码（也即只保留这4个状态码）</li>
<li>算出每个状态在有序列表中的索引，并取出索引值最小的状态，作为最终状态（实际上就是跟进有序列表的顺序进行排序）</li>
<li>如果剩下的集合是空的，那么返还一个<code>UNKNOWN</code>状态（这种情形只发生所有传入的状态都不属于这4种状态的情况下）</li>
</ul>
<blockquote>
<p><strong>提示</strong></p>
<p><code>HealthContributorRegistry</code>可以在运行状态下动态注册和反注册</p>
</blockquote>
<h3 id="自动装配的HealthIndicators（Auto-configured-HealthIndicators）"><a href="#自动装配的HealthIndicators（Auto-configured-HealthIndicators）" class="headerlink" title="自动装配的HealthIndicators（Auto-configured HealthIndicators）"></a>自动装配的HealthIndicators（Auto-configured HealthIndicators）</h3><p>Spring Boot已经自动装配了很多<code>HealthIndicator</code>，可以通过<code>management.health.&lt;key&gt;.enabled</code>将其开启或关闭</p>
<blockquote>
<p><strong>提示</strong></p>
<ul>
<li>详细的<code>HealthIndicator</code>列表不再赘述，详情参考<a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.endpoints.health.auto-configured-health-indicators">源文档</a></li>
<li>可以通过设置<code>management.health.defaults.enabled</code>关闭所有的<code>HealthIndicator</code></li>
</ul>
</blockquote>
<p>以下<code>HealthIndicator</code>也是可用的，但是默认情况下没有被启用：</p>
<table>
<thead>
<tr>
<th align="center">Key</th>
<th align="center">名字</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>livenessstate</code></td>
<td align="center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/availability/LivenessStateHealthIndicator.java"><code>LivenessStateHealthIndicator</code></a></td>
<td align="center">暴露应用程序的<code>活性</code>状态</td>
</tr>
<tr>
<td align="center"><code>readinessstate</code></td>
<td align="center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/availability/ReadinessStateHealthIndicator.java"><code>ReadinessStateHealthIndicator</code></a></td>
<td align="center">暴露应用程序的<code>就绪</code>状态</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>笔者提示</strong></p>
<ul>
<li>关于<code>活性</code>状态，Spring Boot在<a href="https://github.com/spring-projects/spring-boot/blob/v2.5.0/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/availability/LivenessState.java">源码</a>中有详细的解释：当应用程序的内部状态是正确的（CORRECT），那么它被认为是存活的。而<code>失活</code>状态意味着应用程序内部状态已经出现严重异常（BROKEN）而且无法正常恢复，只能通过重启应用解决该异常。相应地，活性状态有两个状态，分别为：<code>CORRECT</code>和<code>BROKEN</code>。</li>
<li>关于<code>就绪</code>状态，Spring Boot在<a href="https://github.com/spring-projects/spring-boot/blob/v2.5.0/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/availability/ReadinessState.java">源码</a>中也有详细的解释：当应用程序处于存活（也即活性状态为CORRECT）状态且可以接受流量时，被认为是就绪的（ACCEPTING_TRAFFIC）。而当应用程序无法接受流量时意味着就绪失败（REFUSING_TRAFFIC），基础设施必须停止对其路由。相应地，就行状态也包含两种：<code>ACCEPTING_TRAFFIC</code>和<code>REFUSING_TRAFFIC</code>（也就是说就绪状态更倾向于一个web术语）</li>
</ul>
</blockquote>
<h3 id="自定义HealthIndicators（Writing-Custom-HealthIndicators）"><a href="#自定义HealthIndicators（Writing-Custom-HealthIndicators）" class="headerlink" title="自定义HealthIndicators（Writing Custom HealthIndicators）"></a>自定义HealthIndicators（Writing Custom HealthIndicators）</h3><p>可以通过注册 <a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/HealthIndicator.java"><code>HealthIndicator</code></a> 接口的Bean实现自定义的监控数据。该接口类需要实现<code>health()</code>方法并且返回一个<code>Health</code>类。该返回值必须包含一个状态，并且可选择性地包含详细信息以供显示。以下代码展示了一个<code>HealthIndicator</code>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyHealthIndicator</span> <span class="keyword">implements</span> <span class="title class_">HealthIndicator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Health <span class="title function_">health</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">errorCode</span> <span class="operator">=</span> check();</span><br><span class="line">        <span class="keyword">if</span> (errorCode != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Health.down().withDetail(<span class="string">&quot;Error Code&quot;</span>, errorCode).build();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Health.up().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">check</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// perform some specific health check</span></span><br><span class="line">        <span class="keyword">return</span> ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>提示</strong></p>
<p><code>HealthIndicator</code>接口类的名字去掉<code>HealthIndicator</code>后缀（如果存在的话）会作为Bean的名字，上述实例中，这个自定义<code>HealthIndicator</code>的名字是my。</p>
</blockquote>
<p>除了Srping Boot内置的<a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/Status.java"><code>Status</code></a>之外，返回的<code>Health</code>内也可以使用自定义的状态。在这种情况下，需要实现一个自定义的<a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/StatusAggregator.java"><code>StatusAggregator</code></a> ，或者对<code>management.endpoint.health.status.order</code>属性进行配置，来替代默认的状态配置。</p>
<p>例如，假如在某个<code>HealthIndicator</code>内返回了一个自定义状态：<code>FATAL</code>，为了配置优先级，需要增加如下配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">health:</span></span><br><span class="line">      <span class="attr">status:</span></span><br><span class="line">        <span class="attr">order:</span> <span class="string">&quot;fatal,down,out-of-service,unknown,up&quot;</span></span><br></pre></td></tr></table></figure>

<p>HTTP的响应状态码反映了系统的整体监控状态。默认情况下，<code>OUT_OF_SERVICE</code>和<code>DOWN</code>的状态码是503。所有没有配置映射的健康状态（包括<code>UP</code>），其状态码为200。如果对自定义健康状态的状态码进行了配置，那么<code>DOWN</code>和<code>OUT_OF_SERVICE</code>的默认状态码会被禁用。如果仍然想保留这些配置，需要和自定义的状态一起进行显式地定义。下面的例子中，将<code>FATAL</code>映射为503（service unavailable），并且保留了<code>DOWN</code>和<code>OUT_OF_SERVICE</code>的原有的配置</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">health:</span></span><br><span class="line">      <span class="attr">status:</span></span><br><span class="line">        <span class="attr">http-mapping:</span></span><br><span class="line">          <span class="attr">down:</span> <span class="number">503</span></span><br><span class="line">          <span class="attr">fatal:</span> <span class="number">503</span></span><br><span class="line">          <span class="attr">out-of-service:</span> <span class="number">503</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>提示</strong></p>
<p>如果想要更多控制权，可以实现一个自定义的<code>HttpCodeStatusMapper</code> Bean</p>
</blockquote>
<p>以下表格展示了内置状态的默认映射配置：</p>
<table>
<thead>
<tr>
<th align="center">状态</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>DOWN</code></td>
<td align="center"><code>SERVICE_UNAVAILABLE</code> (<code>503</code>)</td>
</tr>
<tr>
<td align="center"><code>OUT_OF_SERVICE</code></td>
<td align="center"><code>SERVICE_UNAVAILABLE</code> (<code>503</code>)</td>
</tr>
<tr>
<td align="center"><code>UP</code></td>
<td align="center">默认没有映射，所以状态码是<code>200</code></td>
</tr>
<tr>
<td align="center"><code>UNKNOWN</code></td>
<td align="center">默认没有映射，所以状态码是<code>200</code></td>
</tr>
</tbody></table>
<h3 id="响应式健康指示器（Reactive-Health-Indicators）"><a href="#响应式健康指示器（Reactive-Health-Indicators）" class="headerlink" title="响应式健康指示器（Reactive Health Indicators）"></a>响应式健康指示器（Reactive Health Indicators）</h3><p>对于响应式的应用，例如使用了Spring WebFlux，<code>ReactiveHealthContributor</code>提供了非阻塞的契约来获得应用的健康信息。和传统的<code>HealthContributor</code>很类似，其健康信息收集自<a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/ReactiveHealthContributorRegistry.java"><code>ReactiveHealthContributorRegistry</code></a>（默认情况下，所有的 <a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/HealthContributor.java"><code>HealthContributor</code></a>和<a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/ReactiveHealthContributor.java"><code>ReactiveHealthContributor</code></a> 实例都在<code>ApplicationContext</code>中）。在弹性调度器下（elastic scheduler），常规的<code>HealthContributors</code>并不会调用响应式的API。</p>
<blockquote>
<p><strong>提示</strong></p>
<p>在响应式应用中，<code>ReactiveHealthContributorRegistry</code>应该在运行时状态下注册或反注册健康指示器（health indicators），如果想注册常规的<code>HealthContributor</code>，需要使用<code>ReactiveHealthContributor#adapt</code>对其包装。</p>
</blockquote>
<p>如果想通过响应式API提供自定义健康指示器（health indicators），可以注册实现了<a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/ReactiveHealthIndicator.java"><code>ReactiveHealthIndicator</code></a> 接口的Bean到Spring容器中，以下代码展示了一个<code>ReactiveHealthIndicator</code>的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyReactiveHealthIndicator</span> <span class="keyword">implements</span> <span class="title class_">ReactiveHealthIndicator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Health&gt; <span class="title function_">health</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> doHealthCheck().onErrorResume((exception) -&gt;</span><br><span class="line">            Mono.just(<span class="keyword">new</span> <span class="title class_">Health</span>.Builder().down(exception).build()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Mono&lt;Health&gt; <span class="title function_">doHealthCheck</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// perform some specific health check</span></span><br><span class="line">        <span class="keyword">return</span> ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>提示</strong></p>
<p>如果想自动处理异常错误，可以继承<code>AbstractReactiveHealthIndicator</code></p>
</blockquote>
<h3 id="自动装配的ReactiveHealthIndicators（Auto-configured-ReactiveHealthIndicators）"><a href="#自动装配的ReactiveHealthIndicators（Auto-configured-ReactiveHealthIndicators）" class="headerlink" title="自动装配的ReactiveHealthIndicators（Auto-configured ReactiveHealthIndicators）"></a>自动装配的ReactiveHealthIndicators（Auto-configured ReactiveHealthIndicators）</h3><p>Spring提供了一些内置的响应式健康指示器（<code>ReactiveHealthIndicators</code>），当它们可以可用时（端点被开启且被正常暴露时即为可用），会被自动装配。详情<a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.endpoints.health.auto-configured-reactive-health-indicators">参考源文档第2.8.4节</a>的表格，此处不再赘述</p>
<blockquote>
<p><strong>提示</strong></p>
<p>在必要的情况下，响应式的指示器会替代非响应式的指示器。并且任何没有被处理过的<code>HealthIndicator</code>也会被自动包装为响应式</p>
</blockquote>
<h3 id="健康分组（Health-Groups）"><a href="#健康分组（Health-Groups）" class="headerlink" title="健康分组（Health Groups）"></a>健康分组（Health Groups）</h3><p>处于某些原因，将健康指示器进行分组是很有用的。</p>
<p>可以创建<code>management.endpoint.health.group.&lt;name&gt;</code>属性来创建一个健康分组。并且使用<code>include</code>和<code>exclude</code>属性来配置指示器ID。例如，假如想创建一个仅仅包含数据库指示器的分支，可以配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">health:</span></span><br><span class="line">      <span class="attr">group:</span></span><br><span class="line">        <span class="attr">custom:</span></span><br><span class="line">          <span class="attr">include:</span> <span class="string">&quot;db&quot;</span></span><br></pre></td></tr></table></figure>

<p>然后可以通过链接：<a href="http://localhost:8080/actuator/health/custom">localhost:8080&#x2F;actuator&#x2F;health&#x2F;custom</a>访问该分组</p>
<p>同理，如果想创建一个不包含数据库指示器的分组，可以配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">health:</span></span><br><span class="line">      <span class="attr">group:</span></span><br><span class="line">        <span class="attr">custom:</span></span><br><span class="line">          <span class="attr">exclude:</span> <span class="string">&quot;db&quot;</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，如同系统的健康信息一样，分组沿用了相同的<code>StatusAggregator</code>和<code>HttpCodeStatusMapper</code>设置。不过这些设置可以在每个分组上单独定义。如果有需要的话，还可以覆盖<code>show-details</code>和<code>roles</code>的配置，例如：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">health:</span></span><br><span class="line">      <span class="attr">group:</span></span><br><span class="line">        <span class="attr">custom:</span></span><br><span class="line">          <span class="attr">show-details:</span> <span class="string">&quot;when-authorized&quot;</span></span><br><span class="line">          <span class="attr">roles:</span> <span class="string">&quot;admin&quot;</span></span><br><span class="line">          <span class="attr">status:</span></span><br><span class="line">            <span class="attr">order:</span> <span class="string">&quot;fatal,up&quot;</span></span><br><span class="line">            <span class="attr">http-mapping:</span></span><br><span class="line">              <span class="attr">fatal:</span> <span class="number">500</span></span><br><span class="line">              <span class="attr">out-of-service:</span> <span class="number">500</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>提示</strong></p>
<p>如果想将自定义的<code>StatusAggregator</code>和<code>HttpCodeStatusMapper</code> Bean注册到某个分组上，可以使用注解<code>@Qualifier(&quot;groupname&quot;)</code>对其进行限定</p>
</blockquote>
<h3 id="数据源健康（DataSource-Health）"><a href="#数据源健康（DataSource-Health）" class="headerlink" title="数据源健康（DataSource Health）"></a>数据源健康（DataSource Health）</h3><p><code>DataSource</code>健康指示器用来展示标准数据源（standard data source）类型和路由数据源（routing data source）类型的Bean的健康信息。路由数据源的健康信息也包含了目标数据源（its target data sources）的健康信息。在监控信息端点的HTTP响应中，每一个路由数据源的目标数据源的名字，由路由键值（routing key）来决定。如果想把路由数据源排除，可以将<code>management.health.db.ignore-routing-data-sources</code>设置为true</p>
<h2 id="Kubernetes探针（Kubernetes-Probes）"><a href="#Kubernetes探针（Kubernetes-Probes）" class="headerlink" title="Kubernetes探针（Kubernetes Probes）"></a>Kubernetes探针（Kubernetes Probes）</h2><p>部署在Kubernetes上的应用程序可以通过<a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes">容器探针</a>反馈内部状态信息。kubelet可以根据<a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/">Kubernetes的配置</a>调用这些探针并反馈探针结果。</p>
<p>Spring Boot提供了开箱即用的<a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.spring-application.application-availability">应用程序可用性状态</a>管理。当应用程序被部署到Kubernetes环境下，Spring Boot Acuator会通过<code>ApplicationAvailability</code>接口收集“Liveness”和“Readiness”信息，并且在<a href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%9A%84ReactiveHealthIndicators%EF%BC%88Auto-configured-ReactiveHealthIndicators%EF%BC%89">健康指示器</a>：<code>LivenessStateHealthIndicator</code>和<code>ReadinessStateHealthIndicator</code>中使用这些信息。这些指示器的信息显示在全局端点（<code>&quot;/actuator/health&quot;</code>）中。也可用通过使用<a href="#%E5%81%A5%E5%BA%B7%E5%88%86%E7%BB%84%EF%BC%88Health-Groups%EF%BC%89">健康分组</a>：<code>&quot;/actuator/health/liveness&quot;</code> 和 <code>&quot;/actuator/health/readiness&quot;</code> 访问这些端点。</p>
<p>可以使用如下端点信息配置Kubernetes：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">livenessProbe:</span></span><br><span class="line">  <span class="attr">httpGet:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/actuator/health/liveness</span></span><br><span class="line">    <span class="attr">port:</span> <span class="string">&lt;actuator-port&gt;</span></span><br><span class="line">  <span class="attr">failureThreshold:</span> <span class="string">...</span></span><br><span class="line">  <span class="attr">periodSeconds:</span> <span class="string">...</span></span><br><span class="line"></span><br><span class="line"><span class="attr">readinessProbe:</span></span><br><span class="line">  <span class="attr">httpGet:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/actuator/health/readiness</span></span><br><span class="line">    <span class="attr">port:</span> <span class="string">&lt;actuator-port&gt;</span></span><br><span class="line">  <span class="attr">failureThreshold:</span> <span class="string">...</span></span><br><span class="line">  <span class="attr">periodSeconds:</span> <span class="string">...</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>提示</strong></p>
<p><code>&lt;actuator-port&gt;</code>应该被配置为一个可以被访问的端口号。可以将其配置为web服务器的端口，或者通过<code>management.endpoint.health.probes.enabled</code>配置，使用独立的端口</p>
</blockquote>
<p>这些健康分组只有在应用程序<a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/deployment.html#deployment.cloud.kubernetes">运行在Kubernetes环境下</a>时才会自动生效。当然，也可以通过配置<code>management.endpoint.health.probes.enabled</code>来开启这些功能。</p>
<blockquote>
<p><strong>提示</strong></p>
<p>如果应用程序的启动时间比liveness指示器所反映的时间要长，Kubernetes提供了一个<code>“startupProbe”</code>探针作为替代方案。不过<code>“startupProbe”</code>探针并不一定必须配置，因为在所有的启动任务完成之前<code>&quot;readinessProbe&quot;</code>探针都处于失败状态。可以查看<a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.endpoints.kubernetes-probes.lifecycle">探针在应用程序生命周期中的行为</a></p>
</blockquote>
<blockquote>
<p><strong>警告</strong></p>
<p>如果端点（Actuator endpoints）被配置在独立的Spring上下文（a separate management context）中，需要注意的是，这些端点使用的web配置信息（端口、连接池、框架的组件等）也是独立于应用程序的。在这种情况下，即使应用程序已经无法正常工作（例如无法接受新连接），探针可能也会返回正常状态。</p>
</blockquote>
<h3 id="使用Kubernetes探针检测外部状态（Checking-External-State-with-Kubernetes-Probes）"><a href="#使用Kubernetes探针检测外部状态（Checking-External-State-with-Kubernetes-Probes）" class="headerlink" title="使用Kubernetes探针检测外部状态（Checking External State with Kubernetes Probes）"></a>使用Kubernetes探针检测外部状态（Checking External State with Kubernetes Probes）</h3><p>Spring Boot Actuator将“活性”（liveness）和“就绪”（readiness）探针配置为健康分组。这意味着对于这些探针来说，所有的<a href="#%E5%81%A5%E5%BA%B7%E5%88%86%E7%BB%84%EF%BC%88Health-Groups%EF%BC%89">健康分组特性</a>都适用。例如，可以配置如下健康指示器：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">health:</span></span><br><span class="line">      <span class="attr">group:</span></span><br><span class="line">        <span class="attr">readiness:</span></span><br><span class="line">          <span class="attr">include:</span> <span class="string">&quot;readinessState,customCheck&quot;</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，Spring Boot没有将其他的健康指示器添加到这些健康分组中。</p>
<p>“活性”（liveness）探针的健康检测不应该依赖于外部系统（笔者注：例如mongoDB、Redis等），如果<a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.spring-application.application-availability.liveness">应用程序的活性状态</a>处于当宕机状态，Kubernetes会尝试重新启动应用程序来解决这个问题。也就是说如果外部系统出现异常（例如数据库、Web API或外部缓存），那么Kubernetes会重启所有的应用程序，这会导致级联故障（笔者注：雪崩效应）</p>
<p>而对于“就绪”探针来说，开发人员必须谨慎处理外部系统的检测结果。比如Srping Boot就没有包含任何额外的健康检查。如果<a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.spring-application.application-availability.readiness">应用程序的就绪状态</a>处于未就绪（unready）状态，Kubernetes就不会将流量路由到该应用。那么把这些状态加入到“就绪”探针的探测中是理应该的。某些外部系统可能不是应用程序的关键依赖（比如应用程序已经部署了熔断或者降级策略），在这种情况下，这些外部系统就绝不应该被包含到“就绪”探针中。不妙的是，外部系统都是作为通用模块被应用程序所依赖的，这就需要做一个抉择：将其加入到“就绪”探针，当外部系统发生故障时，让应用程序也停止服务（out of service）；或者将这些外部系统排除在外，在外部系统发生故障时，从更高层级上处理这些故障，比如使用断路器。（Unfortunately, an external system that is shared by all application instances is common, and you have to make a judgement call: include it in the readiness probe and expect that the application is taken out of service when the external service is down, or leave it out and deal with failures higher up the stack, e.g. using a circuit breaker in the caller.）</p>
<blockquote>
<p><strong>提示</strong></p>
<p>If all instances of an application are unready, a Kubernetes Service with <code>type=ClusterIP</code> or <code>NodePort</code> will not accept any incoming connections. There is no HTTP error response (503 etc.) since there is no connection. A Service with <code>type=LoadBalancer</code> might or might not accept connections, depending on the provider. A Service that has an explicit <a href="https://kubernetes.io/docs/concepts/services-networking/ingress/">Ingress</a> will also respond in a way that depends on the implementation - the ingress service itself will have to decide how to handle the “connection refused” from downstream. HTTP 503 is quite likely in the case of both load balancer and ingress.</p>
</blockquote>
<p>此外，如果应用程序使用了Kubernetes的<a href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/">自动伸缩（autoscaling）</a>机制，对于负载均衡后面的程序，探针的表现可能会不同，这要取决于自动伸缩的配置。</p>
<h3 id="应用程序生命周期和探针状态（Application-Lifecycle-and-Probe-States）"><a href="#应用程序生命周期和探针状态（Application-Lifecycle-and-Probe-States）" class="headerlink" title="应用程序生命周期和探针状态（Application Lifecycle and Probe States）"></a>应用程序生命周期和探针状态（Application Lifecycle and Probe States）</h3><p>Kubernetes探针所支持的重要一点就是保持了和应用程序生命周期的一致性。应用程序内存中的内部状态：<code>AvailabilityState</code>和探针实际上返回的状态可能会有巨大的差异：在生命周期的某些阶段，探针可能是不可用状态。</p>
<p>当应用启动和关闭时，Sprin Boot会<a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.spring-application.application-events-and-listeners">发布事件</a>，探针可以监听这些事件，并且暴露<code>AvailabilityState</code>信息。</p>
<p>下面表格展示了在不同阶段下，<code>AvailabilityState</code>和HTTP服务器的状态，当Spring Boot应用程序启动时：</p>
<table>
<thead>
<tr>
<th align="center">启动阶段</th>
<th align="center">活性状态</th>
<th align="center">就绪状态</th>
<th align="center">HTTP服务器</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Starting</td>
<td align="center"><code>BROKEN</code></td>
<td align="center"><code>REFUSING_TRAFFIC</code></td>
<td align="center">未启动</td>
<td align="center">Kubernetes检查“活性”探针，如果耗时过长，就重启应用程序。</td>
</tr>
<tr>
<td align="center">Started</td>
<td align="center"><code>CORRECT</code></td>
<td align="center"><code>REFUSING_TRAFFIC</code></td>
<td align="center">拒绝连接</td>
<td align="center">应用程序上下文已经刷新，应用程序执行启动任务并且还不能接收流量</td>
</tr>
<tr>
<td align="center">Ready</td>
<td align="center"><code>CORRECT</code></td>
<td align="center"><code>ACCEPTING_TRAFFIC</code></td>
<td align="center">接受连接</td>
<td align="center">启动任务已经执行完毕，应用程序可以接收流量</td>
</tr>
</tbody></table>
<p>当Spring Boot应用程序关闭时：</p>
<table>
<thead>
<tr>
<th align="center">关闭阶段</th>
<th align="center">活性状态</th>
<th align="center">就绪状态</th>
<th align="center">HTTP服务器</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Running</td>
<td align="center"><code>CORRECT</code></td>
<td align="center"><code>ACCEPTING_TRAFFIC</code></td>
<td align="center">接受连接</td>
<td align="center">（此时）已经接受关闭请求</td>
</tr>
<tr>
<td align="center">Graceful shutdown</td>
<td align="center"><code>CORRECT</code></td>
<td align="center"><code>REFUSING_TRAFFIC</code></td>
<td align="center">不接受新连接</td>
<td align="center">如果启用该特性，<a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.graceful-shutdown">将会根据请求优雅地关闭进程</a></td>
</tr>
<tr>
<td align="center">Shutdown complete</td>
<td align="center">N&#x2F;A</td>
<td align="center">N&#x2F;A</td>
<td align="center">服务器关闭</td>
<td align="center">应用程序上下文被关闭并且应用也被关闭</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>提示</strong></p>
<p>查看 <a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/deployment.html#deployment.cloud.kubernetes.container-lifecycle">Kubernetes容器生命周期</a>查看关于Kubernetes部署更多的细节</p>
</blockquote>
<h2 id="应用程序信息（Application-Information）"><a href="#应用程序信息（Application-Information）" class="headerlink" title="应用程序信息（Application Information）"></a>应用程序信息（Application Information）</h2><p>应用程序信息可以暴露<code>ApplicationContext</code>内所有的<a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/info/InfoContributor.java"><code>InfoContributor</code></a> Bean收集到的信息。Spring Boot内置了很多自动装配的<code>InfoContributor</code> Bean，并且用户也可以编写自定义的Bean</p>
<h3 id="自动装配InfoContributors（Auto-configured-InfoContributors）"><a href="#自动装配InfoContributors（Auto-configured-InfoContributors）" class="headerlink" title="自动装配InfoContributors（Auto-configured InfoContributors）"></a>自动装配InfoContributors（Auto-configured InfoContributors）</h3><p>在适当的情况下，如下<code>InfoContributor</code>类型的Bean会被自动装配：</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/info/EnvironmentInfoContributor.java"><code>EnvironmentInfoContributor</code></a></td>
<td align="center">暴露<code>Environment</code>内所有<code>info</code>开头的属性（笔者注：例如配置在application.yaml内的info.name: myApp ）</td>
</tr>
<tr>
<td align="center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/info/GitInfoContributor.java"><code>GitInfoContributor</code></a></td>
<td align="center">如果<code>git.properties</code>文件存，则暴露git相关信息</td>
</tr>
<tr>
<td align="center"><a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/info/BuildInfoContributor.java"><code>BuildInfoContributor</code></a></td>
<td align="center">如果<code>META-INF/build-info.properties</code>文件存在，则暴露构建相关信息</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>提示</strong></p>
<p>可以通过配置<code>management.info.defaults.enabled</code>关闭上述任意端点</p>
</blockquote>
<h3 id="自定义应用程序信息（Custom-Application-Information）"><a href="#自定义应用程序信息（Custom-Application-Information）" class="headerlink" title="自定义应用程序信息（Custom Application Information）"></a>自定义应用程序信息（Custom Application Information）</h3><p>可以通过在Spring配置文件中设置<code>info.*</code>配置暴露自定义的数据。所有的<code>Environment</code>属性下<code>info</code>开头的键值都会被自动暴露。例如，可以在<code>application.properties</code>下增加如下配置：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">info.app.encoding</span>=<span class="string">UTF-8</span></span><br><span class="line"><span class="attr">info.app.java.source</span>=<span class="string">11</span></span><br><span class="line"><span class="attr">info.app.java.target</span>=<span class="string">11</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>提示</strong></p>
<p>除了上述硬编码，还可以<a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/howto.html#howto.properties-and-configuration.expand-properties">在构建期间生成属性值</a></p>
<p>以Maven为例，可以将上述配置重写为：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">info.app.encoding</span>=<span class="string">@project.build.sourceEncoding@</span></span><br><span class="line"><span class="attr">info.app.java.source</span>=<span class="string">@java.version@</span></span><br><span class="line"><span class="attr">info.app.java.target</span>=<span class="string">@java.version@</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Git提交信息（Git-Commit-Information）"><a href="#Git提交信息（Git-Commit-Information）" class="headerlink" title="Git提交信息（Git Commit Information）"></a>Git提交信息（Git Commit Information）</h2><p>另外一个有用的<code>info</code>端点是展示源码所在的git仓库的提交信息。当<code>GitProperties</code> Bean存在时，这些信息就可以在<code>info</code>端点下暴露出来。</p>
<blockquote>
<p><strong>提示</strong></p>
<p>如果classpath<strong>根路径</strong>下面存在一个<code>git.properties</code>文件，<code>GitProperties</code> Bean会被自动装配，可以通过“<a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/howto.html#howto.build.generate-git-info">生成git信息</a>”获得更多细节</p>
</blockquote>
<p>默认情况下，在属性存在的前提下，端点会暴露出<code>git.branch</code>、<code>git.commit.id</code>和<code>git.commit.time</code>。如果想关闭任意属性，需要在<code>git.properties</code>中排除掉。如果想展示完整的git信息（也就是说git.properties文件的所有内容），可以配置<code>management.info.git.mode</code>属性，如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">info:</span></span><br><span class="line">    <span class="attr">git:</span></span><br><span class="line">      <span class="attr">mode:</span> <span class="string">&quot;full&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果想从<code>info</code>端点关闭git提交信息，可以通过将<code>management.info.git.enabled</code>属性设置为false，如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">info:</span></span><br><span class="line">    <span class="attr">git:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="构建信息（Build-Information）"><a href="#构建信息（Build-Information）" class="headerlink" title="构建信息（Build Information）"></a>构建信息（Build Information）</h3><p>如果<code>BuildProperties</code> Bean存在，还可以暴露构建信息，并且当classpath下存在<code>META-INF/build-info.properties</code>文件时生效。</p>
<blockquote>
<p><strong>提示</strong></p>
<p>Maven和Gradle插件都可以生成<code>META-INF/build-info.properties</code>文件，可以通过“<a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/howto.html#howto.build.generate-info">Generate build information</a>”或多更多细节</p>
</blockquote>
<h3 id="自定义InfoContributors（Writing-Custom-InfoContributors）"><a href="#自定义InfoContributors（Writing-Custom-InfoContributors）" class="headerlink" title="自定义InfoContributors（Writing Custom InfoContributors）"></a>自定义<code>InfoContributors</code>（Writing Custom InfoContributors）</h3><p>可以通过注册继承了 <a href="https://github.com/spring-projects/spring-boot/tree/v2.5.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/info/InfoContributor.java"><code>InfoContributor</code></a>接口的Bean实现自定义的应用信息。如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInfoContributor</span> <span class="keyword">implements</span> <span class="title class_">InfoContributor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contribute</span><span class="params">(Info.Builder builder)</span> &#123;</span><br><span class="line">        builder.withDetail(<span class="string">&quot;example&quot;</span>, Collections.singletonMap(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果访问<code>info</code>端点，将会看到如下的额外信息：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;example&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;key&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;value&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="通过HTTP进行监控与管理（Monitoring-and-Management-over-HTTP）"><a href="#通过HTTP进行监控与管理（Monitoring-and-Management-over-HTTP）" class="headerlink" title="通过HTTP进行监控与管理（Monitoring and Management over HTTP）"></a>通过HTTP进行监控与管理（Monitoring and Management over HTTP）</h1><p>如果你正在开发一个Web应用程序，Srping Boot Actuator会自动装配所有已经开启（enabled）的端点，使通过HTTP暴露。默认规则是通过端点的<code>id</code>附加一个<code>/actuator</code>前缀作为URL路径。例如，<code>health</code>端点的路径为<code>/actuator/health</code>。</p>
<blockquote>
<p><strong>提示</strong></p>
<ul>
<li>Spring Boot Actuator被Spring MVC、Spring WebFlux和 Jersey原生支持。如果Jersey和Spring MVC都处于可用状态，那么将会使用Spring MVC。</li>
<li>为了获得如API文档 （<a href="https://docs.spring.io/spring-boot/docs/2.5.0/actuator-api/htmlsingle">HTML</a>或<a href="https://docs.spring.io/spring-boot/docs/2.5.0/actuator-api/pdf/spring-boot-actuator-web-api.pdf">PDF</a>）中所述的正确JSON响应，需要将Jackon加入到依赖中</li>
</ul>
</blockquote>
<h2 id="自定义端点路径（Customizing-the-Management-Endpoint-Paths）"><a href="#自定义端点路径（Customizing-the-Management-Endpoint-Paths）" class="headerlink" title="自定义端点路径（Customizing the Management Endpoint Paths）"></a>自定义端点路径（Customizing the Management Endpoint Paths）</h2><p>某些情况下，自定义端点路径的前缀是很有必要的。比如，应用程序可能已经使用了<code>/actuator</code>路径作为其他用途。可以设置<code>management.endpoints.web.base-path</code>属性来调整端点的前缀，如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">base-path:</span> <span class="string">&quot;/manage&quot;</span></span><br></pre></td></tr></table></figure>

<p>这会将端点的URL从<code>/actuator/&#123;id&#125;</code> 改为<code>/manage/&#123;id&#125;</code>（例如：<code>/manage/info</code>）</p>
<blockquote>
<p><strong>提示</strong></p>
<p>除非管理端口被配置为其他的的HTTP端口，否则<code>management.endpoints.web.base-path</code>的配置是相对于<code>server.servlet.context-path</code>（Servlet web应用）或<code>spring.webflux.base-path</code>（响应式web应用）的。如果<code>management.server.port</code>被配置了，那么<code>management.endpoints.web.base-path</code>是相对于<code>management.server.base-path</code>的路径。</p>
</blockquote>
<p>如果想将端点映射到其他路径，可以修改<code>management.endpoints.web.path-mapping</code>属性，以下示例将<code>/actuator/health</code>映射为<code>/healthcheck</code></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">base-path:</span> <span class="string">&quot;/&quot;</span></span><br><span class="line">      <span class="attr">path-mapping:</span></span><br><span class="line">        <span class="attr">health:</span> <span class="string">&quot;healthcheck&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="自定义端口（Customizing-the-Management-Server-Port）"><a href="#自定义端口（Customizing-the-Management-Server-Port）" class="headerlink" title="自定义端口（Customizing the Management Server Port）"></a>自定义端口（Customizing the Management Server Port）</h2><p>如果应用程序是基于云部署，那么使用默认的HTTP端口来暴露端点是一个明智的选择。不过，如果应用程序运行在自己内部的数据中心，可能会倾向于使用其他的HTTP端口。</p>
<p>可以通过设置<code>management.server.port</code>属性调整HTTP端口，如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8081</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>提示</strong></p>
<p>在Cloud Foundry上，默认情况下，应用程序只在端口8080上接收HTTP和TCP路由请求。如果想在Cloud Foundry上使用自定义的端口，你需要明确地设置应用程序的路由，将流量转发到自定义端口。</p>
</blockquote>
<h2 id="配置SSL（Configuring-Management-specific-SSL）"><a href="#配置SSL（Configuring-Management-specific-SSL）" class="headerlink" title="配置SSL（Configuring Management-specific SSL）"></a>配置SSL（Configuring Management-specific SSL）</h2><p>当使用了自定义端口之后，也可以通过<code>management.server.ssl.*</code>属性配置独立的SSL。例如，可以让端点管理通过HTTP访问，而应用程序通过HTTPS访问，如下配置所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8443</span></span><br><span class="line">  <span class="attr">ssl:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">key-store:</span> <span class="string">&quot;classpath:store.jks&quot;</span></span><br><span class="line">    <span class="attr">key-password:</span> <span class="string">secret</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">    <span class="attr">ssl:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>又或者，端点管理和应用程序都通过SSL访问，但是使用不同的证书和秘钥（keystore），如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8443</span></span><br><span class="line">  <span class="attr">ssl:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">key-store:</span> <span class="string">&quot;classpath:main.jks&quot;</span></span><br><span class="line">    <span class="attr">key-password:</span> <span class="string">&quot;secret&quot;</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">    <span class="attr">ssl:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">key-store:</span> <span class="string">&quot;classpath:management.jks&quot;</span></span><br><span class="line">      <span class="attr">key-password:</span> <span class="string">&quot;secret&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="自定义服务器地址"><a href="#自定义服务器地址" class="headerlink" title="自定义服务器地址"></a>自定义服务器地址</h2><p>通过设置<code>management.server.address</code>属性，可以自定义端点的访问地址。如果只想监听内部网络或运维内部网络（ops-facing network ），有或者只想监听来来自localhost的连接，这个设置就会很有用。</p>
<blockquote>
<p><strong>提示</strong></p>
<p>只有当端点端口与应用程序端口不同时，才可以配置监听不同的地址。</p>
</blockquote>
<p>如下配置不允许远程连接访问：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line">    <span class="attr">address:</span> <span class="string">&quot;127.0.0.1&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="禁用HTTP端点（Disabling-HTTP-Endpoints）"><a href="#禁用HTTP端点（Disabling-HTTP-Endpoints）" class="headerlink" title="禁用HTTP端点（Disabling HTTP Endpoints）"></a>禁用HTTP端点（Disabling HTTP Endpoints）</h2><p>如果不想通过HTTP暴露端点，可以将端口设置为-1，例如：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>也可以通过设置<code>management.endpoints.web.exposure.exclude</code>属性达到达到这个效果。如下配置所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">exclude:</span> <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="通过JMX进行监控和管理（Monitoring-and-Management-over-JMX）"><a href="#通过JMX进行监控和管理（Monitoring-and-Management-over-JMX）" class="headerlink" title="通过JMX进行监控和管理（Monitoring and Management over JMX）"></a>通过JMX进行监控和管理（Monitoring and Management over JMX）</h1><p>JAVA管理扩展（JMX）提供了管理和监控应用程序的标准机制。这个特性默认没有被启用，可以通过设置<code>spring.jmx.enabled</code>为<code>true</code>来开启。默认情况下，Spring Boot的JMX MBeans位于<code>org.springframework.boot</code>作用域下。要想完全控制JMX域下的端点，可以考虑实现<code>EndpointObjectNameFactory</code>接口。</p>
<h3 id="自定义MBean名字（Customizing-MBean-Names）"><a href="#自定义MBean名字（Customizing-MBean-Names）" class="headerlink" title="自定义MBean名字（Customizing MBean Names）"></a>自定义MBean名字（Customizing MBean Names）</h3><p>通常情况下，MBean的名字由端点的<code>id</code>生成。例如，<code>health</code>端点就被暴露为：<code>org.springframework.boot:type=Endpoint,name=Health</code>。</p>
<p>如果应用程序拥有的<code>ApplicationContext</code>不止一个的话，可能会发现名称冲突。若要解决该问题，可以设置属性<code>spring.jmx.unique-names</code>为<code>true</code>，这样的话，MBean的名字就是唯一的了。</p>
<p>可以自定义暴露端点的JMX作用域，如下例所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">jmx:</span></span><br><span class="line">    <span class="attr">unique-names:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">jmx:</span></span><br><span class="line">      <span class="attr">domain:</span> <span class="string">&quot;com.example.myapp&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="禁用JMX端点（Disabling-JMX-Endpoints）"><a href="#禁用JMX端点（Disabling-JMX-Endpoints）" class="headerlink" title="禁用JMX端点（Disabling JMX Endpoints）"></a>禁用JMX端点（Disabling JMX Endpoints）</h3><p>如果不想通过JMX暴露端点，可以设置<code>management.endpoints.jmx.exposure.exclude</code>属性为<code>*</code>，如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">jmx:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">exclude:</span> <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="通过HTTP访问基于Jolokia的JMX端点（Using-Jolokia-for-JMX-over-HTTP）"><a href="#通过HTTP访问基于Jolokia的JMX端点（Using-Jolokia-for-JMX-over-HTTP）" class="headerlink" title="通过HTTP访问基于Jolokia的JMX端点（Using Jolokia for JMX over HTTP）"></a>通过HTTP访问基于Jolokia的JMX端点（Using Jolokia for JMX over HTTP）</h3><p>Jolokia作为一个JMX-HTTP桥接器提供了访问JMX bean的替代方案。如果想要使用Jolokia，需要添加依赖：<code>org.jolokia:jolokia-core</code>。以Maven为例，配置如下所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jolokia<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jolokia-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以通过添加<code>jolokia</code>或<code>*</code>到<code>management.endpoints.web.exposure.include</code>属性中开启Jolokia端点。然后可以使用<code>/actuator/jolokia</code>该端点。</p>
<blockquote>
<p><strong>提示</strong></p>
<p>Jolokia端点将Jolokia的servlet暴露为actuator端点。这意味着它是特定于Spring MVC和Jersey等servlet环境的。并且该端点在WebFlux应用程序中不可用。</p>
</blockquote>
<h4 id="自定义Jolokia（Customizing-Jolokia）"><a href="#自定义Jolokia（Customizing-Jolokia）" class="headerlink" title="自定义Jolokia（Customizing Jolokia）"></a>自定义Jolokia（Customizing Jolokia）</h4><p>Jolokia包含许多设置，通常可以是通过设置servlet参数进行配置。而在Spring Boot下中，可以使用<code>application.properties</code>。所有的Jolokia参数都以<code>management.endpoint.jolokia.config</code>作为前缀，举例如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">jolokia:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h4 id="禁用Jolokia（Disabling-Jolokia）"><a href="#禁用Jolokia（Disabling-Jolokia）" class="headerlink" title="禁用Jolokia（Disabling Jolokia）"></a>禁用Jolokia（Disabling Jolokia）</h4><p>当使用了Jolokia而又不想让Spring Boot对其进行配置，可以将<code>management.endpoint.jolokia.enabled</code>设置为<code>false</code>，如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">jolokia:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h1 id="日志（Loggers）"><a href="#日志（Loggers）" class="headerlink" title="日志（Loggers）"></a>日志（Loggers）</h1><p>Spring Boot Actuator具备查看和设置正在运行中的应用程序的日志等级的能力。可以查看完整日志列表或者单独某个日志的配置，这些配置由两部分组成：显式配置的日志等级和日志框架给定的有效日志等级。这些日志等级可以是如下任意一个：</p>
<ul>
<li><code>TRACE</code></li>
<li><code>DEBUG</code></li>
<li><code>INFO</code></li>
<li><code>WARN</code></li>
<li><code>ERROR</code></li>
<li><code>FATAL</code></li>
<li><code>OFF</code></li>
<li><code>null</code></li>
</ul>
<p><code>null</code>代表没有显示地配置日志</p>
<h2 id="配置日志（Configure-a-Logger）"><a href="#配置日志（Configure-a-Logger）" class="headerlink" title="配置日志（Configure a Logger）"></a>配置日志（Configure a Logger）</h2><p>如果要配置一个日志，可以向资源URL <code>POST</code>一个特定的请求体，如下所示：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;configuredLevel&quot;</span><span class="punctuation">:</span> <span class="string">&quot;DEBUG&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>提示</strong></p>
<p>如果想重置之前设置的日志等级（并且使用默认配置），可以将<code>configuredLevel</code>设置为<code>null</code></p>
</blockquote>
<h1 id="指标（Metrics）"><a href="#指标（Metrics）" class="headerlink" title="指标（Metrics）"></a>指标（Metrics）</h1><p>Spring Boot Actuator提供了对 <a href="https://micrometer.io/">Micrometer</a>的依赖管理和自动装配。Spring内部提供了指标门面（an application metrics facade）模式，该模式提供了对于<a href="https://micrometer.io/docs">众多监控系统</a>的支持，包括：</p>
<ul>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.appoptics">AppOptics</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.atlas">Atlas</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.datadog">Datadog</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.dynatrace">Dynatrace</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.elastic">Elastic</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.ganglia">Ganglia</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.graphite">Graphite</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.humio">Humio</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.influx">Influx</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.jmx">JMX</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.kairos">KairosDB</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.newrelic">New Relic</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.prometheus">Prometheus</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.signalfx">SignalFx</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.simple">Simple (in-memory)</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.stackdriver">Stackdriver</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.statsd">StatsD</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/actuator.html#actuator.metrics.export.wavefront">Wavefront</a></li>
</ul>
<blockquote>
<p><strong>提示</strong></p>
<p>要了解更多关于Micrometer的功能，请参考它的<a href="https://micrometer.io/docs">参考文档</a>，特别是<a href="https://micrometer.io/docs/concepts">概念部分</a>。</p>
</blockquote>
<h2 id="入门（Getting-started）"><a href="#入门（Getting-started）" class="headerlink" title="入门（Getting started）"></a>入门（Getting started）</h2><p>Spring Boot自动装配了一个组合类型（composite）的指标注册表（<code>MeterRegistry</code>），对于在classpath下发现的任何指标注册表（<code>MeterRegistery</code>）的实现，Spring Boot会将其加入到这个组合类型的指标注册表中。实际上，在运行期（runtime）的classpath下增加<code>micrometer-registry-&#123;system&#125;</code>（笔者注：此处的system可以替换成上述列表中的监控系统）依赖后，Spring Boot就会自动配置对应类型的注册表（registery）。</p>
<p>大多数注册表都有相同的特性。例如，即使（Micrometer的）注册表的实现类在classpath内，也可以将其禁用。例如，要禁用Datadog：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">datadog:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>也可以禁用所有注册表，除非某注册表已经通过自己的配置单独启用，如下例所示:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">defaults:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>Spring Boot将自动装配的注册器添加到<code>Metrics</code>类（笔者注：全类限定名为：<code>io.micrometer.core.instrument.Metrics</code>）的全局静态组合注册表中，触发显示禁用：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">use-global-registry:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>可以注册任意数量的类型为<code>MeterRegistryCustomizer</code>的bean，这些bean可以实现对注册表的自定义化配置，例如当任意指标注册到指标注册表中时，每个为这些指标增加通用的Tag标记：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMeterRegistryConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MeterRegistryCustomizer&lt;MeterRegistry&gt; <span class="title function_">metricsCommonTags</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (registry) -&gt; registry.config().commonTags(<span class="string">&quot;region&quot;</span>, <span class="string">&quot;us-east-1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以通过更具体的泛型类型的支实现对特定注册表的自定义化配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMeterRegistryConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MeterRegistryCustomizer&lt;GraphiteMeterRegistry&gt; <span class="title function_">graphiteMetricsNamingConvention</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (registry) -&gt; registry.config().namingConvention(<span class="built_in">this</span>::name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">name</span><span class="params">(String name, Meter.Type type, String baseUnit)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring Boot还<a href="##%E6%94%AF%E6%8C%81%E7%9A%84%E6%8C%87%E6%A0%87%EF%BC%88Supported-Metrics-and-Meters%EF%BC%89">内置的很多指标和仪表</a>，可以通过配置文件或专用注解来控制这些指标。</p>
<h2 id="支持的监控系统（Supported-Monitoring-Systems）"><a href="#支持的监控系统（Supported-Monitoring-Systems）" class="headerlink" title="支持的监控系统（Supported Monitoring Systems）"></a>支持的监控系统（Supported Monitoring Systems）</h2><h3 id="AppOptics"><a href="#AppOptics" class="headerlink" title="AppOptics"></a>AppOptics</h3><p>默认情况下，AppOptics注册表负责将指标周期性地推送到 <a href="https://api.appoptics.com/v1/measurements"><code>api.appoptics.com/v1/measurements</code></a>。为了把指标推送到Saas <a href="https://micrometer.io/docs/registry/appOptics">AppOptics</a>平台，需要在配置里提供API令牌（API token）：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">appoptics:</span></span><br><span class="line">        <span class="attr">api-token:</span> <span class="string">&quot;YOUR_TOKEN&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Atlas"><a href="#Atlas" class="headerlink" title="Atlas"></a>Atlas</h3><p>默认情况下， <a href="https://micrometer.io/docs/registry/atlas">Atlas</a> 指标暴露给本机正在运行的Atlas服务器。 <a href="https://github.com/Netflix/atlas">Atlas服务器</a> 的地址可以使用如下配置进行修改：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">atlas:</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">&quot;https://atlas.example.com:7101/api/v1/publish&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="Datadog"><a href="#Datadog" class="headerlink" title="Datadog"></a>Datadog</h3><p>Datadog注册表负责周期性地将指标推送给<a href="https://www.datadoghq.com/">datadoghq</a>。为了把指标推送到 <a href="https://micrometer.io/docs/registry/datadog">Datadog</a>，需要在配置里提供API秘钥（API key）：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">datadog:</span></span><br><span class="line">        <span class="attr">api-key:</span> <span class="string">&quot;YOUR_KEY&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="Dynatrace"><a href="#Dynatrace" class="headerlink" title="Dynatrace"></a>Dynatrace</h3><p>Dynatrace注册表负责将指标周期性地推送给配置的URL。为了把指标推送到<a href="https://micrometer.io/docs/registry/dynatrace">Dynatrace</a>，需要提供API令牌（API token）、设备ID（device ID）以及URL：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">dynatrace:</span></span><br><span class="line">        <span class="attr">api-token:</span> <span class="string">&quot;YOUR_TOKEN&quot;</span></span><br><span class="line">        <span class="attr">device-id:</span> <span class="string">&quot;YOUR_DEVICE_ID&quot;</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">&quot;YOUR_URI&quot;</span></span><br></pre></td></tr></table></figure>

<p>也可以修改推送指标到Dynatrace的间隔时间：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">dynatrace:</span></span><br><span class="line">        <span class="attr">step:</span> <span class="string">&quot;30s&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="Elastic"><a href="#Elastic" class="headerlink" title="Elastic"></a>Elastic</h3><p>默认情况下，指标会被推送到本机运行的<a href="https://micrometer.io/docs/registry/elastic">Elastic</a>服务器上，而Elastic服务器的地址可以通过如下配置进行修改：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">elastic:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">&quot;https://elastic.example.com:8086&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="Ganglia"><a href="#Ganglia" class="headerlink" title="Ganglia"></a>Ganglia</h3><p>默认情况下，指标会被推送到本机运行的<a href="https://micrometer.io/docs/registry/ganglia">Ganglia</a>服务器上，<a href="http://ganglia.sourceforge.net/">Ganglia服务器</a>的地址和端口可以通过如下配置进行修改：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">ganglia:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">&quot;ganglia.example.com&quot;</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">9649</span></span><br></pre></td></tr></table></figure>

<h3 id="Graphite"><a href="#Graphite" class="headerlink" title="Graphite"></a>Graphite</h3><p>默认情况下，指标会被推送到本机运行的 <a href="https://micrometer.io/docs/registry/graphite">Graphite</a>服务器上， <a href="https://graphiteapp.org/">Graphite服务器</a>的地址和端口可以通过如下配置进行修改：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">     <span class="attr">export:</span></span><br><span class="line">       <span class="attr">graphite:</span></span><br><span class="line">         <span class="attr">host:</span> <span class="string">&quot;graphite.example.com&quot;</span></span><br><span class="line">         <span class="attr">port:</span> <span class="number">9004</span></span><br></pre></td></tr></table></figure>

<p>Micrometer提供了一个默认的<code>HierarchicalNameMapper</code>，用于管理如何在多维度的指标名称<a href="https://micrometer.io/docs/registry/graphite#_hierarchical_name_mapping">扁平化指标名称之间进行映射转换</a>。</p>
<blockquote>
<p><strong>提示</strong></p>
<p>如果想实现自定义的名称映射管理，需要自己实现<code>GraphiteMeterRegistry</code>并且提供自定义的<code>HierarchicalNameMapper</code>，<code>GraphiteConfig</code>和<code>Clock</code>不需要自定义，它们会被Spring自动装配，除非用户已经自己定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyGraphiteConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> GraphiteMeterRegistry <span class="title function_">graphiteMeterRegistry</span><span class="params">(GraphiteConfig config, Clock clock)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GraphiteMeterRegistry</span>(config, clock, <span class="built_in">this</span>::toHierarchicalName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">toHierarchicalName</span><span class="params">(Meter.Id id, NamingConvention convention)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Humio"><a href="#Humio" class="headerlink" title="Humio"></a>Humio</h3><p>默认情况下，指标被周期性地推送到 <a href="https://cloud.humio.com/">cloud.humio.com</a>，为了把指标推送到Saas <a href="https://micrometer.io/docs/registry/humio">Humio</a>平台，需要提供API令牌（API token）：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">humio:</span></span><br><span class="line">        <span class="attr">api-token:</span> <span class="string">&quot;YOUR_TOKEN&quot;</span></span><br></pre></td></tr></table></figure>

<p>也可以为每个要推送的指标配置一个或多个Tag标记，用来区分数据源：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">humio:</span></span><br><span class="line">        <span class="attr">tags:</span></span><br><span class="line">          <span class="attr">alpha:</span> <span class="string">&quot;a&quot;</span></span><br><span class="line">          <span class="attr">bravo:</span> <span class="string">&quot;b&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="Influx"><a href="#Influx" class="headerlink" title="Influx"></a>Influx</h3><p>默认情况下，指标被推送（exported）给运行于本机的v1版本的 <a href="https://micrometer.io/docs/registry/influx">Influx</a>，如果想把指标推送给InfluxDB v2，需要配置<code>org</code>、<code>bucket</code>和认证用的<code>token</code>。 <a href="https://www.influxdata.com/">Influx服务器</a>的地址可以通过如下配置进行修改：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">influx:</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">&quot;https://influx.example.com:8086&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="JMX"><a href="#JMX" class="headerlink" title="JMX"></a>JMX</h3><p>Micrometer提供了向<a href="https://micrometer.io/docs/registry/jmx">JMX</a>的层级映射，主要用来当做一种低成本且便携的本地查看指标的方式。默认情况下，指标被推送给JMX的<code>metrics</code>作用域（domain），而作用域也可以通过如下配置进行修改：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">management:</span><br><span class="line">  metrics:</span><br><span class="line">    export:</span><br><span class="line">      jmx:</span><br><span class="line">        domain: <span class="string">&quot;com.example.app.metrics&quot;</span></span><br></pre></td></tr></table></figure>

<p>Micrometer提供了一个默认的<code>HierarchicalNameMapper</code>，用于管理如何在多维度的指标名称<a href="https://micrometer.io/docs/registry/jmx#_hierarchical_name_mapping">扁平化指标名称之间进行映射转换</a>。</p>
<blockquote>
<p><strong>提示</strong></p>
<p>如果想实现自定义的名称映射管理，需要自己实现<code>JmxMeterRegistry</code>并且提供自定义的<code>HierarchicalNameMapper</code>，<code>JmxConfig </code>和<code>Clock</code>不需要自定义，它们都被Spring自动装配，除非用户已经自己定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyJmxConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> JmxMeterRegistry <span class="title function_">jmxMeterRegistry</span><span class="params">(JmxConfig config, Clock clock)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JmxMeterRegistry</span>(config, clock, <span class="built_in">this</span>::toHierarchicalName);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String <span class="title function_">toHierarchicalName</span><span class="params">(Meter.Id id, NamingConvention convention)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> ...</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="KairosDB"><a href="#KairosDB" class="headerlink" title="KairosDB"></a>KairosDB</h3><p>默认情况下，指标会被推送到本机运行的 <a href="https://micrometer.io/docs/registry/kairos">KairosDB</a> 服务器上， <a href="https://kairosdb.github.io/">KairosDB 服务器</a>的地址可以通过如下配置进行修改：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">kairos:</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">&quot;https://kairosdb.example.com:8080/api/v1/datapoints&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="New-Relic"><a href="#New-Relic" class="headerlink" title="New Relic"></a>New Relic</h3><p>New Relic注册表负责周期性地将指标推送给<a href="https://micrometer.io/docs/registry/new-relic">New Relic</a>。为了把指标推送到 <a href="https://newrelic.com/">New Relic</a>，需要在配置里提供API秘钥（API key）和账号id（account id）：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">newrelic:</span></span><br><span class="line">        <span class="attr">api-key:</span> <span class="string">&quot;YOUR_KEY&quot;</span></span><br><span class="line">        <span class="attr">account-id:</span> <span class="string">&quot;YOUR_ACCOUNT_ID&quot;</span></span><br></pre></td></tr></table></figure>

<p>也可以修改推送指标到New Relic的间隔时间：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">newrelic:</span></span><br><span class="line">        <span class="attr">step:</span> <span class="string">&quot;30s&quot;</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，指标以REST的形式推送。也可以使用Java Agent API，如果响应的类库在classpath路径内的情况下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">newrelic:</span></span><br><span class="line">        <span class="attr">client-provider-type:</span> <span class="string">&quot;insights-agent&quot;</span></span><br></pre></td></tr></table></figure>

<p>最后，也可以通过自定义实现<code>NewRelicClientProvider</code> bean获得完全的控制权。</p>
<h3 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h3><p><a href="https://micrometer.io/docs/registry/prometheus">Prometheus</a>获取指标的方式是向应用程序拉取或轮询的指标数据。Spring Boot提供了一个可用的端点<code>/actuator/prometheus</code>，并以适当的方式提供给<a href="https://prometheus.io/">Prometheus指标采集器</a>（Prometheus scrape）</p>
<blockquote>
<p><strong>提示</strong></p>
<p>端点默认是禁用的，并且还需要开放暴露，可用查看<a href="##%E6%9A%B4%E9%9C%B2%E7%AB%AF%E7%82%B9%EF%BC%88Exposing-Endpoints%EF%BC%89">暴露端点（Exposing Endpoints）</a>获取更详细信息</p>
</blockquote>
<p>以下是<code>prometheus.yml</code>配置文件中的<code>scrape_config</code>配置示例：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;spring&#x27;</span></span><br><span class="line">    <span class="attr">metrics_path:</span> <span class="string">&#x27;/actuator/prometheus&#x27;</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&#x27;HOST:PORT&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>对于某些无法被拉取的短暂任务或批量任务， Prometheus的<a href="https://github.com/prometheus/pushgateway">Pushgateway</a>组件提供了将指标推送给Prometheus的方式。如果要启用Pushgateway的支持，需要增加如下依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.prometheus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>simpleclient_pushgateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当Pushgateway 组件存在于classpath下，并且<code>management.metrics.export.prometheus.pushgateway.enabled</code>被设置为<code>true</code>时，Spring Boot会自动装配一个<code>PrometheusPushGatewayManager</code> bean。这个bean就复杂将指标推送到<code>Pushgateway</code>。</p>
<p>可以通过<code>management.metrics.export.prometheus.pushgateway.</code>属性对<code>PrometheusPushGatewayManager</code>进一步配置，当然，用户也可以自定义<code>PrometheusPushGatewayManager</code> bean。</p>
<h3 id="SignalFx"><a href="#SignalFx" class="headerlink" title="SignalFx"></a>SignalFx</h3><p>SignalFx注册表负责周期性地将指标推送给 <a href="https://micrometer.io/docs/registry/signalFx">SignalFx</a>。为了把指标推送到 <a href="https://www.signalfx.com/">SignalFx</a>，需要在配置里提供访问令牌（access token）：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">signalfx:</span></span><br><span class="line">        <span class="attr">access-token:</span> <span class="string">&quot;YOUR_ACCESS_TOKEN&quot;</span></span><br></pre></td></tr></table></figure>

<p>也可以修改推送指标到SignalFx的间隔时间：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">signalfx:</span></span><br><span class="line">        <span class="attr">step:</span> <span class="string">&quot;30s&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="Simple"><a href="#Simple" class="headerlink" title="Simple"></a>Simple</h3><p>Micrometer内置了一个简易的、在内存中的（in-memory）注册表。如果其他的注册表都没有被配置，它会将当做默认的指标监控系统。通过该系统，可以在<a href="##%E6%8C%87%E6%A0%87%E7%AB%AF%E7%82%B9%EF%BC%88Metrics-Endpoint%EF%BC%89">指标端点</a>中查看系统收集了哪些指标。</p>
<p>只要启用了其他任意监控系统，simple系统就会被自动禁用。当然也可以显式将其关闭：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="Stackdriver"><a href="#Stackdriver" class="headerlink" title="Stackdriver"></a>Stackdriver</h3><p>Stackdriver注册表负责周期性地将指标推送给<a href="https://cloud.google.com/stackdriver/">Stackdriver</a>。为了把指标推送到SaaS <a href="https://micrometer.io/docs/registry/stackdriver">Stackdriver</a>平台，需要在配置里提供谷歌云的project id：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">stackdriver:</span></span><br><span class="line">        <span class="attr">project-id:</span> <span class="string">&quot;my-project&quot;</span></span><br></pre></td></tr></table></figure>

<p>也可以修改推送指标到Stackdriver的间隔时间：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">stackdriver:</span></span><br><span class="line">        <span class="attr">step:</span> <span class="string">&quot;30s&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="StatsD"><a href="#StatsD" class="headerlink" title="StatsD"></a>StatsD</h3><p>StatsD注册表通过UDP将指标推送到StatsD代理。默认情况下，指标将被推送到本机运行的StatsD代理。StatsD代理的主机（host）、端口（port）和协议（协议）可以通过以下方式修改：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">statsd:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">&quot;statsd.example.com&quot;</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">9125</span></span><br><span class="line">        <span class="attr">protocol:</span> <span class="string">&quot;udp&quot;</span></span><br></pre></td></tr></table></figure>

<p>也可以修改StatsD所使用的line协议（line protocol）（默认为Datadog）：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">statsd:</span></span><br><span class="line">        <span class="attr">flavor:</span> <span class="string">&quot;etsy&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="Wavefront"><a href="#Wavefront" class="headerlink" title="Wavefront"></a>Wavefront</h3><p>Wavefront注册表负责周期性地将指标推送给<a href="https://micrometer.io/docs/registry/wavefront">Wavefront</a>。为了把指标推送到<a href="https://www.wavefront.com/">Wavefront</a>，需要在配置里提供API令牌（API token）：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">wavefront:</span></span><br><span class="line">        <span class="attr">api-token:</span> <span class="string">&quot;YOUR_API_TOKEN&quot;</span></span><br></pre></td></tr></table></figure>

<p>你可能会使用一个Wavefront边车代理（Wavefront sidecar）或设置一个内部代理，用于将指标数据转发到Wavefront API主机：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">wavefront:</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">&quot;proxy://localhost:2878&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>指标</strong></p>
<p>如果是将指标发布到Wavefront代理（如<a href="https://docs.wavefront.com/proxies_installing.html">文档所述</a>），主机的配置格式必须为：<code>proxy://HOST:PORT</code></p>
</blockquote>
<p>也可以修改推送指标到Wavefront的间隔时间：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">export:</span></span><br><span class="line">      <span class="attr">wavefront:</span></span><br><span class="line">        <span class="attr">step:</span> <span class="string">&quot;30s&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="支持的指标和仪表（Supported-Metrics-and-Meters）"><a href="#支持的指标和仪表（Supported-Metrics-and-Meters）" class="headerlink" title="支持的指标和仪表（Supported Metrics and Meters）"></a>支持的指标和仪表（Supported Metrics and Meters）</h2><p>对于（系统使用的）各种的技术组件，Spring Boot都提供了指标自动注册。大多数情况下，这些开箱即用的指标注册表会选择适当的指标，并将其发布到任意所支持的监控系统上。</p>
<h3 id="JVM指标（JVM-Metrics）"><a href="#JVM指标（JVM-Metrics）" class="headerlink" title="JVM指标（JVM Metrics）"></a>JVM指标（JVM Metrics）</h3><p>自动装配机制会使用Micrometer的核心代码开启JVM指标。JVM指标被发布在<code>jvm.</code>名称下。如下JVM指标都是支持的：</p>
<ul>
<li>各种内存和缓冲池详细信息</li>
<li>垃圾收集相关统计</li>
<li>线程利用率</li>
<li>被加载&#x2F;卸载的class数量</li>
</ul>
<h3 id="系统指标（System-Metrics）"><a href="#系统指标（System-Metrics）" class="headerlink" title="系统指标（System Metrics）"></a>系统指标（System Metrics）</h3><p>自动装配机制会使用Micrometer的核心代码开启系统指标。系统指标被发布在<code>system.</code>和<code>process.</code>名称下。如下系统指标都是支持的：</p>
<ul>
<li>CPU指标</li>
<li>文件指标（File descriptor metrics）</li>
<li>运行时间指标（包括系统的运行时间以及启动时的绝对时间）</li>
</ul>
<h3 id="日志指标（Logger-Metrics）"><a href="#日志指标（Logger-Metrics）" class="headerlink" title="日志指标（Logger Metrics）"></a>日志指标（Logger Metrics）</h3><p>自动装配机制支持Logback和Log4J2的日志事件。这些指标被发布在<code>log4j2.events.</code>或<code>logback.events.</code>下面。</p>
<h3 id="Spring-MVC指标（-Spring-MVC-Metrics）"><a href="#Spring-MVC指标（-Spring-MVC-Metrics）" class="headerlink" title="Spring MVC指标（ Spring MVC Metrics）"></a>Spring MVC指标（ Spring MVC Metrics）</h3><p>自动装配机制会开启对 Spring MVC控制器（Spring MVC controllers）和请求处理器（functional handlers）的所有请求的采集。默认情况下，指标的名称前缀为<code> http.server.requests</code>。可以通过设置 <code>management.metrics.web.server.request.metric-name </code>来自定义该前缀。</p>
<p><code>@Controller</code>类和<code>@RequestMapping</code>方法支持<code>@Timed</code>注解（详情参考：[@Timed注解支持（@Timed Annotation Support）](##@Timed注解支持（@Timed Annotation Support）)）。如果不想开启所有的Spring MVC请求，可以将<code>management.metrics.web.server.request.autotime.enabled</code>设置为<code>false</code>，而仅使用<code>@Timed</code>注解。</p>
<p>默认情况下，Spring MVC相关的指标会被增加如下tag标记：</p>
<table>
<thead>
<tr>
<th align="center">Tag</th>
<th align="center">详情</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>exception</code></td>
<td align="center">当处理请求出现异常时，被抛出的异常类的简短类名</td>
</tr>
<tr>
<td align="center"><code>method</code></td>
<td align="center">请求方法（例如：<code>GET</code>或<code>POST</code>）</td>
</tr>
<tr>
<td align="center"><code>outcome</code></td>
<td align="center">基于响应状态码的返回值描述，1xx：<code>INFORMATIONAL</code>；2xx：<code>SUCCESS</code>；3xx：<code>REDIRECTION</code>；4xx：<code>CLIENT_ERROR</code>；5xx：<code>SERVER_ERROR</code></td>
</tr>
<tr>
<td align="center"><code>status</code></td>
<td align="center">响应状态码（例如<code>200</code>或<code>500</code>）</td>
</tr>
<tr>
<td align="center"><code>url</code></td>
<td align="center">在变量替换之前使用请求的URI模板(例如，<code>/api/person/&#123;id&#125;</code>)</td>
</tr>
</tbody></table>
<p>如果想添加默认的tag标记，可以提供一个或多个实现了<code>WebMvcTagsContributor</code>的<code>@Bean</code>，如果想替换（上述）tag标记，提供一个实现了<code>WebMvcTagsProvider</code>的<code>@Bean</code></p>
<blockquote>
<p><strong>提示</strong></p>
<p>在某些情况下，控制器和请求处理器内处理的异常并不会以指标tag标记的方式（如上表）被记录。此时，应用程序可以通过<a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.developing-web-applications.spring-mvc.error-handling">将异常设置为请求的属性</a>来确保该异常处理不会被遗漏。</p>
</blockquote>
<h3 id="Spring-WebFlux指标（Spring-WebFlux-Metrics）"><a href="#Spring-WebFlux指标（Spring-WebFlux-Metrics）" class="headerlink" title="Spring WebFlux指标（Spring WebFlux Metrics）"></a>Spring WebFlux指标（Spring WebFlux Metrics）</h3><p>自动装配机制会开启对 Spring WebFlux控制器（Spring WebFlux controllers）和请求处理器（functional handlers）的所有请求的采集。默认情况下，指标的名称前缀为<code> http.server.requests</code>。可以通过设置 <code>management.metrics.web.server.request.metric-name </code>来自定义该前缀。</p>
<p><code>@Controller</code>类和<code>@RequestMapping</code>方法支持<code>@Timed</code>注解（详情参考：[@Timed注解支持（@Timed Annotation Support）](##@Timed注解支持（@Timed Annotation Support）)）。如果不想开启所有的Spring WebFlux请求，可以将<code>management.metrics.web.server.request.autotime.enabled</code>设置为<code>false</code>，而仅使用<code>@Timed</code>注解。</p>
<p>默认情况下，Spring WebFlux相关的指标会被增加如下tag标记：</p>
<table>
<thead>
<tr>
<th align="center">Tag</th>
<th align="center">详情</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>exception</code></td>
<td align="center">当处理请求出现异常时，被抛出的异常类的简短类名</td>
</tr>
<tr>
<td align="center"><code>method</code></td>
<td align="center">请求方法（例如：<code>GET</code>或<code>POST</code>）</td>
</tr>
<tr>
<td align="center"><code>outcome</code></td>
<td align="center">基于响应状态码的返回值描述，1xx：<code>INFORMATIONAL</code>；2xx：<code>SUCCESS</code>；3xx：<code>REDIRECTION</code>；4xx：<code>CLIENT_ERROR</code>；5xx：<code>SERVER_ERROR</code></td>
</tr>
<tr>
<td align="center"><code>status</code></td>
<td align="center">响应状态码（例如<code>200</code>或<code>500</code>）</td>
</tr>
<tr>
<td align="center"><code>url</code></td>
<td align="center">在变量替换之前使用请求的URI模板(例如，<code>/api/person/&#123;id&#125;</code>)</td>
</tr>
</tbody></table>
<p>如果想添加默认的tag标记，可以提供一个或多个实现了<code>WebFluxTagsContributor</code>的<code>@Bean</code>，如果想替换（上述）tag标记，提供一个实现了<code>WebFluxTagsProvider</code>的<code>@Bean</code></p>
<blockquote>
<p><strong>提示</strong></p>
<p>在某些情况下，控制器和请求处理器内处理的异常并不会以指标tag标记的方式（如上表）被记录。此时，应用程序可以通过<a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/features.html#features.developing-web-applications.spring-mvc.error-handling">将异常设置为请求的属性</a>来确保该异常处理不会被遗漏。</p>
</blockquote>
<h3 id="Jersey-Server指标（Jersey-Server-Metrics）"><a href="#Jersey-Server指标（Jersey-Server-Metrics）" class="headerlink" title="Jersey Server指标（Jersey Server Metrics）"></a>Jersey Server指标（Jersey Server Metrics）</h3><p>只要Micrometer的<code>micrometer-jersey2</code>模块在classpath下，自动装配机制会开启所有由Jersey JAX-RS实现的请求。默认情况下，指标的名称前缀为<code> http.server.requests</code>。可以通过设置 <code>management.metrics.web.server.request.metric-name </code>来自定义该前缀。</p>
<p>默认情况下，Jersey server相关的指标会被增加如下tag标记：</p>
<table>
<thead>
<tr>
<th align="center">Tag</th>
<th align="center">详情</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>exception</code></td>
<td align="center">当处理请求出现异常时，被抛出的异常类的简短类名</td>
</tr>
<tr>
<td align="center"><code>method</code></td>
<td align="center">请求方法（例如：<code>GET</code>或<code>POST</code>）</td>
</tr>
<tr>
<td align="center"><code>outcome</code></td>
<td align="center">基于响应状态码的描述，1xx：<code>INFORMATIONAL</code>；2xx：<code>SUCCESS</code>；3xx：<code>REDIRECTION</code>；4xx：<code>CLIENT_ERROR</code>；5xx：<code>SERVER_ERROR</code></td>
</tr>
<tr>
<td align="center"><code>status</code></td>
<td align="center">响应状态码（例如<code>200</code>或<code>500</code>）</td>
</tr>
<tr>
<td align="center"><code>url</code></td>
<td align="center">在变量替换之前使用请求的URI模板(例如，<code>/api/person/&#123;id&#125;</code>)</td>
</tr>
</tbody></table>
<p>如果想自定义这些tag标记，提供一个实现了<code>JerseyTagsProvider</code>接口的<code>@Bean</code>即可</p>
<h3 id="HTTP-Client指标（HTTP-Client-Metrics）"><a href="#HTTP-Client指标（HTTP-Client-Metrics）" class="headerlink" title="HTTP Client指标（HTTP Client Metrics）"></a>HTTP Client指标（HTTP Client Metrics）</h3><p>Spring Boot Actuator提供了对<code>RestTemplate</code>和<code>WebClient</code>的监测管理。不过使用需要通过注入自动装配的builder来创建实例：</p>
<ul>
<li>通过<code>RestTemplateBuilder</code>创建<code>RestTemplate</code></li>
<li>通过<code>WebClient.Builder</code>创建<code>WebClient</code></li>
</ul>
<p>也可以使用自定义的<code>MetricsRestTemplateCustomizer</code>和<code>MetricsWebClientCustomizer</code>实现同相同目的。</p>
<p>默认情况下，指标的名称前缀为<code> http.client.requests</code>，可以通过修改<code>management.metrics.web.client.request.metric-name</code>来自定义该前缀</p>
<p>默认情况下，相关指标会增加如下tag标记：</p>
<table>
<thead>
<tr>
<th align="center">Tag</th>
<th align="center">详情</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>clientName</code></td>
<td align="center">URI的主机地址</td>
</tr>
<tr>
<td align="center"><code>method</code></td>
<td align="center">请求方法（例如：<code>GET</code>或<code>POST</code>）</td>
</tr>
<tr>
<td align="center"><code>outcome</code></td>
<td align="center">基于响应状态码的返回值描述，1xx：<code>INFORMATIONAL</code>；2xx：<code>SUCCESS</code>；3xx：<code>REDIRECTION</code>；4xx：<code>CLIENT_ERROR</code>；5xx：<code>SERVER_ERROR</code></td>
</tr>
<tr>
<td align="center"><code>status</code></td>
<td align="center">正常情况下为HTTP响应状态码（例如<code>200</code>或<code>500</code>），出现I&#x2F;O异常时为<code>IO_ERROR</code>，其他情况为<code>CLIENT_ERROR</code></td>
</tr>
<tr>
<td align="center"><code>url</code></td>
<td align="center">在变量替换之前使用请求的URI模板(例如，<code>/api/person/&#123;id&#125;</code>)</td>
</tr>
</tbody></table>
<p>可以提供一个实现了<code>RestTemplateExchangeTagsProvider</code>或<code>WebClientExchangeTagsProvider</code>接口的<code>@Bean</code>，实现对tag标记的自定义。<code>RestTemplateExchangeTags</code> and <code>WebClientExchangeTags</code>内也包含方便使用的静态函数。</p>
<h3 id="Tomcat指标（-Tomcat-Metrics）"><a href="#Tomcat指标（-Tomcat-Metrics）" class="headerlink" title="Tomcat指标（ Tomcat Metrics）"></a>Tomcat指标（ Tomcat Metrics）</h3><p>当<code>MBeanRegistry</code>注册表被启用时，自动装配机制会开启对Tomcat的监测。默认情况下，<code>MBeanRegistry</code>是关闭的，可以通过将<code>server.tomcat.mbeanregistry.enabled</code>设置为<code>true</code>来开启。</p>
<p>Tomcat指标以<code>tomcat.</code>为前缀。</p>
<h3 id="缓存指标（Cache-Metrics）"><a href="#缓存指标（Cache-Metrics）" class="headerlink" title="缓存指标（Cache Metrics）"></a>缓存指标（Cache Metrics）</h3><p>当应用启动时，自动装配机制会开启所有已生效<code>Caches</code>的监测，并以<code>cache.</code>为前缀。这是基础监测指标的标准化配置（Cache instrumentation is standardized for a basic set of metrics.）。此外，某些缓存专属指标也是生效的。如下缓存库已经被支持：</p>
<ul>
<li>Caffeine</li>
<li>EhCache 2</li>
<li>Hazelcast</li>
<li>Any compliant JCache (JSR-107) implementation</li>
<li>Redis</li>
</ul>
<p>这些指标会被附加两个tag标记，它们分别是以缓存命名的tag，以及实现了<code>CacheManager</code>的bean的名字。</p>
<blockquote>
<p><strong>提示</strong></p>
<p>只有启动时被配置的缓存会被绑定到指标注册表中。对于那些没有在配置中定义的缓存，例如当启动后，实时地或编程方式创建的缓存，则需要显示地进行注册。<code>CacheMetricsRegistrar</code> bean提供了简单易用的注册机制。</p>
</blockquote>
<h3 id="数据源指标（DataSource-Metrics）"><a href="#数据源指标（DataSource-Metrics）" class="headerlink" title="数据源指标（DataSource Metrics）"></a>数据源指标（DataSource Metrics）</h3><p>自动装配会启用对所有可用<code>DataSource</code>对象的监测，这些指标以<code>jdbc.connections</code>为前缀。数据源测量结果以gauges的方式显示连接池内当前活动连接数、空闲连接数、最大连接数和最小连接数。</p>
<p>这些指标也会被附加tag标记，这些tag标记的名字就是<code>DataSource</code> bean的名字。</p>
<blockquote>
<p><strong>提示</strong></p>
<p>默认情况下，对于所有支持的数据源，Spring Boot都提供了元数据（metadata）。如果使用的数据源不支持这个开箱即用的特性，可以额外提供<code>DataSourcePoolMetadataProvider</code>，可以到<code>DataSourcePoolMetadataProvidersConfiguration</code>查看使用示例。</p>
</blockquote>
<h3 id="Hibernate指标（-Hibernate-Metrics）"><a href="#Hibernate指标（-Hibernate-Metrics）" class="headerlink" title="Hibernate指标（ Hibernate Metrics）"></a>Hibernate指标（ Hibernate Metrics）</h3><p>如果<code>org.hibernate:hibernate-micrometer</code>在classpath内，所有生效且开启统计<code>EntityManagerFactory</code>实例都会被监测，指标名为：<code>hibernate</code>。</p>
<p>这些指标也会被附加tag标记，tag标记的名字就是<code>EntityManagerFactory </code> bean的名字。</p>
<p>如果要开启统计功能，JPA属性<code>hibernate.generate_statistics</code>必须要被设置为<code>true</code>，可以通过如下示例将<code>EntityManagerFactory</code>开启：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">jpa:</span></span><br><span class="line">    <span class="attr">properties:</span></span><br><span class="line">      <span class="string">&quot;[hibernate.generate_statistics]&quot;</span><span class="string">:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="Spring-Data-Repository指标（Spring-Data-Repository-Metrics）"><a href="#Spring-Data-Repository指标（Spring-Data-Repository-Metrics）" class="headerlink" title="Spring Data Repository指标（Spring Data Repository Metrics）"></a>Spring Data Repository指标（Spring Data Repository Metrics）</h3><p>自动装配机制会开启Spring Data <code>Repository</code>的所有函数调用的监测。默认情况下，指标名为<code>spring.data.repository.invocations</code>，可以通过<code>management.metrics.data.repository.metric-name</code>对其修改。</p>
<p><code>Repository</code>类及其方法支持<code>@Timed</code>（查看<a href="##@Timed%E6%B3%A8%E8%A7%A3%E6%94%AF%E6%8C%81%EF%BC%88@Timed-Annotation-Support%EF%BC%89">@Timed注解支持</a>了解更多细节）注解。如果不想对所有的<code>Repository</code>调用都开启指标监控，可以将<code>management.metrics.data.repository.autotime.enabled</code>设置为false，并且单独使用<code>@Timed</code>。</p>
<p>默认情况下，<code>Repository</code>相关的指标会被附加如下tag标记：</p>
<table>
<thead>
<tr>
<th align="center">Tag</th>
<th align="center">详情</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>repository</code></td>
<td align="center"><code>Repository</code>的简单类名</td>
</tr>
<tr>
<td align="center"><code>method</code></td>
<td align="center">被调用的<code>Repository</code>方法名</td>
</tr>
<tr>
<td align="center"><code>state</code></td>
<td align="center">状态（<code>SUCCESS</code>, <code>ERROR</code>, <code>CANCELED</code> or <code>RUNNING</code>）</td>
</tr>
<tr>
<td align="center"><code>exception</code></td>
<td align="center">当调用出现异常时，异常类的简单类名</td>
</tr>
</tbody></table>
<p>如果想修改这些默认的tag标记，配置一个实现了<code>RepositoryTagsProvider</code>接口的<code>@Bean</code>。</p>
<h3 id="RabbitMQ指标（RabbitMQ-Metrics）"><a href="#RabbitMQ指标（RabbitMQ-Metrics）" class="headerlink" title="RabbitMQ指标（RabbitMQ Metrics）"></a>RabbitMQ指标（RabbitMQ Metrics）</h3><p>自动装配机制会开启所有可用的<code>RabbitMQ </code>连接的监控，指标名为<code>rabbitmq</code>。</p>
<h3 id="Spring-Integration指标（Spring-Integration-Metrics）"><a href="#Spring-Integration指标（Spring-Integration-Metrics）" class="headerlink" title="Spring Integration指标（Spring Integration Metrics）"></a>Spring Integration指标（Spring Integration Metrics）</h3><p>任何时候，当<code>MeterRegistry</code> bean可用时，Spring Integration会自动提供<a href="https://docs.spring.io/spring-integration/docs/5.5.0/reference/html/system-management.html#micrometer-integration">基于<code>Micrometer</code>的监测支持</a>。并且指标会被发布在<code>spring.integration.</code>下面。</p>
<h3 id="Kafka指标（Kafka-Metrics）"><a href="#Kafka指标（Kafka-Metrics）" class="headerlink" title="Kafka指标（Kafka Metrics）"></a>Kafka指标（Kafka Metrics）</h3><p>自动装配机制会分别为自动装配的消费者工厂（consumer factory）和生产者工厂（producer factory）注册一个 <code>MicrometerConsumerListener</code>和 <code>MicrometerProducerListener</code>。也会为<code>StreamsBuilderFactoryBean</code>注册一个<code>KafkaStreamsMicrometerListener</code>。更多详情，请参考Spring Kafka文档的 <a href="https://docs.spring.io/spring-kafka/docs/2.7.1/reference/html/#micrometer-native">Micrometer原生指标</a>。</p>
<h3 id="MongoDB指标（MongoDB-Metrics）"><a href="#MongoDB指标（MongoDB-Metrics）" class="headerlink" title="MongoDB指标（MongoDB Metrics）"></a>MongoDB指标（MongoDB Metrics）</h3><h4 id="命令指标（Command-Metrics）"><a href="#命令指标（Command-Metrics）" class="headerlink" title="命令指标（Command Metrics）"></a>命令指标（Command Metrics）</h4><p>自动装配机制会为自动装配的<code>MongoClient</code>注册一个<code>MongoMetricsCommandListener</code>。</p>
<p>对于mongoDB driver下的每一条指令，都会创建一个名为<code>mongodb.driver.commands</code>的计时器指标（timer metric）。每个指标默认会附加如下tag标记：</p>
<table>
<thead>
<tr>
<th align="center">Tag</th>
<th align="center">详情</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>command</code></td>
<td align="center">命令的名称</td>
</tr>
<tr>
<td align="center"><code>cluster.id</code></td>
<td align="center">执行命令的monoDB集群的id</td>
</tr>
<tr>
<td align="center"><code>server.address</code></td>
<td align="center">执行命令的mongoDB的的服务器地址</td>
</tr>
<tr>
<td align="center"><code>status</code></td>
<td align="center">命令返回结果（<code>SUCCESS</code>或<code>FAILED</code>中的一个）</td>
</tr>
</tbody></table>
<p>如果想替换默认的指标tag标记，可以定义一个<code>MongoCommandTagsProvider</code> bean，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCommandTagsProviderConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MongoCommandTagsProvider <span class="title function_">customCommandTagsProvider</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomCommandTagsProvider</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想禁用上述命令指标，可以按照如下指令进行设置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">mongo:</span></span><br><span class="line">      <span class="attr">command:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h4 id="连接池指标（Connection-Pool-Metrics）"><a href="#连接池指标（Connection-Pool-Metrics）" class="headerlink" title="连接池指标（Connection Pool Metrics）"></a>连接池指标（Connection Pool Metrics）</h4><p>自动装配机制会为自动装配的<code>MongoClient</code>注册一个<code>MongoMetricsConnectionPoolListener </code>。</p>
<p>连接池会创建如下gauge指标：</p>
<ul>
<li><code>mongodb.driver.pool.size</code>上报当前连接池内的连接数量，包括空闲和使用者的连接。</li>
<li><code>mongodb.driver.pool.checkedout</code>上报连接池内正在使用的连接数量</li>
<li><code>mongodb.driver.pool.waitqueuesize</code>上报连接池等待队列的大小</li>
</ul>
<p>默认情况下，每个指标都会被附加如下tag标记：</p>
<table>
<thead>
<tr>
<th align="center">Tag</th>
<th align="center">详情</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>cluster.id</code></td>
<td align="center">当前连接池对应的monoDB集群的id</td>
</tr>
<tr>
<td align="center"><code>server.address</code></td>
<td align="center">当前连接池对应的monoDB集群的服务器地址</td>
</tr>
</tbody></table>
<p>如果想替换默认的指标tag标记，可以定义一个<code>MongoConnectionPoolTagsProvider</code> bean，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConnectionPoolTagsProviderConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MongoConnectionPoolTagsProvider <span class="title function_">customConnectionPoolTagsProvider</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomConnectionPoolTagsProvider</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想禁用上述连接池指标，可以按照如下指令进行设置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">mongo:</span></span><br><span class="line">      <span class="attr">connectionpool:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="Timed注解支持（-Timed-Annotation-Support）"><a href="#Timed注解支持（-Timed-Annotation-Support）" class="headerlink" title="@Timed注解支持（@Timed Annotation Support）"></a>@Timed注解支持（@Timed Annotation Support）</h3><p><code>io.micrometer.core.annotation</code>包内的<code>@Timed</code>注解可以被上述列出的某些指标支持。一旦被支持，这个注解既可以用在类层级，也可以用在函数层级上。</p>
<p>例如，如下代码展示了这个注解如何监测<code>@RestController</code>类的所有请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Timed</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/api/addresses&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Address&gt; <span class="title function_">listAddress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/api/people&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Person&gt; <span class="title function_">listPeople</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果只想监测某一个请求，可以将注解从类层级移到方法层级上：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/api/addresses&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Address&gt; <span class="title function_">listAddress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/api/people&quot;)</span></span><br><span class="line">    <span class="meta">@Timed</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Person&gt; <span class="title function_">listPeople</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想修改方法层级的指标信息，可以对该注解组合使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Timed</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/api/addresses&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Address&gt; <span class="title function_">listAddress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/api/people&quot;)</span></span><br><span class="line">    <span class="meta">@Timed(extraTags = &#123; &quot;region&quot;, &quot;us-east-1&quot; &#125;)</span></span><br><span class="line">    <span class="meta">@Timed(value = &quot;all.people&quot;, longTask = true)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Person&gt; <span class="title function_">listPeople</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>提示</strong></p>
<p>带有<code>longTask = true</code>的<code>@Timed</code>注解为方法启用一个长时间任务计时器指标（long task timer）。该指标需要单独的名称，并且可以与短时间任务计时器指标进行叠加。（译者注：此处没有说明叠加内容，如何叠加，需要后续进一步研究）</p>
</blockquote>
<h2 id="注册自定义指标（Registering-Custom-Metrics）"><a href="#注册自定义指标（Registering-Custom-Metrics）" class="headerlink" title="注册自定义指标（Registering Custom Metrics）"></a>注册自定义指标（Registering Custom Metrics）</h2><p>如果想注册自定义指标，可以将<code>MeterRegistry</code>注入到自己的组件中，如下面例子所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Dictionary dictionary;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyBean</span><span class="params">(MeterRegistry registry)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dictionary = Dictionary.load();</span><br><span class="line">        registry.gauge(<span class="string">&quot;dictionary.size&quot;</span>, Tags.empty(), <span class="built_in">this</span>.dictionary.getWords().size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要注册的指标需要依赖其他bean，建议使用<code>MeterBinder</code>来注册，如下面的例子所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMeterBinderConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MeterBinder <span class="title function_">queueSize</span><span class="params">(Queue queue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (registry) -&gt; Gauge.builder(<span class="string">&quot;queueSize&quot;</span>, queue::size).register(registry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>MeterBinder</code>可以确保依赖的正确性，并且在指标被检索时，这个bean是可用的。如果经常重复性跨组件或应用监测一组指标，<code>MeterBinder</code>会非常有用。</p>
<blockquote>
<p><strong>提示</strong></p>
<p>默认情况下，所有的<code>MeterBinder</code> bean会自动绑定到由Spring管理的<code>MeterRegistery</code>中。</p>
</blockquote>
<h2 id="自定义特定指标（Customizing-Individual-Metrics）"><a href="#自定义特定指标（Customizing-Individual-Metrics）" class="headerlink" title="自定义特定指标（Customizing Individual Metrics）"></a>自定义特定指标（Customizing Individual Metrics）</h2><p>如果想对特定的<code>Meter</code>实例进行自定义，可用使用<code>io.micrometer.core.instrument.config.MeterFilte</code>接口。</p>
<p>例如，如果想对所有以<code>com.example</code>开头的指标进行自定义：将<code>mytag.region</code>改为<code>mytag.area</code>，可用按照如下示例操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMetricsFilterConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MeterFilter <span class="title function_">renameRegionTagMeterFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> MeterFilter.renameTag(<span class="string">&quot;com.example&quot;</span>, <span class="string">&quot;mytag.region&quot;</span>, <span class="string">&quot;mytag.area&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>提示</strong></p>
<p>默认情况下，所有<code>MeterFilter</code> bean会自动绑定到由Spring管理的<code>MeterRegistery</code>中。要确保将自定义指标注册到由Spring管理的<code>MeterRegistery</code>上，并且在<code>Metrics</code>中不能含有静态函数。而全局的注册表并没有被Spring管理！</p>
</blockquote>
<h4 id="自定义通用Tag标记（Common-Tags）"><a href="#自定义通用Tag标记（Common-Tags）" class="headerlink" title="自定义通用Tag标记（Common Tags）"></a>自定义通用Tag标记（Common Tags）</h4><p>通用Tag标记常用来对诸如主机名（host）、实例名（instance）、地区（region）、集群（stack）等操作环境进行更细粒度的划分。通用Tag标记会被附加到所有的指标上，可以按照如下示例进行配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">tags:</span></span><br><span class="line">      <span class="attr">region:</span> <span class="string">&quot;us-east-1&quot;</span></span><br><span class="line">      <span class="attr">stack:</span> <span class="string">&quot;prod&quot;</span></span><br></pre></td></tr></table></figure>

<p>以上示例中，会分别为每个指标增加两个tag标记：<code>region:us-east-1</code>和<code>stack:prod</code>。</p>
<blockquote>
<p><strong>提示</strong></p>
<p>如果使用Graphite，通用tag标记的顺序非常重要。因为这个方式并不能保证通用tag标记的的属性，Graphite用户请使用<code>MeterFilter</code>的方式。</p>
</blockquote>
<h4 id="精确指标配置（Per-meter-Properties）"><a href="#精确指标配置（Per-meter-Properties）" class="headerlink" title="精确指标配置（Per-meter Properties）"></a>精确指标配置（Per-meter Properties）</h4><p>除了<code>MeterFilter</code>之外，也可以通过配置对每一个指标进行调整。可以在配置中指定指标的名称，所有以该名称为前缀的指标都会被调整。下面示例中，所有以<code>example.remote</code>开头的指标都会被禁用：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">    <span class="attr">enable:</span></span><br><span class="line">      <span class="attr">example:</span></span><br><span class="line">        <span class="attr">remote:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>如下配置都可以应用到指标的调整：</p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">详情</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>management.metrics.enable</code></td>
<td align="center">是否禁止指标</td>
</tr>
<tr>
<td align="center"><code>management.metrics.distribution.percentiles-histogram</code></td>
<td align="center">是否使用于百分比直方图（Whether to publish a histogram suitable for computing aggregable (across dimension) percentile approximations.）</td>
</tr>
<tr>
<td align="center"><code>management.metrics.distribution.minimum-expected-value</code>, <code>management.metrics.distribution.maximum-expected-value</code></td>
<td align="center">通过设置监测有效范围可以减少直方图中桶的数量（Publish less histogram buckets by clamping the range of expected values.）</td>
</tr>
<tr>
<td align="center"><code>management.metrics.distribution.percentiles</code></td>
<td align="center">需要被统计的百分位数（Publish percentile values computed in your application）</td>
</tr>
<tr>
<td align="center"><code>management.metrics.distribution.slo</code></td>
<td align="center">额外自定义的应用级的直方图（Publish a cumulative histogram with buckets defined by your service-level objectives）</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>译者提示</strong></p>
<ul>
<li>关于上述配置可以参考IBM developerWorks的一篇文章<a href="(https://github.com/labulaka521/ibm_bak/blob/main/ibm_articles/%E4%BD%BF%E7%94%A8Micrometer%E8%AE%B0%E5%BD%95Java%E5%BA%94%E7%94%A8%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87.md)">《使用 Micrometer 记录 Java 应用性能指标》</a>（可惜网站已经关闭，该链接为github的备份）</li>
<li><code>management.metrics.enable</code>是一个map，key为指标ID前缀（最长的优先匹配），value为Boolean</li>
<li><code>management.metrics.distribution.percentiles</code> 代表要统计的百分位数，这是一个map，key为指标ID前缀（最长的优先匹配），value为double型且取值区间为[0,1]的数组，代表某指标要统计的百分位数。百分位数是统计学指标，详情可以参考<a href="https://zh.wikipedia.org/wiki/%E7%99%BE%E5%88%86%E4%BD%8D%E6%95%B0">wikipedia词条</a></li>
<li><code>management.metrics.distribution.slo</code>  针对的是整个应用，而无法针对某一个指标进行单独配置</li>
</ul>
</blockquote>
<p>更多关于<code>percentiles-histogram</code>和<code>percentiles</code>的详情，可以参考micrometer文档的 <a href="https://micrometer.io/docs/concepts#_histograms_and_percentiles">“直方图和百分位数”</a> 。</p>
<h2 id="指标端点（Metrics-Endpoint）"><a href="#指标端点（Metrics-Endpoint）" class="headerlink" title="指标端点（Metrics Endpoint）"></a>指标端点（Metrics Endpoint）</h2><p>Spring Boot提供了一个<code>metrics</code>端点，作为诊断性的目的，可以用来检查应用程序收集到的指标。这个端点默认没有被暴露出来，可以查看<a href="##%E6%9A%B4%E9%9C%B2%E7%AB%AF%E7%82%B9%EF%BC%88Exposing-Endpoints%EF%BC%89">暴露端点（Exposing Endpoints）</a>获得更多细节。</p>
<p><code>/actuator/metrics</code>列出了所有可用的端点的名称，可以通过指定某指标的名称进一步查看更详细信息，例如：<code>/actuator/metrics/jvm.memory.max</code>。</p>
<blockquote>
<p><strong>提示</strong></p>
<p>此处使用的指标名称应该和代码中的名字相匹配，而不是将指标名称进行映射转换后，特定监控系统的指标名称。例如，Prometheus使用的是蛇形命名法，<code>jvm.memory.max</code>会被映射转换成<code>jvm_memory_max</code>。此时，在<code>metrics</code>端点中，仍然应该使用<code>jvm.memory.max</code>。</p>
</blockquote>
<p>可以在查询语句上增加任意数量的查询参数：<code>tag=KEY:VALUE</code>，从而获得某一维度上的详细指标，例如：<code>/actuator/metrics/jvm.memory.max?tag=area:nonheap</code>。</p>
<blockquote>
<p><strong>提示</strong></p>
<p><code>measurements</code>字段是某个指标下所有tag的统计数据的总和，在上面的例子中，这个数据是堆内存中“Code Cache”、“Compressed Class Space”和“Metaspace”各自最大值的总和，如果只想查看“Metaspace”的的最大值，可用在查询语句上增加额外的tag标记：<code>tag=id:Metaspace</code>，例如：<code>/actuator/metrics/jvm.memory.max?tag=area:nonheap&amp;tag=id:Metaspace</code></p>
</blockquote>
<h1 id="审计（Auditing）"><a href="#审计（Auditing）" class="headerlink" title="审计（Auditing）"></a>审计（Auditing）</h1><p>一旦Spring Security被启用，Spring Boot Actuator就有了一个灵活的审计框架可以发布事件（默认情况下，包括“认证成功”（authentication success）、“失败”（failure）和“拒绝访问”（access denied）的异常）。该特性对于报告和实现基于身份验证失败的锁定策略非常有用。</p>
<p>可以通过定义一个<code>AuditEventRepository</code>类型的bean开启审计功能。为了方便用户，Spring Boot内置了一个<code>InMemoryAuditEventRepository</code>。不过它的能力有限，我们建议只在开发环境下使用。至于生产环境，需要创建自己的<code>AuditEventRepository</code>。</p>
<h2 id="自定义审计（Custom-Auditing）"><a href="#自定义审计（Custom-Auditing）" class="headerlink" title="自定义审计（Custom Auditing）"></a>自定义审计（Custom Auditing）</h2><p>如果想自定义安全事件，可以提供自定义的<code>AbstractAuthenticationAuditListener</code>和<code>AbstractAuthorizationAuditListener</code>的实现。</p>
<p>您还可以对自己的业务事件使用审计服务。要做到这一点，可以将<code>AuditEventRepository</code> bean注入到自己的组件中并直接使用它，或者使用<code>Spring ApplicationEventPublisher</code>（实现<code>ApplicationEventPublisherAware</code>接口）发布一个<code>AuditApplicationEvent</code>。</p>
<h1 id="HTTP追踪（HTTP-Tracing）"><a href="#HTTP追踪（HTTP-Tracing）" class="headerlink" title="HTTP追踪（HTTP Tracing）"></a>HTTP追踪（HTTP Tracing）</h1><p>可以在应用中提供一个<code>HttpTraceRepository</code>类型的bean开启HTTP追踪功能。为了方便用户，Spring Boot内置了一个<code>InMemoryHttpTraceRepository </code>用于存储最近100条请求和响应。相比于其他最终方案，默认提供的<code>InMemoryHttpTraceRepository</code>功能有限，我们建议仅在开发环境下使用。对于生产环境，请使用具备生产就绪特性的追踪、观测方案。例如ZipKin或Spring Cloud Sleuth。此外，也可以提供一个自定义的<code>HttpTraceRepository</code>满足业务需求。</p>
<p><code>httptrace</code>端点可以用来获取存储在<code>HttpTraceRepository</code>中的请求响应的信息。</p>
<h2 id="自定义HTTP追踪（Custom-HTTP-tracing）"><a href="#自定义HTTP追踪（Custom-HTTP-tracing）" class="headerlink" title="自定义HTTP追踪（Custom HTTP tracing）"></a>自定义HTTP追踪（Custom HTTP tracing）</h2><p>如果想自定义追踪数据，使用<code>management.trace.http.include</code>。对于更加深入的自定义，可以考虑注册自定义实现的<code>HttpExchangeTracer</code> bean。</p>
<h1 id="进程监控（Process-Monitoring）"><a href="#进程监控（Process-Monitoring）" class="headerlink" title="进程监控（Process Monitoring）"></a>进程监控（Process Monitoring）</h1><p>在Spring Boot中，有两个类可以用来创建文件，这在监控进程时非常有用：</p>
<ul>
<li><code>ApplicationPidFileWriter</code> 可以创建一个包含应用PID的文件（默认情况下，文件位于应用目录，文件名为：<code>application.pid</code>）</li>
<li><code>WebServerPortFileWriter</code>创建一个（或多个）包含当前web服务器的端口的文件</li>
</ul>
<p>这两个类默认是没有被激活，可以通过如下方式将其开启：</p>
<ul>
<li><a href="##%E6%89%A9%E5%B1%95%E9%85%8D%E7%BD%AE%EF%BC%88Extending-Configuration%EF%BC%89">扩展配置</a></li>
<li><a href="##%E7%BC%96%E7%A8%8B%E6%96%B9%E5%BC%8F%E6%94%AF%E6%8C%81%EF%BC%88Programmatically%EF%BC%89">编程方式</a></li>
</ul>
<h2 id="扩展配置（Extending-Configuration）"><a href="#扩展配置（Extending-Configuration）" class="headerlink" title="扩展配置（Extending Configuration）"></a>扩展配置（Extending Configuration）</h2><p>在<code>META-INF/spring.factories</code>中，你可以通过如下方式激活一个或多个监听，从而实现PID文件的写入：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">org.springframework.context.ApplicationListener</span>=<span class="string">\</span></span><br><span class="line"><span class="string">org.springframework.boot.context.ApplicationPidFileWriter,\</span></span><br><span class="line"><span class="string">org.springframework.boot.web.context.WebServerPortFileWriter</span></span><br></pre></td></tr></table></figure>

<h2 id="编程方式支持（Programmatically）"><a href="#编程方式支持（Programmatically）" class="headerlink" title="编程方式支持（Programmatically）"></a>编程方式支持（Programmatically）</h2><p>也可以通过调用<code>SpringApplication.addListeners(…)</code>来激活一个监听器，并传入一个<code>Writer</code>对象，这种方式允许你在<code>Writer</code>的构造函数中自定义文件名、文件路径。</p>
<h1 id="Cloud-Foundry-支持（Cloud-Foundry-Support）"><a href="#Cloud-Foundry-支持（Cloud-Foundry-Support）" class="headerlink" title="Cloud Foundry 支持（Cloud Foundry Support）"></a>Cloud Foundry 支持（Cloud Foundry Support）</h1><p>Spring Boot Actuator对Cloud Foundry提供了额外支持，当应用被部署到兼容的Cloud Foundry实例时，该特性会被激活。<code>/cloudfoundryapplication</code>提供了另外一种到所有端点<code>@Endpoint</code> bean安全路由。</p>
<blockquote>
<p><strong>提示</strong></p>
<p>对于常规用户来说，<code>/cloudfoundryapplication</code>路径不能被直接访问。如果想使用该端点，需要在请求中提供一个UAA令牌（UAA token）。</p>
</blockquote>
<h2 id="禁用Cloud-Foundry-Actuator支持（Disabling-Extended-Cloud-Foundry-Actuator-Support）"><a href="#禁用Cloud-Foundry-Actuator支持（Disabling-Extended-Cloud-Foundry-Actuator-Support）" class="headerlink" title="禁用Cloud Foundry Actuator支持（Disabling Extended Cloud Foundry Actuator Support）"></a>禁用Cloud Foundry Actuator支持（Disabling Extended Cloud Foundry Actuator Support）</h2><p>如果想完全禁用<code>/cloudfoundryapplication</code>端点，可以进行如下配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">cloudfoundry:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h2 id="Cloud-Foundry自签名证书（Cloud-Foundry-Self-signed-Certificates）"><a href="#Cloud-Foundry自签名证书（Cloud-Foundry-Self-signed-Certificates）" class="headerlink" title="Cloud Foundry自签名证书（Cloud Foundry Self-signed Certificates）"></a>Cloud Foundry自签名证书（Cloud Foundry Self-signed Certificates）</h2><p>默认情况下，<code>/cloudfoundry</code>端点的安全认证会对Cloud Foundry服务进行SSL调用。如果您的Cloud Foundry UAA或Cloud Controller服务使用自签名证书，您需要设置以下属性：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">cloudfoundry:</span></span><br><span class="line">    <span class="attr">skip-ssl-validation:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="自定义上下文路径（Custom-Context-Path）"><a href="#自定义上下文路径（Custom-Context-Path）" class="headerlink" title="自定义上下文路径（Custom Context Path）"></a>自定义上下文路径（Custom Context Path）</h2><p>如果服务器的上下文路径并非<code>/</code>，而是其他路径，那么根路径下的Cloud Foundry端点会不可用。例如，对于配置<code>server.servlet.context-path=/app</code>，Cloud Foundry端点路径为：<code>/app/cloudfoundryapplication/*</code>。</p>
<p>如果想实现这个需求：不管服务器的上下文路径如何配置， Cloud Foundry端点的路径都位于：<code>/cloudfoundryapplication/*</code>，需要在应用中进行配置，至于配置方式，根据所使用的web服务器的不同而不尽相同。以Tomcat为例，可以使用如下配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCloudFoundryConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TomcatServletWebServerFactory <span class="title function_">servletWebServerFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TomcatServletWebServerFactory</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">prepareContext</span><span class="params">(Host host, ServletContextInitializer[] initializers)</span> &#123;</span><br><span class="line">                <span class="built_in">super</span>.prepareContext(host, initializers);</span><br><span class="line">                <span class="type">StandardContext</span> <span class="variable">child</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardContext</span>();</span><br><span class="line">                child.addLifecycleListener(<span class="keyword">new</span> <span class="title class_">Tomcat</span>.FixContextListener());</span><br><span class="line">                child.setPath(<span class="string">&quot;/cloudfoundryapplication&quot;</span>);</span><br><span class="line">                <span class="type">ServletContainerInitializer</span> <span class="variable">initializer</span> <span class="operator">=</span> getServletContextInitializer(getContextPath());</span><br><span class="line">                child.addServletContainerInitializer(initializer, Collections.emptySet());</span><br><span class="line">                child.setCrossContext(<span class="literal">true</span>);</span><br><span class="line">                host.addChild(child);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServletContainerInitializer <span class="title function_">getServletContextInitializer</span><span class="params">(String contextPath)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (classes, context) -&gt; &#123;</span><br><span class="line">            <span class="type">Servlet</span> <span class="variable">servlet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericServlet</span>() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">                    <span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> req.getServletContext().getContext(contextPath);</span><br><span class="line">                    context.getRequestDispatcher(<span class="string">&quot;/cloudfoundryapplication&quot;</span>).forward(req, res);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;;</span><br><span class="line">            context.addServlet(<span class="string">&quot;cloudfoundry&quot;</span>, servlet).addMapping(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="接下来要读什么（What-to-Read-Next）"><a href="#接下来要读什么（What-to-Read-Next）" class="headerlink" title="接下来要读什么（What to Read Next）"></a>接下来要读什么（What to Read Next）</h1><p>你可能想读一些关于图形工具的文档，例如Graphite](<a href="https://graphiteapp.org/">https://graphiteapp.org/</a>)</p>
<p>或者，如果想继续深挖，可以阅读<a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/deployment.html#deployment">部署选项</a>相关知识，或者提前了解有关Spring Boot<a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/html/build-tool-plugins.html#build-tool-plugins">构建工具插件</a>的知识。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" rel="tag"># 源码阅读</a>
              <a href="/tags/spring/" rel="tag"># spring</a>
              <a href="/tags/spring-boot/" rel="tag"># spring boot</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/04/22/%E5%85%B3%E4%BA%8Ehotspot%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%ADCardTable%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%80%E7%82%B9%E7%96%91%E6%83%91%E6%8E%A2%E7%A9%B6/" rel="prev" title="关于hotspot虚拟机中CardTable数组的一点疑惑探究">
                  <i class="fa fa-angle-left"></i> 关于hotspot虚拟机中CardTable数组的一点疑惑探究
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/01/11/%E7%AC%AC1%E9%83%A8%E5%88%86%EF%BC%9AG1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%AE%80%E4%BB%8B/" rel="next" title="[译]第一篇：G1垃圾回收器简介">
                  [译]第一篇：G1垃圾回收器简介 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">临江听雨</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
